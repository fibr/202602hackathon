Directory structure:
└── forgisx-hackathon_forgis_dobot_urr/
    ├── README.md
    ├── docker-compose.yml
    ├── assets/
    │   ├── camera_server/
    │   │   ├── camera_server.py
    │   │   ├── pyproject.toml
    │   │   └── requirements.txt
    │   ├── dobot-driver/
    │   │   ├── Dockerfile
    │   │   └── scripts/
    │   │       └── start_driver.sh
    │   └── urdriver/
    │       ├── Dockerfile
    │       ├── pyproject.toml
    │       └── scripts/
    │           └── start_driver.sh
    ├── backend/
    │   ├── Dockerfile
    │   ├── pyproject.toml
    │   ├── scripts/
    │   │   └── start_backend.sh
    │   └── src/
    │       ├── main.py
    │       ├── api/
    │       │   ├── __init__.py
    │       │   ├── app.py
    │       │   ├── routes/
    │       │   │   ├── __init__.py
    │       │   │   ├── camera.py
    │       │   │   ├── flows.py
    │       │   │   └── skills.py
    │       │   └── websocket/
    │       │       ├── __init__.py
    │       │       ├── events.py
    │       │       └── manager.py
    │       ├── data/
    │       │   └── flow/
    │       │       ├── dobot_test_pick.json
    │       │       ├── hand_pick_and_place.json
    │       │       └── pick_and_place_v2.json
    │       ├── executors/
    │       │   ├── __init__.py
    │       │   ├── base.py
    │       │   ├── camera_executor.py
    │       │   ├── dobot_nova5_executor.py
    │       │   ├── hand_executor.py
    │       │   ├── io_executor.py
    │       │   └── robot_executor.py
    │       ├── flow/
    │       │   ├── __init__.py
    │       │   ├── conditions.py
    │       │   ├── executor.py
    │       │   ├── loader.py
    │       │   ├── manager.py
    │       │   └── schemas.py
    │       ├── nodes/
    │       │   ├── camera_bridge_node.py
    │       │   ├── camera_node.py
    │       │   ├── covvi_hand_node.py
    │       │   ├── dobot_nova5_node.py
    │       │   └── ur_node.py
    │       └── skills/
    │           ├── __init__.py
    │           ├── base.py
    │           ├── registry.py
    │           ├── camera/
    │           │   ├── __init__.py
    │           │   ├── get_bounding_box.py
    │           │   ├── get_label.py
    │           │   ├── start_streaming.py
    │           │   └── stop_streaming.py
    │           ├── hand/
    │           │   ├── __init__.py
    │           │   ├── grip_until_contact.py
    │           │   ├── set_finger_positions.py
    │           │   └── set_grip.py
    │           ├── io/
    │           │   ├── __init__.py
    │           │   ├── set_digital_output.py
    │           │   └── wait_digital_input.py
    │           └── robot/
    │               ├── __init__.py
    │               ├── move_joint.py
    │               ├── move_linear.py
    │               ├── palletize.py
    │               └── set_tool_output.py
    ├── flows/
    │   ├── pick_and_place_v1.json
    │   ├── pick_and_place_v2.json
    │   ├── test_label.json
    │   └── .gitkeep
    ├── frontend/
    │   ├── README.md
    │   ├── components.json
    │   ├── Dockerfile
    │   ├── eslint.config.js
    │   ├── index.html
    │   ├── nginx.conf
    │   ├── package.json
    │   ├── tsconfig.app.json
    │   ├── tsconfig.json
    │   ├── tsconfig.node.json
    │   ├── vite.config.ts
    │   ├── .dockerignore
    │   └── src/
    │       ├── App.tsx
    │       ├── index.css
    │       ├── main.tsx
    │       ├── api/
    │       │   ├── cameraApi.ts
    │       │   ├── flowApi.ts
    │       │   ├── flowSocket.ts
    │       │   └── httpClient.ts
    │       ├── components/
    │       │   ├── camera/
    │       │   │   ├── BboxOverlay.tsx
    │       │   │   ├── CameraFeed.tsx
    │       │   │   ├── DetectionStatus.tsx
    │       │   │   └── StationMap.tsx
    │       │   ├── chat/
    │       │   │   └── CoderSidebar.tsx
    │       │   ├── devices/
    │       │   │   ├── AddDeviceDialog.tsx
    │       │   │   ├── DeviceList.tsx
    │       │   │   ├── DevicesSidebar.tsx
    │       │   │   ├── NodeCreatorDialog.tsx
    │       │   │   └── ParameterEditor.tsx
    │       │   ├── flow/
    │       │   │   ├── ExecutionNode.tsx
    │       │   │   ├── FlowAutoFit.tsx
    │       │   │   ├── FlowAutoFollow.tsx
    │       │   │   ├── FlowCanvas.tsx
    │       │   │   └── FlowControls.tsx
    │       │   ├── layout/
    │       │   │   ├── ContentPanel.tsx
    │       │   │   └── Topbar.tsx
    │       │   └── ui/
    │       │       ├── badge.tsx
    │       │       ├── breadcrumb.tsx
    │       │       ├── button.tsx
    │       │       ├── card.tsx
    │       │       ├── chart.tsx
    │       │       ├── dialog.tsx
    │       │       ├── input.tsx
    │       │       ├── label.tsx
    │       │       ├── scroll-area.tsx
    │       │       ├── select.tsx
    │       │       ├── separator.tsx
    │       │       ├── sonner.tsx
    │       │       ├── tabs.tsx
    │       │       └── tooltip.tsx
    │       ├── constants/
    │       │   ├── cameraConfig.ts
    │       │   ├── chatConfig.ts
    │       │   ├── deviceConfig.ts
    │       │   └── executorConfig.ts
    │       ├── hooks/
    │       │   ├── useCamera.ts
    │       │   ├── useFlowExecution.ts
    │       │   └── useFlowGeneration.ts
    │       ├── lib/
    │       │   └── utils.ts
    │       ├── pages/
    │       │   └── RobotControlPage.tsx
    │       ├── services/
    │       │   ├── flowLayoutService.ts
    │       │   └── flowTransformService.ts
    │       └── types/
    │           └── index.ts
    └── scripts/
        └── test_yolo.py

================================================
FILE: README.md
================================================
[Binary file]


================================================
FILE: docker-compose.yml
================================================
services:
  # ── UR Robot Driver ──────────────────────────────────────────
  # Enable with: docker compose --profile ur up
  # Or set COMPOSE_PROFILES=ur in .env
  ur-driver:
    profiles: [ur]
    build: ./assets/urdriver
    container_name: ur-driver
    network_mode: host
    ipc: host
    environment:
      - ROS_DOMAIN_ID=${ROS_DOMAIN_ID:-0}
    env_file: .env
    command: bash scripts/start_driver.sh
    restart: unless-stopped


  # ── DOBOT Nova 5 Driver ──────────────────────────────────────
  # Enable with: docker compose --profile dobot up
  # Or set COMPOSE_PROFILES=dobot in .env
  dobot-driver:
    profiles: [dobot]
    build: ./assets/dobot-driver
    container_name: dobot-driver
    network_mode: host
    ipc: host
    environment:
      - ROS_DOMAIN_ID=${ROS_DOMAIN_ID:-0}
    env_file: .env
    command: bash scripts/start_driver.sh
    restart: unless-stopped


  # ── Backend Application ──────────────────────────────────────
  # Runs RobotNode + PickAndPlacePipeline + FastAPI flow execution API.
  # API available at http://localhost:8000
  backend:
    build: ./backend
    container_name: forgis-backend
    network_mode: host
    ipc: host
    ports:
      - "8000:8000"  # FastAPI (Note: ignored when network_mode: host on Linux)
    environment:
      - ROS_DOMAIN_ID=${ROS_DOMAIN_ID:-0}
      - FLOWS_DIR=/app/flows
      - YOLO_MODEL=${YOLO_MODEL:-/app/weights/roboflow_logistics.pt}
      - ROBOT_TCP_OFFSET=${ROBOT_TCP_OFFSET:-0,0,0.055,0,0,0}
      - AZURE_OPENAI_ENDPOINT=${AZURE_OPENAI_ENDPOINT:-}
      - AZURE_OPENAI_API_KEY=${AZURE_OPENAI_API_KEY:-}
      - AZURE_OPENAI_API_VERSION=${AZURE_OPENAI_API_VERSION:-2024-02-15-preview}
      - AZURE_OPENAI_DEPLOYMENT=${AZURE_OPENAI_DEPLOYMENT:-gpt-4o}
    env_file: .env
    volumes:
      - ./backend/src/data/flow:/app/flows  # Persist flow definitions
      - ./backend/weights:/app/weights  # YOLO model weights
    restart: unless-stopped

  # ── Frontend ─────────────────────────────────────────────────
  frontend:
    build: ./frontend
    container_name: forgis-frontend
    network_mode: host
    ports:
      - "80:80"
    depends_on:
      - backend
    restart: unless-stopped



================================================
FILE: assets/camera_server/camera_server.py
================================================
"""
Windows RealSense Camera WebSocket Server.

Captures frames from a RealSense camera and streams them as JPEG over WebSocket.
Run this script on Windows with the RealSense camera connected.

Usage:
    python camera_server.py --port 8765 --fps 30 --width 640 --height 480
"""

import argparse
import asyncio
import logging
import signal
import sys
from typing import Optional

import cv2
import numpy as np
import pyrealsense2 as rs
import websockets

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


class RealSenseCapture:
    """Captures frames from a RealSense camera."""

    def __init__(self, width: int = 640, height: int = 480, fps: int = 30):
        self.width = width
        self.height = height
        self.fps = fps
        self.pipeline: Optional[rs.pipeline] = None
        self.config: Optional[rs.config] = None

    def start(self) -> bool:
        """Initialize and start the RealSense pipeline."""
        try:
            self.pipeline = rs.pipeline()
            self.config = rs.config()
            self.config.enable_stream(
                rs.stream.color, self.width, self.height, rs.format.rgb8, self.fps
            )
            self.pipeline.start(self.config)
            logger.info(
                f"RealSense started: {self.width}x{self.height} @ {self.fps} FPS"
            )
            return True
        except Exception as e:
            logger.error(f"Failed to start RealSense: {e}")
            return False

    def stop(self) -> None:
        """Stop the RealSense pipeline."""
        if self.pipeline:
            try:
                self.pipeline.stop()
                logger.info("RealSense stopped")
            except Exception as e:
                logger.error(f"Error stopping RealSense: {e}")

    def get_frame(self) -> Optional[np.ndarray]:
        """Capture a single frame from the camera."""
        if not self.pipeline:
            return None
        try:
            frames = self.pipeline.wait_for_frames(timeout_ms=1000)
            color_frame = frames.get_color_frame()
            if not color_frame:
                return None
            return np.asanyarray(color_frame.get_data())
        except Exception as e:
            logger.error(f"Error capturing frame: {e}")
            return None


class CameraServer:
    """WebSocket server that streams camera frames to connected clients."""

    def __init__(
        self,
        host: str = "0.0.0.0",
        port: int = 8765,
        fps: int = 30,
        width: int = 640,
        height: int = 480,
        jpeg_quality: int = 80,
    ):
        self.host = host
        self.port = port
        self.fps = fps
        self.jpeg_quality = jpeg_quality
        self.camera = RealSenseCapture(width=width, height=height, fps=fps)
        self.clients: set = set()
        self.running = False
        self._frame_interval = 1.0 / fps

    async def register_client(self, websocket) -> None:
        """Register a new client and keep connection alive."""
        client_addr = websocket.remote_address
        logger.info(f"Client connected: {client_addr}")
        self.clients.add(websocket)
        try:
            # Keep connection open, wait for close
            await websocket.wait_closed()
        finally:
            self.clients.discard(websocket)
            logger.info(f"Client disconnected: {client_addr}")

    async def broadcast_frames(self) -> None:
        """Capture and broadcast frames to all connected clients."""
        while self.running:
            if not self.clients:
                await asyncio.sleep(0.1)
                continue

            frame = self.camera.get_frame()
            if frame is None:
                await asyncio.sleep(0.01)
                continue

            # Convert RGB to BGR for OpenCV encoding
            frame_bgr = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)

            # Encode as JPEG
            encode_params = [cv2.IMWRITE_JPEG_QUALITY, self.jpeg_quality]
            success, jpeg_data = cv2.imencode(".jpg", frame_bgr, encode_params)
            if not success:
                continue

            jpeg_bytes = jpeg_data.tobytes()

            # Use websockets.broadcast for thread-safe sending
            websockets.broadcast(self.clients, jpeg_bytes)

            await asyncio.sleep(self._frame_interval)

    async def start(self) -> None:
        """Start the camera and WebSocket server."""
        if not self.camera.start():
            logger.error("Failed to start camera, exiting")
            return

        self.running = True

        # Start frame broadcast task
        broadcast_task = asyncio.create_task(self.broadcast_frames())

        # Start WebSocket server with ping disabled to avoid race conditions
        logger.info(f"WebSocket server starting on ws://{self.host}:{self.port}")
        try:
            async with websockets.serve(
                self.register_client,
                self.host,
                self.port,
                ping_interval=None,  # Disable ping to avoid race with broadcast
            ):
                await asyncio.Future()  # Run forever
        except asyncio.CancelledError:
            pass
        finally:
            self.running = False
            broadcast_task.cancel()
            try:
                await broadcast_task
            except asyncio.CancelledError:
                pass
            self.camera.stop()

    def stop(self) -> None:
        """Signal the server to stop."""
        self.running = False


def main():
    parser = argparse.ArgumentParser(
        description="RealSense Camera WebSocket Server",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument("--host", default="0.0.0.0", help="Server bind address")
    parser.add_argument("--port", type=int, default=8765, help="WebSocket port")
    parser.add_argument("--fps", type=int, default=30, help="Camera FPS")
    parser.add_argument("--width", type=int, default=640, help="Frame width")
    parser.add_argument("--height", type=int, default=480, help="Frame height")
    parser.add_argument(
        "--quality", type=int, default=80, help="JPEG quality (0-100)"
    )
    args = parser.parse_args()

    server = CameraServer(
        host=args.host,
        port=args.port,
        fps=args.fps,
        width=args.width,
        height=args.height,
        jpeg_quality=args.quality,
    )

    def signal_handler(sig, frame):
        logger.info("Shutdown signal received")
        server.stop()
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    try:
        asyncio.run(server.start())
    except KeyboardInterrupt:
        logger.info("Server stopped by user")


if __name__ == "__main__":
    main()



================================================
FILE: assets/camera_server/pyproject.toml
================================================
[project]
name = "camera-server"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = [
    "pyrealsense2>=2.50.0",
    "websockets>=12.0",
    "opencv-python>=4.8.0",
    "numpy>=1.24.0",
    "pillow>=12.1.1",
]

[project.scripts]
camera-server = "camera_server:main"



================================================
FILE: assets/camera_server/requirements.txt
================================================
pyrealsense2>=2.50.0
websockets>=12.0
opencv-python>=4.8.0
numpy>=1.24.0



================================================
FILE: assets/dobot-driver/Dockerfile
================================================
FROM ros:humble

RUN apt-get update && apt-get install -y \
    git python3-colcon-common-extensions \
    && rm -rf /var/lib/apt/lists/*

# Build DOBOT 6Axis ROS2 V4 from source (no apt package available)
RUN mkdir -p /dobot_ws/src && \
    cd /dobot_ws/src && \
    git clone --depth 1 https://github.com/Dobot-Arm/DOBOT_6Axis_ROS2_V4.git && \
    cd /dobot_ws && \
    . /opt/ros/humble/setup.sh && \
    colcon build --symlink-install

WORKDIR /dobot_ws

COPY scripts/ ./scripts/
RUN sed -i 's/\r$//' scripts/*.sh && chmod +x scripts/*.sh

CMD ["bash"]



================================================
FILE: assets/dobot-driver/scripts/start_driver.sh
================================================
#!/usr/bin/env bash
set -e
source /opt/ros/humble/setup.bash
source /dobot_ws/install/setup.bash

export DOBOT_TYPE=nova5
# The bringup node reads the robot IP from this env var
export IP_address="${DOBOT_IP:?Set DOBOT_IP in .env}"

ros2 launch cr_robot_ros2 dobot_bringup_ros2.launch.py



================================================
FILE: assets/urdriver/Dockerfile
================================================
FROM ros:humble

RUN apt-get update && apt-get install -y \
    curl \
    ros-humble-ur \
    ros-humble-realsense2-camera \
    ros-humble-realsense2-description \
    && rm -rf /var/lib/apt/lists/*

RUN curl -LsSf https://astral.sh/uv/install.sh | sh
ENV PATH="/root/.local/bin:$PATH"

WORKDIR /app

COPY pyproject.toml uv.lock ./
RUN uv sync --frozen

COPY scripts/ ./scripts/
RUN sed -i 's/\r$//' scripts/*.sh && chmod +x scripts/*.sh


CMD ["bash"]


================================================
FILE: assets/urdriver/pyproject.toml
================================================
[project]
name = "backend"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = [
    "fastapi",
    "uvicorn",
    "opencv-python",
    "numpy",
    "google-generativeai",
    "pydantic",
    "websockets",
    "ultralytics>=8.0.0",
    "openai>=1.0.0",
]


================================================
FILE: assets/urdriver/scripts/start_driver.sh
================================================
#!/usr/bin/env bash
set -e
source /opt/ros/humble/setup.bash

ros2 launch ur_robot_driver ur_control.launch.py \
  ur_type:="${UR_TYPE:-ur3}" \
  robot_ip:="${ROBOT_IP:?Set ROBOT_IP in .env}" \
  launch_rviz:=false \
  headless_mode:=true



================================================
FILE: backend/Dockerfile
================================================
FROM ros:humble

RUN apt-get update && apt-get install -y \
    curl \
    git \
    python3-colcon-common-extensions \
    ros-humble-ur \
    ros-humble-realsense2-camera \
    ros-humble-realsense2-description \
    && rm -rf /var/lib/apt/lists/*

# Build dobot_msgs_v4 (Python service/message bindings for DOBOT Nova 5).
# Only the message package is built here; the full DOBOT driver runs in the dobot-driver container.
RUN mkdir -p /dobot_msgs_ws/src && \
    cd /dobot_msgs_ws/src && \
    git clone --depth 1 --filter=blob:none --sparse \
        https://github.com/Dobot-Arm/DOBOT_6Axis_ROS2_V4.git && \
    cd DOBOT_6Axis_ROS2_V4 && \
    git sparse-checkout set dobot_msgs_v4 && \
    cd /dobot_msgs_ws && \
    . /opt/ros/humble/setup.sh && \
    colcon build --symlink-install --packages-select dobot_msgs_v4

RUN curl -LsSf https://astral.sh/uv/install.sh | sh
ENV PATH="/root/.local/bin:$PATH"

WORKDIR /app

COPY pyproject.toml uv.lock ./
RUN uv sync --frozen

COPY src/ ./src/
COPY scripts/ ./scripts/
RUN sed -i 's/\r$//' scripts/*.sh && chmod +x scripts/*.sh

# Create flows directory for flow persistence
RUN mkdir -p /app/flows

# Pre-create Ultralytics settings to avoid runtime delay
RUN mkdir -p /root/.config/Ultralytics /app/weights && \
    printf "settings_version: 0.0.6\ndatasets_dir: /root/datasets\nweights_dir: /app/weights\nruns_dir: /root/runs\nuuid: none\nsync: false\napi_key: ''\n" > /root/.config/Ultralytics/settings.yaml

# Expose FastAPI port
EXPOSE 8000

CMD ["bash", "scripts/start_backend.sh"]


================================================
FILE: backend/pyproject.toml
================================================
[project]
name = "backend"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = [
    "fastapi",
    "uvicorn",
    "opencv-python",
    "numpy",
    "google-generativeai",
    "pydantic",
    "websockets",
    "ultralytics>=8.0.0",
    "dill",
    "openai>=1.0.0",
    "pyserial>=3.5",
    "covvi-eci",
]



================================================
FILE: backend/scripts/start_backend.sh
================================================
#!/usr/bin/env bash
set -e
source /opt/ros/humble/setup.bash

# Source DOBOT message bindings if present (built during image build)
if [ -f /dobot_msgs_ws/install/setup.bash ]; then
    source /dobot_msgs_ws/install/setup.bash
fi

uv run python src/main.py



================================================
FILE: backend/src/main.py
================================================
import asyncio
import logging
import os
import threading

import rclpy
import uvicorn
from rclpy.executors import MultiThreadedExecutor

from api.app import create_app
from api.websocket import WebSocketManager
from executors import IOExecutor, RobotExecutor, CameraExecutor, HandExecutor, DobotNova5Executor
from flow.manager import FlowManager
from nodes.ur_node import RobotNode
from nodes.dobot_nova5_node import DobotNova5Node
from nodes.camera_node import CameraNode
from nodes.camera_bridge_node import CameraBridgeNode
from nodes.covvi_hand_node import CovviHandNode
# Import skills to register them
import skills.robot  # noqa: F401
import skills.io  # noqa: F401
import skills.camera  # noqa: F401
import skills.hand  # noqa: F401

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


def run_ros_executor(ros_executor: MultiThreadedExecutor) -> None:
    """Run the ROS 2 executor in a separate thread."""
    try:
        ros_executor.spin()
    except Exception as e:
        logger.error(f"ROS executor error: {e}")


def main():
    rclpy.init()

    # Select robot type from environment (ur | dobot)
    robot_type = os.environ.get("ROBOT_TYPE", "ur").lower()
    logger.info(f"Robot type: {robot_type}")

    # ROS 2 robot node + executor (type-switched)
    if robot_type == "dobot":
        robot = DobotNova5Node()
        robot_executor = DobotNova5Executor(robot)
        io_robot_executor = None  # DOBOT I/O can be wired later
        logger.info("Using DOBOT Nova 5 robot")
    else:
        robot = RobotNode()
        robot_executor = RobotExecutor(robot)
        io_robot_executor = IOExecutor(robot, executor_type="io_robot")
        logger.info("Using UR robot")

    # Fixed ROS 2 nodes
    camera = CameraNode()
    camera_bridge = CameraBridgeNode()
    hand = CovviHandNode()

    # WebSocket manager for real-time events
    ws_manager = WebSocketManager()

    # Camera and hand executors (always present)
    camera_executor = CameraExecutor(camera, ws_manager)
    hand_executor = HandExecutor(hand)

    executors = {
        "robot": robot_executor,
        "camera": camera_executor,
        "hand": hand_executor,
    }
    if io_robot_executor is not None:
        executors["io_robot"] = io_robot_executor

    # Flow manager for orchestration
    flows_dir = os.environ.get("FLOWS_DIR", "/app/flows")
    flow_manager = FlowManager(
        executors=executors,
        ws_manager=ws_manager,
        flows_dir=flows_dir,
    )

    # FastAPI application
    app = create_app(flow_manager, ws_manager, robot, camera_executor, io_robot_executor, hand_executor)

    # ROS 2 executor with nodes
    ros_executor = MultiThreadedExecutor()
    ros_executor.add_node(robot)
    ros_executor.add_node(camera)
    ros_executor.add_node(camera_bridge)
    ros_executor.add_node(hand)
    # Run ROS 2 executor in background thread
    ros_thread = threading.Thread(target=run_ros_executor, args=(ros_executor,), daemon=True)
    ros_thread.start()
    logger.info("ROS 2 executor started in background thread")

    # Initialize executors asynchronously
    async def init_executors():
        await robot_executor.initialize()
        if io_robot_executor is not None:
            await io_robot_executor.initialize()
        await camera_executor.initialize()
        await hand_executor.initialize()

    asyncio.get_event_loop().run_until_complete(init_executors())
    logger.info("Executors initialized")

    # Run FastAPI server (blocks main thread)
    try:
        logger.info("Starting FastAPI server on port 8000")
        uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")
    except KeyboardInterrupt:
        logger.info("Shutdown requested")
    finally:
        logger.info("Shutting down...")
        ros_executor.shutdown()
        robot.destroy_node()
        camera.destroy_node()
        camera_bridge.destroy_node()
        hand.destroy_node()
        rclpy.shutdown()


if __name__ == "__main__":
    main()



================================================
FILE: backend/src/api/__init__.py
================================================
"""API layer for flow execution system."""

from .app import create_app

__all__ = ["create_app"]



================================================
FILE: backend/src/api/app.py
================================================
"""FastAPI application factory."""

import logging
from contextlib import asynccontextmanager
from typing import TYPE_CHECKING

from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware

from .routes import flows_router, skills_router, camera_router
from .routes.flows import set_flow_manager
from .routes.camera import set_camera_executor
from .websocket import WebSocketManager

if TYPE_CHECKING:
    from executors.camera_executor import CameraExecutor
    from executors.hand_executor import HandExecutor
    from executors.io_executor import IOExecutor
    from flow.manager import FlowManager
    from nodes.ur_node import RobotNode

logger = logging.getLogger(__name__)


def create_app(
    flow_manager: "FlowManager",
    ws_manager: WebSocketManager,
    robot_node: "RobotNode",
    camera_executor: "CameraExecutor" = None,
    io_robot_executor: "IOExecutor" = None,
    hand_executor: "HandExecutor" = None,
) -> FastAPI:
    """
    Create and configure the FastAPI application.

    Args:
        flow_manager: FlowManager instance for flow operations.
        ws_manager: WebSocketManager instance for real-time events.
        robot_node: RobotNode for robot state queries.
        camera_executor: CameraExecutor for camera operations (optional).

    Returns:
        Configured FastAPI application.
    """

    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """Application lifespan context manager."""
        logger.info("FastAPI application starting")
        # Inject flow manager into routes
        set_flow_manager(flow_manager)
        # Inject camera executor if available
        if camera_executor:
            set_camera_executor(camera_executor)
        yield
        logger.info("FastAPI application shutting down")

    app = FastAPI(
        title="Flow Execution System",
        description="REST API and WebSocket for industrial robot automation flows",
        version="1.0.0",
        lifespan=lifespan,
    )

    # CORS middleware
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # Configure appropriately for production
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Include routers
    app.include_router(flows_router)
    app.include_router(skills_router)
    app.include_router(camera_router)

    # WebSocket endpoint
    @app.websocket("/ws")
    async def websocket_endpoint(websocket: WebSocket):
        """WebSocket endpoint for real-time flow telemetry."""
        await ws_manager.connect(websocket)

        # Reset conveyor IO on frontend connect to prevent stale trigger
        if io_robot_executor and io_robot_executor.is_ready():
            try:
                await io_robot_executor.set_digital_output(4, False)
                logger.info("Reset conveyor DO[4] to False on client connect")
            except Exception as e:
                logger.warning(f"Failed to reset DO[4] on connect: {e}")

        try:
            while True:
                # Wait for messages (ping/pong or custom commands)
                data = await websocket.receive_text()
                if data == "ping":
                    await websocket.send_text('{"type":"pong"}')
        except WebSocketDisconnect:
            pass
        except Exception as e:
            logger.warning(f"WebSocket error: {e}")
        finally:
            await ws_manager.disconnect(websocket)

    # Health check endpoint
    @app.get("/health")
    async def health_check():
        """Health check endpoint."""
        robot_connected = robot_node.get_joint_positions() is not None
        return {
            "status": "healthy",
            "robot_connected": robot_connected,
            "websocket_connections": ws_manager.connection_count(),
        }

    # Robot state endpoint
    @app.get("/api/robot/state")
    async def get_robot_state():
        """Get current robot state."""
        return robot_node.get_state_summary()

    # Hand state endpoint
    @app.get("/api/hand/state")
    async def get_hand_state():
        """Get current COVVI hand state."""
        if not hand_executor or not hand_executor.is_ready():
            return {"connected": False, "fingers": None}
        return {"connected": True, "fingers": hand_executor.get_hand_state()}

    return app



================================================
FILE: backend/src/api/routes/__init__.py
================================================
"""API routes for flow execution system."""

from .flows import router as flows_router
from .skills import router as skills_router
from .camera import router as camera_router

__all__ = ["flows_router", "skills_router", "camera_router"]



================================================
FILE: backend/src/api/routes/camera.py
================================================
"""REST endpoints for camera control."""

from typing import Optional

from fastapi import APIRouter, HTTPException, Response, status
from pydantic import BaseModel, Field

router = APIRouter(prefix="/api/camera", tags=["camera"])

# CameraExecutor will be injected via app state
_camera_executor = None


def set_camera_executor(executor) -> None:
    """Set the camera executor instance (called during app initialization)."""
    global _camera_executor
    _camera_executor = executor


def get_executor():
    """Get the camera executor, raising if not initialized."""
    if _camera_executor is None:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Camera executor not initialized",
        )
    return _camera_executor


# --- Request/Response Models ---


class StreamStartRequest(BaseModel):
    """Request to start streaming."""

    fps: int = Field(default=15, ge=1, le=30, description="Target FPS")


class StreamResponse(BaseModel):
    """Response for stream control operations."""

    success: bool
    streaming: bool
    message: Optional[str] = None


class CameraStateResponse(BaseModel):
    """Response for camera state."""

    connected: bool
    streaming: bool
    frame_size: Optional[dict] = None
    last_detection: Optional[dict] = None


# --- Endpoints ---


@router.post("/stream/start", response_model=StreamResponse)
async def start_stream(request: StreamStartRequest = StreamStartRequest()):
    """Start streaming camera frames over WebSocket."""
    executor = get_executor()

    if not executor.is_ready():
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Camera not connected",
        )

    started = await executor.start_streaming(fps=request.fps)

    return StreamResponse(
        success=True,
        streaming=True,
        message=f"Streaming started at {request.fps} FPS" if started else "Streaming already active",
    )


@router.post("/stream/stop", response_model=StreamResponse)
async def stop_stream():
    """Stop streaming camera frames."""
    executor = get_executor()

    stopped = await executor.stop_streaming()

    return StreamResponse(
        success=True,
        streaming=False,
        message="Streaming stopped" if stopped else "Streaming was not active",
    )


@router.get("/snapshot")
async def get_snapshot(quality: int = 90):
    """
    Get a single JPEG snapshot from the camera.

    Args:
        quality: JPEG quality (1-100).

    Returns:
        JPEG image data.
    """
    executor = get_executor()

    if not executor.is_ready():
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Camera not connected",
        )

    jpeg_data = executor.get_snapshot_jpeg(quality=min(100, max(1, quality)))

    if jpeg_data is None:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="No frame available",
        )

    return Response(
        content=jpeg_data,
        media_type="image/jpeg",
        headers={"Content-Disposition": "inline; filename=snapshot.jpg"},
    )


@router.get("/state", response_model=CameraStateResponse)
async def get_camera_state():
    """Get current camera state."""
    executor = get_executor()
    return executor.get_state_summary()



================================================
FILE: backend/src/api/routes/flows.py
================================================
"""REST endpoints for flow management."""

import logging
from typing import Any, Optional

logger = logging.getLogger(__name__)

from fastapi import APIRouter, HTTPException, status
from pydantic import BaseModel

from flow import FlowSchema, FlowStatusResponse

router = APIRouter(prefix="/api/flows", tags=["flows"])

# FlowManager will be injected via app state
_flow_manager = None


def set_flow_manager(manager) -> None:
    """Set the flow manager instance (called during app initialization)."""
    global _flow_manager
    _flow_manager = manager


def get_manager():
    """Get the flow manager, raising if not initialized."""
    if _flow_manager is None:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Flow manager not initialized",
        )
    return _flow_manager


# --- Request/Response Models ---


class FlowListResponse(BaseModel):
    """Response for listing flows."""

    flows: list[str]


class FlowCreateResponse(BaseModel):
    """Response for creating/updating a flow."""

    success: bool
    message: str
    flow_id: Optional[str] = None


class FlowStartResponse(BaseModel):
    """Response for starting a flow."""

    success: bool
    message: str


class FlowAbortResponse(BaseModel):
    """Response for aborting a flow."""

    success: bool
    message: str


class FlowGenerateRequest(BaseModel):
    """Request for generating a flow from prompt."""

    prompt: str


class FlowStep(BaseModel):
    """Step within a state (aligned with backend naming)."""

    id: str
    skill: str
    executor: str
    params: Optional[dict[str, Any]] = None


class FlowNode(BaseModel):
    """Node in the frontend flow format (aligned with backend naming)."""

    id: str
    type: str  # "state", "start", "end"
    label: str
    steps: Optional[list[FlowStep]] = None  # For state nodes
    position: dict[str, float]
    style: Optional[dict[str, Any]] = None  # For sizing


class FlowEdge(BaseModel):
    """Edge in the frontend flow format."""

    id: str
    source: str
    target: str
    type: str = "transitionEdge"
    data: Optional[dict[str, Any]] = None


class FlowGenerateResponse(BaseModel):
    """Response with frontend-compatible flow format."""

    id: str
    name: str
    loop: bool = False
    nodes: list[FlowNode]
    edges: list[FlowEdge]


def convert_backend_to_frontend(flow: FlowSchema) -> FlowGenerateResponse:
    """
    Convert backend flow format to frontend node/edge format.

    Backend: states with steps, transitions between states
    Frontend: start node, state nodes (containing steps), end node, edges

    Uses actual transitions from the flow definition.
    """
    nodes: list[FlowNode] = []
    edges: list[FlowEdge] = []

    # Positions are set to (0,0) — the frontend's layoutFlow() computes real positions.

    # Add start node
    start_node_id = "start"
    nodes.append(FlowNode(
        id=start_node_id,
        type="start",
        label="Start",
        position={"x": 0, "y": 0},
    ))

    # Convert each state to a node with steps inside
    for state in flow.states:
        node_id = state.name

        steps = [
            FlowStep(
                id=step.id,
                skill=step.skill,
                executor=step.executor,
                params=step.params,
            )
            for step in state.steps
        ]

        nodes.append(FlowNode(
            id=node_id,
            type="state",
            label=state.name,
            steps=steps,
            position={"x": 0, "y": 0},
        ))

    # Add end node
    end_node_id = "end"
    nodes.append(FlowNode(
        id=end_node_id,
        type="end",
        label="End",
        position={"x": 0, "y": 0},
    ))

    # Edge from start to initial state
    edges.append(FlowEdge(
        id=f"e_{start_node_id}_{flow.initial_state}",
        source=start_node_id,
        target=flow.initial_state,
    ))

    # Convert actual transitions to edges
    for i, t in enumerate(flow.transitions):
        edge_data: dict[str, Any] = {"transitionType": t.type}
        if t.condition:
            edge_data["condition"] = t.condition

        edges.append(FlowEdge(
            id=f"e_{t.from_state}_{t.to_state}_{i}",
            source=t.from_state,
            target=t.to_state,
            data=edge_data,
        ))

    # Find terminal states (no outgoing transitions)
    states_with_outgoing = {t.from_state for t in flow.transitions}
    terminal_states = [s.name for s in flow.states if s.name not in states_with_outgoing]

    # Add loop-back and/or end edges for terminal states
    for state_name in terminal_states:
        if flow.loop:
            edges.append(FlowEdge(
                id=f"e_loop_{state_name}_{flow.initial_state}",
                source=state_name,
                target=flow.initial_state,
                data={"isLoop": True},
            ))
        edges.append(FlowEdge(
            id=f"e_{state_name}_{end_node_id}",
            source=state_name,
            target=end_node_id,
        ))

    return FlowGenerateResponse(
        id=flow.id,
        name=flow.name,
        loop=flow.loop,
        nodes=nodes,
        edges=edges,
    )


# --- Endpoints ---


@router.get("", response_model=FlowListResponse)
async def list_flows():
    """List all available flows."""
    manager = get_manager()
    return FlowListResponse(flows=manager.list_flows())


@router.get("/status", response_model=FlowStatusResponse)
async def get_status():
    """Get current execution status."""
    manager = get_manager()
    return manager.get_status()


@router.get("/{flow_id}", response_model=FlowSchema)
async def get_flow(flow_id: str):
    """Get a flow definition by ID."""
    manager = get_manager()
    flow = manager.get_flow(flow_id)
    if flow is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Flow '{flow_id}' not found",
        )
    return flow


@router.post("", response_model=FlowCreateResponse)
async def create_flow(flow: FlowSchema):
    """Create or update a flow."""
    manager = get_manager()
    success, error = manager.save_flow(flow)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error or "Failed to save flow",
        )
    return FlowCreateResponse(
        success=True,
        message=f"Flow '{flow.id}' saved",
        flow_id=flow.id,
    )


@router.delete("/{flow_id}")
async def delete_flow(flow_id: str):
    """Delete a flow."""
    manager = get_manager()
    if not manager.delete_flow(flow_id):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Flow '{flow_id}' not found",
        )
    return {"success": True, "message": f"Flow '{flow_id}' deleted"}


@router.post("/{flow_id}/start", response_model=FlowStartResponse)
async def start_flow(flow_id: str):
    """Start executing a flow."""
    manager = get_manager()
    success, message = await manager.start_flow(flow_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT
            if "already running" in message.lower()
            else status.HTTP_400_BAD_REQUEST,
            detail=message,
        )
    return FlowStartResponse(success=True, message=message)


@router.post("/abort", response_model=FlowAbortResponse)
async def abort_flow():
    """Abort the currently running flow."""
    manager = get_manager()
    success, message = await manager.abort_flow()
    if not success:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=message,
        )
    return FlowAbortResponse(success=True, message=message)


class FlowFinishResponse(BaseModel):
    """Response for finishing a flow."""

    success: bool
    message: str


class FlowPauseResponse(BaseModel):
    """Response for pausing a flow."""

    success: bool
    message: str


class FlowResumeResponse(BaseModel):
    """Response for resuming a flow."""

    success: bool
    message: str


@router.post("/finish", response_model=FlowFinishResponse)
async def finish_flow():
    """Request graceful finish — complete current loop cycle then stop."""
    manager = get_manager()
    success, message = await manager.finish_flow()
    if not success:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=message,
        )
    return FlowFinishResponse(success=True, message=message)


@router.post("/pause", response_model=FlowPauseResponse)
async def pause_flow():
    """Pause the currently running flow."""
    manager = get_manager()
    success, message = await manager.pause_flow()
    if not success:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=message,
        )
    return FlowPauseResponse(success=True, message=message)


@router.post("/resume", response_model=FlowResumeResponse)
async def resume_flow():
    """Resume a paused flow."""
    manager = get_manager()
    success, message = await manager.resume_flow()
    if not success:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=message,
        )
    return FlowResumeResponse(success=True, message=message)


# Default flow loaded when no AI generation is implemented.
# Hackathon challenge: replace this endpoint with real LLM-based flow generation.
_DEFAULT_FLOW_ID = "dobot_test_pick"


@router.post("/generate", response_model=FlowGenerateResponse)
async def generate_flow(request: FlowGenerateRequest):
    """
    Load and return the default flow definition.

    TODO (hackathon): Implement AI-based flow generation from the natural
    language prompt in `request.prompt`. The response must conform to
    FlowGenerateResponse (nodes + edges in frontend format).
    """
    logger.debug("generate_flow called with prompt: %r", request.prompt)
    manager = get_manager()

    flow = manager.get_flow(_DEFAULT_FLOW_ID)
    if flow is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Default flow '{_DEFAULT_FLOW_ID}' not found",
        )

    return convert_backend_to_frontend(flow)



================================================
FILE: backend/src/api/routes/skills.py
================================================
"""REST endpoints for skill discovery."""

from typing import Any

from fastapi import APIRouter
from pydantic import BaseModel

from skills import list_skills

router = APIRouter(prefix="/api/skills", tags=["skills"])


class SkillInfo(BaseModel):
    """Skill metadata for API response."""

    name: str
    executor_type: str
    description: str
    params_schema: dict[str, Any]


class SkillListResponse(BaseModel):
    """Response for listing skills."""

    skills: list[SkillInfo]


@router.get("", response_model=SkillListResponse)
async def get_skills():
    """List all available skills with their metadata."""
    skills_metadata = list_skills()
    return SkillListResponse(
        skills=[SkillInfo(**skill) for skill in skills_metadata]
    )


@router.get("/{skill_name}", response_model=SkillInfo)
async def get_skill(skill_name: str):
    """Get metadata for a specific skill."""
    from fastapi import HTTPException, status
    from skills import get_skill as get_skill_instance

    try:
        skill = get_skill_instance(skill_name)
        metadata = skill.get_metadata()
        return SkillInfo(**metadata)
    except KeyError:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Skill '{skill_name}' not found",
        )



================================================
FILE: backend/src/api/websocket/__init__.py
================================================
"""WebSocket components for real-time telemetry."""

from .events import EventType, create_event
from .manager import WebSocketManager

__all__ = ["EventType", "WebSocketManager", "create_event"]



================================================
FILE: backend/src/api/websocket/events.py
================================================
"""WebSocket event type definitions."""

import time
from enum import Enum
from typing import Any


class EventType(str, Enum):
    """WebSocket event types."""

    # Flow lifecycle events
    FLOW_STARTED = "flow_started"
    FLOW_COMPLETED = "flow_completed"
    FLOW_PAUSED = "flow_paused"
    FLOW_RESUMED = "flow_resumed"
    FLOW_ABORTED = "flow_aborted"
    FLOW_ERROR = "flow_error"

    # State events
    STATE_ENTERED = "state_entered"
    STATE_COMPLETED = "state_completed"
    WAITING_CONDITION = "waiting_condition"

    # Step events
    STEP_STARTED = "step_started"
    STEP_COMPLETED = "step_completed"
    STEP_ERROR = "step_error"
    STEP_RETRY = "step_retry"
    STEP_SKIPPED = "step_skipped"

    # Telemetry events
    ROBOT_STATE = "robot_state"

    # Camera events
    CAMERA_FRAME = "camera_frame"

    # Connection events
    CONNECTED = "connected"
    PING = "ping"
    PONG = "pong"


def create_event(event_type: str | EventType, data: dict[str, Any]) -> dict[str, Any]:
    """
    Create a WebSocket event payload.

    Args:
        event_type: Type of event.
        data: Event-specific data.

    Returns:
        Complete event dict ready for JSON serialization.
    """
    if isinstance(event_type, EventType):
        event_type = event_type.value

    return {
        "type": event_type,
        "timestamp": time.time(),
        **data,
    }



================================================
FILE: backend/src/api/websocket/manager.py
================================================
"""WebSocket connection manager for broadcasting events."""

import asyncio
import json
import logging
from typing import Any

from fastapi import WebSocket

from .events import EventType, create_event

logger = logging.getLogger(__name__)


class WebSocketManager:
    """
    Manages WebSocket connections and broadcasts events.

    Thread-safe for use with asyncio.
    """

    def __init__(self):
        self._connections: set[WebSocket] = set()
        self._lock = asyncio.Lock()

    async def connect(self, websocket: WebSocket) -> None:
        """Accept and register a new WebSocket connection."""
        await websocket.accept()
        async with self._lock:
            self._connections.add(websocket)
        logger.info(f"WebSocket connected. Total: {len(self._connections)}")

        # Send welcome event
        await self._send_to_one(
            websocket, create_event(EventType.CONNECTED, {"message": "Connected to flow execution system"})
        )

    async def disconnect(self, websocket: WebSocket) -> None:
        """Remove a WebSocket connection."""
        async with self._lock:
            self._connections.discard(websocket)
        logger.info(f"WebSocket disconnected. Total: {len(self._connections)}")

    async def broadcast(self, event_type: str, data: dict[str, Any]) -> None:
        """
        Broadcast an event to all connected clients.

        Args:
            event_type: Event type string.
            data: Event data (will be merged with type and timestamp).
        """
        event = create_event(event_type, data)
        await self._broadcast_raw(event)

    async def broadcast_event(self, event: dict[str, Any]) -> None:
        """Broadcast a pre-formed event dict."""
        await self._broadcast_raw(event)

    async def _broadcast_raw(self, event: dict[str, Any]) -> None:
        """Broadcast raw event dict to all connections."""
        if not self._connections:
            return

        message = json.dumps(event)
        disconnected: list[WebSocket] = []

        async with self._lock:
            connections = list(self._connections)

        for ws in connections:
            try:
                await ws.send_text(message)
            except Exception as e:
                logger.warning(f"Failed to send to WebSocket: {e}")
                disconnected.append(ws)

        # Remove failed connections
        if disconnected:
            async with self._lock:
                for ws in disconnected:
                    self._connections.discard(ws)

    async def _send_to_one(self, websocket: WebSocket, event: dict[str, Any]) -> None:
        """Send an event to a single connection."""
        try:
            await websocket.send_text(json.dumps(event))
        except Exception as e:
            logger.warning(f"Failed to send to WebSocket: {e}")

    def connection_count(self) -> int:
        """Return current number of connections."""
        return len(self._connections)

    def create_event_callback(self):
        """
        Create a callback function for FlowExecutor events.

        Returns a sync function that schedules async broadcast.
        """

        def callback(event_type: str, data: dict) -> None:
            # Schedule the broadcast in the event loop
            try:
                loop = asyncio.get_running_loop()
                loop.create_task(self.broadcast(event_type, data))
            except RuntimeError:
                # No running loop - log and skip
                logger.debug(f"No event loop for broadcast: {event_type}")

        return callback



================================================
FILE: backend/src/data/flow/dobot_test_pick.json
================================================
{
  "id": "dobot_test_pick",
  "name": "DOBOT Test Pick (Nova 5)",
  "initial_state": "midair",
  "loop": false,
  "variables": {
    "midair_joints": [152.345, -17.610, 87.397, 50.315, 2.243, 10.032],
    "pick_joints":   [152.345, -32.610, 72.397, 50.315, 2.243, 10.032]
  },
  "states": [
    {
      "name": "midair",
      "steps": [
        {
          "id": "go_midair",
          "skill": "move_joint",
          "executor": "robot",
          "params": { "target_joints_deg": "{{midair_joints}}" },
          "timeout_ms": 30000
        }
      ]
    },
    {
      "name": "pick",
      "steps": [
        {
          "id": "move_to_pick",
          "skill": "move_joint",
          "executor": "robot",
          "params": { "target_joints_deg": "{{pick_joints}}" },
          "timeout_ms": 30000
        },
        {
          "id": "open_gripper",
          "skill": "set_tool_output",
          "executor": "robot",
          "params": { "index": 2, "status": 1 },
          "timeout_ms": 3000
        },
        {
          "id": "close_gripper",
          "skill": "set_tool_output",
          "executor": "robot",
          "params": { "index": 1, "status": 1 },
          "timeout_ms": 3000
        }
      ]
    },
    {
      "name": "return_midair",
      "steps": [
        {
          "id": "go_midair_return",
          "skill": "move_joint",
          "executor": "robot",
          "params": { "target_joints_deg": "{{midair_joints}}" },
          "timeout_ms": 30000
        }
      ]
    }
  ],
  "transitions": [
    {
      "type": "sequential",
      "from_state": "midair",
      "to_state": "pick"
    },
    {
      "type": "sequential",
      "from_state": "pick",
      "to_state": "return_midair"
    }
  ]
}



================================================
FILE: backend/src/data/flow/hand_pick_and_place.json
================================================
{
  "id": "hand_pick_and_place",
  "name": "Hand Pick and Place (COVVI)",
  "initial_state": "home",
  "loop": true,
  "variables": {
    "midair_joints": [-11.3, -77.6, -105.3, 343.2, 81.8, -352.3],
    "pick_joints":   [-2.6, -109.6, -115.7, 340.7, 81.4, -349.2]
  },
  "states": [
    {
      "name": "home",
      "steps": [
        {
          "id": "open_hand_home",
          "skill": "set_grip",
          "executor": "hand",
          "params": { "grip": "RELAXED" },
          "timeout_ms": 5000
        },
        {
          "id": "go_home",
          "skill": "move_joint",
          "executor": "robot",
          "params": { "target_joints_deg": "{{midair_joints}}" },
          "timeout_ms": 30000
        }
      ]
    },
    {
      "name": "pick",
      "steps": [
        {
          "id": "move_to_pick",
          "skill": "move_joint",
          "executor": "robot",
          "params": { "target_joints_deg": "{{pick_joints}}" },
          "timeout_ms": 30000
        },
        {
          "id": "grip_object",
          "skill": "grip_until_contact",
          "executor": "hand",
          "params": {
            "speed": 25,
            "fingers": ["thumb", "index", "middle", "little"],
            "min_contacts": 2,
            "timeout_s": 5.0
          },
          "store_result": "grip_result",
          "timeout_ms": 10000
        }
      ]
    },
    {
      "name": "retract",
      "steps": [
        {
          "id": "go_midair_retract",
          "skill": "move_joint",
          "executor": "robot",
          "params": { "target_joints_deg": "{{midair_joints}}" },
          "timeout_ms": 30000
        }
      ]
    }
  ],
  "transitions": [
    {
      "type": "sequential",
      "from_state": "home",
      "to_state": "pick"
    },
    {
      "type": "sequential",
      "from_state": "pick",
      "to_state": "retract"
    }
  ]
}



================================================
FILE: backend/src/data/flow/pick_and_place_v2.json
================================================
{
  "id": "pick_and_place_v2",
  "name": "Pick and Place with Approach/Retract",
  "initial_state": "start_midair",
  "loop": true,
  "variables": {
    "midair_joints": [-122.69, -109.26, -44.24, -112.69, 89.94, -14.72],
    "pick_pose": [-0.413, -0.080, 0.094, 0.0, 3.14, 0.0],
    "approach_z_offset": 0.15,
    "waypoint_c_joints": [-26.66, -76.09, -89.12, -99.54, 88.68, 154.01],
    "place_positions": {
      "Zone_A": [[-0.041, -0.318, 0.174, 0.0, 3.14, 0.0], [0.065, -0.318, 0.174, 0.0, 3.14, 0.0], [-0.015, -0.426, 0.174, 2.20, 2.26, 0.0]],
      "Zone_B": [[0.248, -0.288, 0.174, 2.20, 2.26, 0.0], [0.248, -0.353, 0.174, 2.20, 2.26, 0.0], [0.352, -0.310, 0.174, 0.0, 3.14, 0.0]],
      "Zone_C": [[0.386, -0.082, 0.174, 0.0, 3.14, 0.0], [0.270, -0.093, 0.174, 2.20, 2.26, 0.0], [0.270, -0.008, 0.174, 2.20, 2.26, 0.0]],
      "default":   [[-0.00324, -0.3789, 0.217, 3.14, 0.0, 0.0]]
    }
  },
  "states": [
    {
      "name": "start_midair",
      "steps": [
        {
          "id": "go_midair_1",
          "skill": "move_joint",
          "executor": "robot",
          "params": {
            "target_joints_deg": "{{midair_joints}}"
          },
          "error_handling": {
            "strategy": "retry",
            "max_retries": 2
          },
          "timeout_ms": 30000
        }
      ]
    },
    
    {
      "name": "pick",
      "steps": [
        {
          "id": "read_label",
          "skill": "get_label",
          "executor": "camera",
          "params": {
            "prompt": "Read the product label in the image. Map it to one of these zones: Zone_A = MXP-30, Zone_B = MXP Speed, Zone_C = MXP Torque. Return ONLY the zone name (Zone_A, Zone_B, or Zone_C), nothing else. If you are unsure, return the most likely zone.",
            "use_bbox": false
          },
          "store_result": "label_data",
          "timeout_ms": 60000
        },
        {
          "id": "pick_approach",
          "skill": "move_linear",
          "executor": "robot",
          "params": {
            "target_pose": "{{pick_pose}}",
            "z_offset": "{{approach_z_offset}}"
          },
          "timeout_ms": 30000
        },
        {
          "id": "pick_descend",
          "skill": "move_linear",
          "executor": "robot",
          "params": {
            "target_pose": "{{pick_pose}}"
          },
          "timeout_ms": 30000
        },
        {
          "id": "vacuum_on",
          "skill": "io_set_digital_output",
          "executor": "io_robot",
          "params": {
            "pin": 0,
            "value": true
          },
          "timeout_ms": 5000
        }
      ]
    },
    {
      "name": "transition",
      "steps": [
        {
          "id": "pick_retract_up",
          "skill": "move_linear",
          "executor": "robot",
          "params": {
            "target_pose": "{{pick_pose}}",
            "z_offset": "{{approach_z_offset}}"
          },
          "timeout_ms": 30000
        },
        {
          "id": "go_midair_2",
          "skill": "move_joint",
          "executor": "robot",
          "params": {
            "target_joints_deg": "{{midair_joints}}"
          },
          "timeout_ms": 30000
        }
      ]
    },
    {
      "name": "waypoint_c",
      "steps": [
        {
          "id": "go_waypoint_c",
          "skill": "move_joint",
          "executor": "robot",
          "params": {
            "target_joints_deg": "{{waypoint_c_joints}}"
          },
          "timeout_ms": 30000
        }
      ]
    },
    {
      "name": "place",
      "steps": [
        {
          "id": "place_approach",
          "skill": "palletize",
          "executor": "robot",
          "params": {
            "positions_var": "place_positions",
            "key": "{{label_data.label}}",
            "default_key": "default",
            "z_offset": "{{approach_z_offset}}"
          },
          "store_result": "place_target",
          "timeout_ms": 30000
        },
        {
          "id": "place_descend",
          "skill": "move_linear",
          "executor": "robot",
          "params": {
            "target_pose": "{{place_target.target_pose}}"
          },
          "timeout_ms": 30000
        },
        {
          "id": "vacuum_off",
          "skill": "io_set_digital_output",
          "executor": "io_robot",
          "params": {
            "pin": 0,
            "value": false
          },
          "timeout_ms": 5000
        }
      ]
    },
    {
      "name": "end_midair",
      "steps": [
        {
          "id": "place_retract_up",
          "skill": "move_linear",
          "executor": "robot",
          "params": {
            "target_pose": "{{place_target.target_pose}}",
            "z_offset": "{{approach_z_offset}}"
          },
          "timeout_ms": 30000
        },
        {
          "id": "go_midair_3",
          "skill": "move_joint",
          "executor": "robot",
          "params": {
            "target_joints_deg": "{{midair_joints}}"
          },
          "timeout_ms": 30000
        },
        {
          "id": "restart_conveyor",
          "skill": "io_set_digital_output",
          "executor": "io_robot",
          "params": {
            "pin": 4,
            "value": true
          },
          "timeout_ms": 5000
        },
        {
          "id": "reset_io_conveyour",
          "skill": "io_set_digital_output",
          "executor": "io_robot",
          "params": {
            "pin": 4,
            "value": false
          },
          "timeout_ms": 5000
        }
      ]
    }
  ],
  "transitions": [
    {
      "type": "conditional",
      "from_state": "start_midair",
      "to_state": "pick",
      "condition": "io_robot.input[4] == true"
    },
    {
      "type": "sequential",
      "from_state": "pick",
      "to_state": "transition"
    },
    {
      "type": "conditional",
      "from_state": "transition",
      "to_state": "waypoint_c",
      "condition": "{{label_data.label}} == 'Zone_C'"
    },
    {
      "type": "conditional",
      "from_state": "transition",
      "to_state": "place",
      "condition": "{{label_data.label}} != 'Zone_C'"
    },
    {
      "type": "sequential",
      "from_state": "waypoint_c",
      "to_state": "place"
    },
    {
      "type": "sequential",
      "from_state": "place",
      "to_state": "end_midair"
    }
  ]
}



================================================
FILE: backend/src/executors/__init__.py
================================================
"""Executors for bridging skills to ROS 2 nodes."""

from .base import Executor
from .robot_executor import RobotExecutor
from .io_executor import IOExecutor
from .camera_executor import CameraExecutor
from .hand_executor import HandExecutor
from .dobot_nova5_executor import DobotNova5Executor

__all__ = ["Executor", "RobotExecutor", "IOExecutor", "CameraExecutor", "HandExecutor", "DobotNova5Executor"]



================================================
FILE: backend/src/executors/base.py
================================================
"""Base class for executors."""

from abc import ABC, abstractmethod
from typing import Any


class Executor(ABC):
    """
    Abstract base class for executors.

    Executors bridge between skills and underlying hardware/ROS 2 nodes.
    Each executor type handles a specific category of operations.
    """

    executor_type: str = ""

    @abstractmethod
    async def initialize(self) -> None:
        """Initialize the executor (connect to nodes, verify state)."""
        ...

    @abstractmethod
    async def shutdown(self) -> None:
        """Cleanup executor resources."""
        ...

    @abstractmethod
    def is_ready(self) -> bool:
        """Check if executor is ready for operations."""
        ...

    def get_type(self) -> str:
        """Return the executor type identifier."""
        return self.executor_type



================================================
FILE: backend/src/executors/camera_executor.py
================================================
"""Camera executor for YOLO detection, OpenAI Vision, and frame streaming."""

import asyncio
import base64
import logging
import os
from dataclasses import dataclass
from typing import TYPE_CHECKING, Optional

import cv2
import numpy as np
from openai import AsyncAzureOpenAI

from .base import Executor

if TYPE_CHECKING:
    from api.websocket import WebSocketManager
    from nodes.camera_node import CameraNode

logger = logging.getLogger(__name__)


@dataclass
class BoundingBox:
    """Detected object bounding box."""

    x: float
    y: float
    width: float
    height: float
    confidence: float
    class_name: str

    def to_dict(self) -> dict:
        return {
            "x": self.x,
            "y": self.y,
            "width": self.width,
            "height": self.height,
            "confidence": self.confidence,
            "class_name": self.class_name,
        }


class CameraExecutor(Executor):
    """
    Executor for camera operations including YOLO detection and OpenAI Vision.

    Provides streaming, object detection, and OCR capabilities.
    """

    executor_type = "camera"

    def __init__(self, camera_node: "CameraNode", ws_manager: "WebSocketManager"):
        self._camera = camera_node
        self._ws = ws_manager

        # Streaming state
        self._streaming = False
        self._stream_task: Optional[asyncio.Task] = None
        self._send_task: Optional[asyncio.Task] = None
        self._frame_queue: Optional[asyncio.Queue] = None

        # YOLO model (lazy loaded)
        self._yolo_model = None
        self._yolo_model_name = os.environ.get("YOLO_MODEL", "/app/weights/roboflow_logistics.pt")

        # Azure OpenAI client (lazy loaded)
        self._openai_client: Optional[AsyncAzureOpenAI] = None
        self._azure_deployment = os.environ.get("AZURE_OPENAI_DEPLOYMENT", "gpt-4o")

        # Last detection result for cropping
        self._last_bbox: Optional[BoundingBox] = None

    async def initialize(self) -> None:
        """Wait for camera connection and pre-load YOLO model."""
        logger.info("CameraExecutor initializing...")

        # # Pre-load YOLO model in background to avoid delay on first detection
        # loop = asyncio.get_event_loop()
        # await loop.run_in_executor(None, self._get_yolo_model)

        # Pre-initialize Azure OpenAI client AND warm up the HTTP connection
        # so the first real read_label() call doesn't pay the TLS/auth cold-start
        await self._warmup_openai()

        timeout = 10.0
        elapsed = 0.0
        while not self._camera.has_frame() and elapsed < timeout:
            await asyncio.sleep(0.1)
            elapsed += 0.1

        if not self._camera.has_frame():
            logger.warning("Camera frame not available after timeout - camera may not be connected")
        else:
            dims = self._camera.get_frame_dimensions()
            logger.info(f"CameraExecutor ready - frame size: {dims}")

    async def shutdown(self) -> None:
        """Stop streaming and cleanup."""
        await self.stop_streaming()

    def is_ready(self) -> bool:
        """Check if camera has received frames."""
        return self._camera.has_frame()

    def _get_yolo_model(self):
        """Lazy-load YOLO model on first use."""
        if self._yolo_model is None:
            from ultralytics import YOLO

            logger.info(f"Loading YOLO model: {self._yolo_model_name}")
            self._yolo_model = YOLO(self._yolo_model_name)
            logger.info("YOLO model loaded")
        return self._yolo_model

    def _get_openai_client(self) -> AsyncAzureOpenAI:
        """Get or create Azure OpenAI client."""
        if self._openai_client is None:
            self._openai_client = AsyncAzureOpenAI(
                api_key=os.environ.get("AZURE_OPENAI_API_KEY"),
                api_version=os.environ.get("AZURE_OPENAI_API_VERSION", "2024-02-15-preview"),
                azure_endpoint=os.environ.get("AZURE_OPENAI_ENDPOINT"),
            )
        return self._openai_client

    async def _warmup_openai(self) -> None:
        """Send a minimal request to establish the HTTP/TLS connection pool.

        This eliminates the cold-start latency on the first real read_label() call.
        """
        try:
            client = self._get_openai_client()
            await asyncio.wait_for(
                client.chat.completions.create(
                    model=self._azure_deployment,
                    messages=[{"role": "user", "content": "hi"}],
                    max_completion_tokens=1,
                ),
                timeout=15.0,
            )
            logger.info("Azure OpenAI connection warmed up successfully")
        except Exception as e:
            logger.warning(f"Azure OpenAI warmup failed (non-fatal): {e}")

    # --- Streaming ---

    async def start_streaming(self, fps: int = 15, max_queue: int = 1) -> bool:
        """
        Start streaming camera frames over WebSocket.

        Args:
            fps: Target frames per second.
            max_queue: Maximum frames to queue before dropping old ones.

        Returns:
            True if streaming started, False if already streaming.
        """
        if self._streaming:
            logger.warning("Streaming already active")
            return False

        self._streaming = True
        self._frame_queue = asyncio.Queue(maxsize=max_queue)
        self._stream_task = asyncio.create_task(self._capture_loop(fps))
        self._send_task = asyncio.create_task(self._send_loop())
        logger.info(f"Camera streaming started at {fps} FPS (queue size: {max_queue})")
        return True

    async def stop_streaming(self) -> bool:
        """
        Stop streaming camera frames.

        Returns:
            True if streaming stopped, False if not streaming.
        """
        if not self._streaming:
            return False

        self._streaming = False

        for task in [self._stream_task, self._send_task]:
            if task:
                task.cancel()
                try:
                    await task
                except asyncio.CancelledError:
                    pass

        self._stream_task = None
        self._send_task = None
        self._frame_queue = None

        logger.info("Camera streaming stopped")
        return True

    def is_streaming(self) -> bool:
        """Check if currently streaming."""
        return self._streaming

    async def _capture_loop(self, fps: int) -> None:
        """Capture frames and put them in the queue, dropping old ones if full."""
        interval = 1.0 / fps

        while self._streaming:
            try:
                frame_jpeg = self._camera.get_frame_jpeg(quality=70)
                if frame_jpeg and self._frame_queue:
                    dims = self._camera.get_frame_dimensions()
                    width, height = dims if dims else (640, 480)

                    frame_data = {
                        "frame": base64.b64encode(frame_jpeg).decode(),
                        "width": width,
                        "height": height,
                    }

                    # Drop oldest frame if queue is full
                    if self._frame_queue.full():
                        try:
                            self._frame_queue.get_nowait()
                        except asyncio.QueueEmpty:
                            pass

                    try:
                        self._frame_queue.put_nowait(frame_data)
                    except asyncio.QueueFull:
                        pass  # Skip this frame

                await asyncio.sleep(interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Capture error: {e}")
                await asyncio.sleep(interval)

    async def _send_loop(self) -> None:
        """Send frames from the queue to WebSocket clients."""
        while self._streaming:
            try:
                if self._frame_queue:
                    frame_data = await asyncio.wait_for(
                        self._frame_queue.get(), timeout=0.033
                    )
                    await self._ws.broadcast("camera_frame", frame_data)
            except asyncio.TimeoutError:
                continue
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Send error: {e}")

    # --- Object Detection ---

    async def detect_objects(
        self,
        class_name: Optional[str] = None,
        confidence_threshold: float = 0.5,
    ) -> list[BoundingBox]:
        """
        Run YOLO object detection on current frame.

        Args:
            class_name: Filter by class name (e.g., "bottle", "person").
            confidence_threshold: Minimum confidence threshold.

        Returns:
            List of detected bounding boxes.
        """
        frame = self._camera.get_latest_frame()
        if frame is None:
            logger.warning("No frame available for detection")
            return []

        logger.info(f"detect_objects: frame shape={frame.shape}, looking for class='{class_name}' conf>={confidence_threshold}")

        # Run detection on full frame
        loop = asyncio.get_event_loop()
        results = await loop.run_in_executor(
            None,
            lambda: self._get_yolo_model()(frame, verbose=False),
        )

        detections: list[BoundingBox] = []
        model = self._get_yolo_model()

        for result in results:
            logger.info(f"detect_objects: YOLO returned {len(result.boxes)} raw boxes")
            for box in result.boxes:
                cls_id = int(box.cls)
                cls_name = model.names[cls_id]
                conf = float(box.conf)
                x1, y1, x2, y2 = box.xyxy[0].tolist()
                logger.info(f"detect_objects: raw box class='{cls_name}' conf={conf:.3f} xyxy=[{x1:.1f},{y1:.1f},{x2:.1f},{y2:.1f}]")

                # Filter by confidence
                if conf < confidence_threshold:
                    logger.info(f"detect_objects: SKIPPED (conf {conf:.3f} < {confidence_threshold})")
                    continue

                # Filter by class name if specified
                if class_name and cls_name.lower() != class_name.lower():
                    logger.info(f"detect_objects: SKIPPED (class '{cls_name}' != '{class_name}')")
                    continue

                bbox = BoundingBox(
                    x=x1,
                    y=y1,
                    width=x2 - x1,
                    height=y2 - y1,
                    confidence=conf,
                    class_name=cls_name,
                )
                logger.info(f"detect_objects: ACCEPTED bbox x={bbox.x:.1f} y={bbox.y:.1f} w={bbox.width:.1f} h={bbox.height:.1f}")
                detections.append(bbox)

        # Store last detection for potential cropping
        if detections:
            self._last_bbox = detections[0]
            logger.info(f"detect_objects: broadcasting bbox to frontend: {detections[0].to_dict()}")
            try:
                await self._broadcast_bbox(detections[0])
                logger.info("detect_objects: bbox broadcast sent successfully")
            except Exception as e:
                logger.error(f"detect_objects: bbox broadcast FAILED: {e}")
        else:
            logger.warning("detect_objects: no detections passed filters, no bbox broadcast")

        logger.info(f"detect_objects: returning {len(detections)} detections")
        return detections

    async def _broadcast_bbox(self, bbox: BoundingBox) -> None:
        """Broadcast bounding box to frontend for overlay display."""
        dims = self._camera.get_frame_dimensions()
        width, height = dims if dims else (640, 480)
        payload = {
            "bbox": bbox.to_dict(),
            "frame_width": width,
            "frame_height": height,
            "display_duration_ms": 5000,
        }
        logger.info(f"_broadcast_bbox: sending payload frame={width}x{height} bbox={bbox.to_dict()}")
        await self._ws.broadcast("bounding_box", payload)

    def get_last_bbox(self) -> Optional[BoundingBox]:
        """Get the last detected bounding box."""
        return self._last_bbox

    # --- OpenAI Vision / OCR ---

    async def read_label(
        self,
        prompt: str,
        use_bbox: bool = True,
        crop_margin: float = 0.1,
    ) -> dict:
        """
        Use GPT-4V to read text/labels from the image.

        Args:
            prompt: Instruction for what to read (e.g., "Read the product label").
            use_bbox: If True and last detection exists, crop to that region.
            crop_margin: Margin around bbox as fraction of bbox size.

        Returns:
            Dict with 'label' (extracted text) and 'success' status.
        """
        # Brief delay to let the box settle under the camera
        await asyncio.sleep(1.5)

        frame = self._camera.get_latest_frame()
        if frame is None:
            return {"success": False, "label": "", "error": "No frame available"}

        # Crop to fixed pick zone (125x125 centered at frame_center + 50px right, + 75px down)
        frame, _, _ = self._crop_to_pick_zone(frame)

        # Optionally crop further to last detected bbox
        # if use_bbox and self._last_bbox:
            # frame = self._crop_to_bbox(frame, self._last_bbox, margin=crop_margin)

        # Save debug image to see what is sent to the API
        cv2.imwrite("/app/debug_label_crop.jpg", frame)
        logger.info(f"read_label: saved debug crop to /app/debug_label_crop.jpg (shape={frame.shape})")

        # Encode frame to JPEG
        encode_params = [cv2.IMWRITE_JPEG_QUALITY, 90]
        success, encoded = cv2.imencode(".jpg", frame, encode_params)
        if not success:
            return {"success": False, "label": "", "error": "Failed to encode image"}

        image_bytes = encoded.tobytes()
        b64_image = base64.b64encode(image_bytes).decode()

        try:
            client = self._get_openai_client()
            response = await asyncio.wait_for(
                client.chat.completions.create(
                    model=self._azure_deployment,
                    messages=[
                        {
                            "role": "user",
                            "content": [
                                {"type": "text", "text": prompt},
                                {
                                    "type": "image_url",
                                    "image_url": {"url": f"data:image/jpeg;base64,{b64_image}"},
                                },
                            ],
                        }
                    ],
                    max_completion_tokens=300,
                ),
                timeout=50.0,  # generous timeout to handle cold-start connection
            )

            label = response.choices[0].message.content or ""
            logger.info(f"OpenAI Vision response: {label[:100]}...")
            return {"success": True, "label": label.strip()}

        except asyncio.TimeoutError:
            logger.error("OpenAI Vision timeout after 25 seconds")
            return {"success": False, "label": "", "error": "OpenAI Vision timeout"}
        except Exception as e:
            logger.error(f"OpenAI Vision error: {e}")
            return {"success": False, "label": "", "error": str(e)}

    async def check_quality(
        self,
        prompt: str,
        use_bbox: bool = False,
        crop_margin: float = 0.1,
    ) -> dict:
        """
        Use GPT-4V to check if a label is readable.

        Args:
            prompt: Instruction for quality check (should ask for READABLE/NOT_READABLE).
            use_bbox: If True and last detection exists, crop to that region.
            crop_margin: Margin around bbox as fraction of bbox size.

        Returns:
            Dict with 'readable' (bool) and 'success' status.
        """
        # Brief delay to let the box settle under the camera
        await asyncio.sleep(1.5)

        frame = self._camera.get_latest_frame()
        if frame is None:
            return {"success": False, "readable": False, "error": "No frame available"}

        # Crop to fixed pick zone
        frame, _, _ = self._crop_to_pick_zone(frame)

        # Save debug image
        cv2.imwrite("/app/debug_qc_crop.jpg", frame)
        logger.info(f"check_quality: saved debug crop to /app/debug_qc_crop.jpg (shape={frame.shape})")

        # Encode frame to JPEG
        encode_params = [cv2.IMWRITE_JPEG_QUALITY, 90]
        success, encoded = cv2.imencode(".jpg", frame, encode_params)
        if not success:
            return {"success": False, "readable": False, "error": "Failed to encode image"}

        image_bytes = encoded.tobytes()
        b64_image = base64.b64encode(image_bytes).decode()

        try:
            client = self._get_openai_client()
            response = await asyncio.wait_for(
                client.chat.completions.create(
                    model=self._azure_deployment,
                    messages=[
                        {
                            "role": "user",
                            "content": [
                                {"type": "text", "text": prompt},
                                {
                                    "type": "image_url",
                                    "image_url": {"url": f"data:image/jpeg;base64,{b64_image}"},
                                },
                            ],
                        }
                    ],
                    max_completion_tokens=50,
                ),
                timeout=50.0,
            )

            raw_response = response.choices[0].message.content or ""
            raw_response = raw_response.strip().upper()
            logger.info(f"check_quality OpenAI response: {raw_response}")

            # Parse response - look for READABLE or NOT_READABLE
            readable = "READABLE" in raw_response and "NOT_READABLE" not in raw_response

            return {
                "success": True,
                "readable": readable,
                "raw_response": raw_response,
            }

        except asyncio.TimeoutError:
            logger.error("check_quality: OpenAI Vision timeout")
            return {"success": False, "readable": False, "error": "OpenAI Vision timeout"}
        except Exception as e:
            logger.error(f"check_quality: OpenAI Vision error: {e}")
            return {"success": False, "readable": False, "error": str(e)}

    def _crop_to_pick_zone(self, frame: np.ndarray) -> tuple[np.ndarray, int, int]:
        """Crop frame to the fixed pick zone (300x350 at center + 70px right, + 15px down).

        Returns:
            Tuple of (cropped_frame, offset_x, offset_y) where offsets map
            cropped coordinates back to the original frame.
        """
        h, w = frame.shape[:2]
        cx = w // 2 + 70
        cy = h // 2 + 15
        crop_w = 300
        crop_h = 350

        x1 = max(0, cx - crop_w // 2)
        y1 = max(0, cy - crop_h // 2)
        x2 = min(w, x1 + crop_w)
        y2 = min(h, y1 + crop_h)

        return frame[y1:y2, x1:x2], x1, y1

    def _crop_to_bbox(
        self,
        frame: np.ndarray,
        bbox: BoundingBox,
        margin: float = 0.1,
    ) -> np.ndarray:
        """Crop frame to bounding box with margin."""
        h, w = frame.shape[:2]

        # Add margin
        margin_x = bbox.width * margin
        margin_y = bbox.height * margin

        x1 = max(0, int(bbox.x - margin_x))
        y1 = max(0, int(bbox.y - margin_y))
        x2 = min(w, int(bbox.x + bbox.width + margin_x))
        y2 = min(h, int(bbox.y + bbox.height + margin_y))

        return frame[y1:y2, x1:x2]

    # --- Snapshot ---

    def get_snapshot_jpeg(self, quality: int = 90) -> Optional[bytes]:
        """Get current frame as JPEG for REST endpoint."""
        return self._camera.get_frame_jpeg(quality=quality)

    def get_state_summary(self) -> dict:
        """Get camera state summary."""
        dims = self._camera.get_frame_dimensions()
        return {
            "connected": self._camera.has_frame(),
            "streaming": self._streaming,
            "frame_size": {"width": dims[0], "height": dims[1]} if dims else None,
            "last_detection": self._last_bbox.to_dict() if self._last_bbox else None,
        }



================================================
FILE: backend/src/executors/dobot_nova5_executor.py
================================================
"""Executor wrapping DobotNova5Node for motion control."""

import asyncio
import logging
import math
from typing import TYPE_CHECKING, Optional

from .base import Executor

if TYPE_CHECKING:
    from nodes.dobot_nova5_node import DobotNova5Node

logger = logging.getLogger(__name__)


class DobotNova5Executor(Executor):
    """
    Executor for DOBOT Nova 5 motion commands.

    Wraps DobotNova5Node and provides the same async interface as RobotExecutor
    so all existing skills (move_joint, move_linear, palletize) work unchanged.

    Key difference from UR: DOBOT uses ROS 2 service calls for motion. These
    services accept the command and return quickly (fire-and-forget). Motion
    completion is detected by polling joint stability — identical to how
    robot_executor handles move_linear.

    Service calls are blocking (use time.sleep internally) and must NOT be
    called directly from the asyncio thread. They are always dispatched via
    run_in_executor() so the event loop stays free during motion.
    """

    executor_type = "robot"

    def __init__(self, node: "DobotNova5Node"):
        self._node = node
        self._motion_poll_interval = 0.1  # seconds

    async def initialize(self) -> None:
        """Wait for DOBOT connection and enable the arm."""
        logger.info("DobotNova5Executor initializing...")
        timeout = 10.0
        elapsed = 0.0
        while self._node.get_joint_positions() is None and elapsed < timeout:
            await asyncio.sleep(0.1)
            elapsed += 0.1

        if self._node.get_joint_positions() is None:
            logger.warning("DOBOT joint positions not available after timeout — robot may not be connected")
            return

        # Enable robot (blocking call, dispatched to thread pool)
        loop = asyncio.get_event_loop()
        enabled = await loop.run_in_executor(None, self._node.enable_robot)
        if enabled:
            logger.info("DobotNova5Executor ready")
        else:
            logger.warning("DobotNova5Executor: EnableRobot failed — check DOBOT connection")

    async def shutdown(self) -> None:
        pass

    def is_ready(self) -> bool:
        return self._node.get_joint_positions() is not None

    async def move_joint(
        self,
        target_rad: list[float],
        acceleration: float = 1.4,
        velocity: float = 1.05,
        tolerance_rad: float = 0.02,
        timeout: float = 60.0,
    ) -> bool:
        """
        Execute a joint-space move and wait for completion.

        Args:
            target_rad: Target joint positions in radians (converted from skill params).
            acceleration: Unused for DOBOT (controlled by firmware speed settings).
            velocity: Unused for DOBOT (controlled by firmware speed settings).
            tolerance_rad: Position tolerance in radians for completion detection.
            timeout: Maximum time to wait for motion completion.

        Returns:
            True if motion completed within tolerance, False on timeout.
        """
        target_deg = [math.degrees(r) for r in target_rad]
        tolerance_deg = math.degrees(tolerance_rad)

        logger.info(f"DobotNova5Executor: Starting JointMovJ to {target_deg}")

        loop = asyncio.get_event_loop()
        ok = await loop.run_in_executor(
            None, self._node.send_joint_move, *target_deg
        )
        if not ok:
            logger.error("DobotNova5Executor: JointMovJ service call failed")
            return False

        # Poll until target reached or timeout
        elapsed = 0.0
        while elapsed < timeout:
            if self._node.joints_at_target(target_deg, tolerance_deg=tolerance_deg):
                logger.info("DobotNova5Executor: Joint target reached")
                return True
            await asyncio.sleep(self._motion_poll_interval)
            elapsed += self._motion_poll_interval

        logger.error(f"DobotNova5Executor: Joint move timeout after {timeout}s")
        return False

    async def move_linear(
        self,
        pose: list[float],
        acceleration: float = 1.2,
        velocity: float = 0.25,
        timeout: float = 60.0,
    ) -> bool:
        """
        Execute a Cartesian linear move and wait for completion.

        Args:
            pose: Target pose [x, y, z, rx, ry, rz] in meters and radians (SI units).
            acceleration: Unused for DOBOT.
            velocity: Unused for DOBOT.
            timeout: Maximum time to wait for motion completion.

        Returns:
            True if motion completed (joints stable), False on timeout.
        """
        x, y, z, rx, ry, rz = pose
        # DOBOT firmware expects mm for xyz, degrees for rotations
        x_mm = x * 1000.0
        y_mm = y * 1000.0
        z_mm = z * 1000.0
        rx_deg = math.degrees(rx)
        ry_deg = math.degrees(ry)
        rz_deg = math.degrees(rz)

        logger.info(f"DobotNova5Executor: Starting MovL to [{x_mm:.1f},{y_mm:.1f},{z_mm:.1f}] mm")

        loop = asyncio.get_event_loop()
        ok = await loop.run_in_executor(
            None, self._node.send_linear_move, x_mm, y_mm, z_mm, rx_deg, ry_deg, rz_deg
        )
        if not ok:
            logger.error("DobotNova5Executor: MovL service call failed")
            return False

        # Detect completion by waiting for joints to stop moving
        elapsed = 0.0
        prev_joints = None
        stable_count = 0
        stable_threshold = 3

        while elapsed < timeout:
            await asyncio.sleep(self._motion_poll_interval)
            elapsed += self._motion_poll_interval

            current = self._node.get_joint_positions()
            if current is None:
                continue

            if prev_joints is not None:
                max_diff = max(abs(c - p) for c, p in zip(current, prev_joints))
                if max_diff < 0.001:
                    stable_count += 1
                    if stable_count >= stable_threshold:
                        logger.info(f"DobotNova5Executor: Linear move complete (stable for {stable_count} polls)")
                        return True
                else:
                    stable_count = 0

            prev_joints = current

        logger.error(f"DobotNova5Executor: Linear move timeout after {timeout}s")
        return False

    async def set_tool_output(self, index: int, status: int) -> bool:
        """Control a tool digital output (ToolDO).

        Dual-solenoid pneumatic gripper:
          index=1, status=1 → close
          index=2, status=1 → open
        """
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, self._node.tool_do, index, status)

    def get_joint_positions_deg(self) -> Optional[list[float]]:
        return self._node.get_joint_positions_deg()

    def get_state_summary(self) -> dict:
        return self._node.get_state_summary()



================================================
FILE: backend/src/executors/hand_executor.py
================================================
"""Executor for the COVVI prosthetic hand."""

import asyncio
import logging
from typing import TYPE_CHECKING, Optional

from .base import Executor

if TYPE_CHECKING:
    from nodes.covvi_hand_node import CovviHandNode

logger = logging.getLogger(__name__)


class HandExecutor(Executor):
    """
    Executor for COVVI hand operations.

    Wraps CovviHandNode and provides an async interface for skills.
    """

    executor_type = "hand"

    def __init__(self, hand_node: "CovviHandNode"):
        self._node = hand_node

    async def initialize(self) -> None:
        """Wait for the hand connection to be established."""
        logger.info("HandExecutor initializing...")
        timeout = 10.0
        elapsed = 0.0
        while not self._node.is_connected() and elapsed < timeout:
            await asyncio.sleep(0.1)
            elapsed += 0.1
        if self._node.is_connected():
            logger.info("HandExecutor ready")
        else:
            logger.warning(
                "HandExecutor: COVVI hand not reachable after timeout — "
                "hand skills will fail until connection is established"
            )

    async def shutdown(self) -> None:
        pass

    def is_ready(self) -> bool:
        return self._node.is_connected()

    async def set_grip(self, grip_name: str) -> None:
        """Set a predefined grip by name."""
        logger.info(f"HandExecutor: setting grip={grip_name!r}")
        self._node.set_grip(grip_name)

    async def set_finger_positions(self, speed: int = 50, **fingers) -> None:
        """Set individual finger positions."""
        logger.info(f"HandExecutor: set_finger_positions speed={speed} fingers={fingers}")
        self._node.set_finger_positions(speed, **fingers)
        await asyncio.sleep(0.05)  # Brief delay for propagation

    def get_hand_state(self) -> Optional[dict]:
        """Return the latest finger positions."""
        return self._node.get_hand_state()

    def get_hand_status(self) -> Optional[dict]:
        """Return latest stall/gripping flags per finger."""
        return self._node.get_hand_status()

    async def grip_until_contact(
        self,
        speed: int,
        fingers: list,
        min_contacts: int,
        timeout_s: float,
    ) -> dict:
        """
        Close fingers at the given speed until min_contacts stall, or release on timeout.

        Returns:
            {"contacted": bool, "contact_fingers": list[str]}
        """
        self._node.set_finger_positions(speed, **{f: 100 for f in fingers})

        loop = asyncio.get_event_loop()
        deadline = loop.time() + timeout_s
        while loop.time() < deadline:
            await asyncio.sleep(0.05)
            status = self._node.get_hand_status()
            if status:
                contacted = [f for f in fingers if status.get(f, False)]
                if len(contacted) >= min_contacts:
                    self._node.stop_fingers()
                    return {"contacted": True, "contact_fingers": contacted}

        # Timeout — open fingers back up
        self._node.set_finger_positions(50, **{f: 0 for f in fingers})
        return {"contacted": False, "contact_fingers": []}



================================================
FILE: backend/src/executors/io_executor.py
================================================
"""I/O executor for digital input/output operations."""

import asyncio
import logging
from typing import TYPE_CHECKING, Optional, Any

from .base import Executor

if TYPE_CHECKING:
    from nodes.ur_node import RobotNode

logger = logging.getLogger(__name__)


class IOExecutor(Executor):
    """
    Executor for digital I/O operations.

    Works with any node that has _io_states, get_digital_input,
    get_digital_output, and set_digital_output.
    """

    executor_type = "io"

    def __init__(self, io_node: Any, executor_type: str = "io"):
        self._node = io_node
        self.executor_type = executor_type

    async def initialize(self) -> None:
        """Wait for I/O state availability."""
        logger.info(f"IOExecutor ({self.executor_type}) initializing...")
        timeout = 10.0
        elapsed = 0.0
        while self._node._io_states is None and elapsed < timeout:
            await asyncio.sleep(0.1)
            elapsed += 0.1
        if self._node._io_states is None:
            logger.warning(f"IOExecutor ({self.executor_type}): I/O states not available after timeout")
        else:
            logger.info(f"IOExecutor ({self.executor_type}) ready")

    async def shutdown(self) -> None:
        """No cleanup needed."""
        pass

    def is_ready(self) -> bool:
        """Check if I/O states are available."""
        return self._node._io_states is not None

    async def get_digital_input(self, pin: int) -> Optional[bool]:
        """
        Read a digital input pin.

        Args:
            pin: Digital input pin number.

        Returns:
            Current pin state, or None if unavailable.
        """
        return self._node.get_digital_input(pin)

    async def get_digital_output(self, pin: int) -> Optional[bool]:
        """
        Read a digital output pin state.

        Args:
            pin: Digital output pin number.

        Returns:
            Current pin state, or None if unavailable.
        """
        return self._node.get_digital_output(pin)

    async def set_digital_output(self, pin: int, value: bool) -> None:
        """
        Set a digital output pin.

        Args:
            pin: Digital output pin number.
            value: Desired pin state.
        """
        logger.info(f"IOExecutor ({self.executor_type}): Setting DO[{pin}] = {value}")
        self._node.set_digital_output(pin, value)
        await asyncio.sleep(0.05)  # Brief delay for I/O propagation

    async def wait_for_digital_input(
        self,
        pin: int,
        expected_value: bool,
        timeout: float = 30.0,
        poll_interval: float = 0.1,
    ) -> bool:
        """
        Wait for a digital input to reach expected value.

        Args:
            pin: Digital input pin number.
            expected_value: Value to wait for.
            timeout: Maximum wait time in seconds.
            poll_interval: Polling interval in seconds.

        Returns:
            True if expected value reached, False if timeout.
        """
        elapsed = 0.0
        while elapsed < timeout:
            current = await self.get_digital_input(pin)
            if current == expected_value:
                return True
            await asyncio.sleep(poll_interval)
            elapsed += poll_interval
        return False



================================================
FILE: backend/src/executors/robot_executor.py
================================================
"""Robot executor wrapping RobotNode for motion control."""

import asyncio
import logging
from typing import TYPE_CHECKING, Optional

from .base import Executor

if TYPE_CHECKING:
    from nodes.ur_node import RobotNode

logger = logging.getLogger(__name__)


class RobotExecutor(Executor):
    """
    Executor for robot motion commands.

    Wraps RobotNode and provides async interface for skills.
    Handles the URScript control pattern: send command, poll completion, resend program.
    """

    executor_type = "robot"

    def __init__(self, robot_node: "RobotNode"):
        self._robot = robot_node
        self._motion_poll_interval = 0.1  # seconds

    async def initialize(self) -> None:
        """Wait for robot connection and set TCP."""
        logger.info("RobotExecutor initializing...")
        timeout = 10.0
        elapsed = 0.0
        while self._robot.get_joint_positions() is None and elapsed < timeout:
            await asyncio.sleep(0.1)
            elapsed += 0.1
        if self._robot.get_joint_positions() is None:
            logger.warning("Robot joint positions not available after timeout")
        else:
            # Set TCP offset once connected
            self._robot.set_tcp()
            logger.info("RobotExecutor ready (TCP configured)")

    async def shutdown(self) -> None:
        """No cleanup needed - RobotNode lifecycle managed elsewhere."""
        pass

    def is_ready(self) -> bool:
        """Check if robot is connected (has joint positions)."""
        return self._robot.get_joint_positions() is not None

    async def move_joint(
        self,
        target_rad: list[float],
        acceleration: float = 1.4,
        velocity: float = 1.05,
        tolerance_rad: float = 0.02,
        timeout: float = 60.0,
    ) -> bool:
        """
        Execute a movej command and wait for completion.

        Args:
            target_rad: Target joint positions in radians.
            acceleration: Joint acceleration in rad/s².
            velocity: Joint velocity in rad/s.
            tolerance_rad: Position tolerance in radians.
            timeout: Maximum time to wait for motion completion.

        Returns:
            True if motion completed successfully, False otherwise.
        """
        logger.info(f"RobotExecutor: Starting movej to {target_rad}")

        # Send the motion command (interrupts External Control)
        self._robot.send_movej(target_rad, accel=acceleration, vel=velocity)

        # Poll until target reached or timeout
        elapsed = 0.0
        while elapsed < timeout:
            if self._robot.joints_at_target(target_rad, tolerance=tolerance_rad):
                logger.info("RobotExecutor: Target reached")
                # Restore External Control
                await asyncio.sleep(0.2)  # Brief delay before resend
                self._robot.resend_robot_program()
                return True
            await asyncio.sleep(self._motion_poll_interval)
            elapsed += self._motion_poll_interval

        logger.error(f"RobotExecutor: Motion timeout after {timeout}s")
        self._robot.resend_robot_program()
        return False

    async def move_linear(
        self,
        pose: list[float],
        acceleration: float = 1.2,
        velocity: float = 0.25,
        timeout: float = 60.0,
    ) -> bool:
        """
        Execute a movel command and wait for completion.

        Args:
            pose: Target pose [x, y, z, rx, ry, rz] in meters and radians.
            acceleration: Tool acceleration in m/s².
            velocity: Tool velocity in m/s.
            timeout: Maximum time to wait for motion completion.

        Returns:
            True if motion completed successfully, False otherwise.
        """
        logger.info(f"RobotExecutor: Starting movel to {pose}")

        self._robot.send_movel(pose, accel=acceleration, vel=velocity)

        # Wait for motion to complete by detecting when joints stop moving
        elapsed = 0.0
        prev_joints = None
        stable_count = 0
        stable_threshold = 3  # Number of consecutive stable readings

        while elapsed < timeout:
            await asyncio.sleep(self._motion_poll_interval)
            elapsed += self._motion_poll_interval

            current_joints = self._robot.get_joint_positions()
            if current_joints is None:
                continue

            if prev_joints is not None:
                # Check if joints have stopped moving (all within tolerance)
                max_diff = max(abs(c - p) for c, p in zip(current_joints, prev_joints))
                if max_diff < 0.001:  # Less than ~0.06 degrees movement
                    stable_count += 1
                    if stable_count >= stable_threshold:
                        logger.info(f"RobotExecutor: Motion complete (stable for {stable_count} polls)")
                        await asyncio.sleep(0.2)  # Brief delay before resend
                        self._robot.resend_robot_program()
                        return True
                else:
                    stable_count = 0

            prev_joints = current_joints

        logger.error(f"RobotExecutor: Motion timeout after {timeout}s")
        self._robot.resend_robot_program()
        return False

    async def set_digital_output(self, pin: int, value: bool) -> None:
        """
        Set a digital output pin.

        Uses secondary script so it doesn't interrupt motion.
        """
        logger.info(f"RobotExecutor: Setting DO[{pin}] = {value}")
        self._robot.set_digital_output(pin, value)
        await asyncio.sleep(0.05)  # Brief delay for I/O propagation

    def get_joint_positions_deg(self) -> Optional[list[float]]:
        """Get current joint positions in degrees."""
        return self._robot.get_joint_positions_deg()

    def get_state_summary(self) -> dict:
        """Get robot state summary."""
        return self._robot.get_state_summary()



================================================
FILE: backend/src/flow/__init__.py
================================================
"""Flow execution system for industrial automation."""

from .schemas import (
    ErrorConfig,
    ErrorHandling,
    FlowExecutionStatus,
    FlowSchema,
    FlowStatusResponse,
    StateSchema,
    StepSchema,
    TransitionSchema,
)
from .loader import FlowLoader
from .executor import FlowExecutor, FlowExecutionResult, StepExecutionResult
from .manager import FlowManager

__all__ = [
    "ErrorConfig",
    "ErrorHandling",
    "FlowExecutionResult",
    "FlowExecutionStatus",
    "FlowExecutor",
    "FlowLoader",
    "FlowManager",
    "FlowSchema",
    "FlowStatusResponse",
    "StateSchema",
    "StepExecutionResult",
    "StepSchema",
    "TransitionSchema",
]



================================================
FILE: backend/src/flow/conditions.py
================================================
"""Condition evaluator for conditional transitions.

Supports conditions based on:
- IO states: io_robot.input[0], io_robot.output[1]
- Variables: {{label_data.label}}, {{some_var}}
- Comparisons: ==, !=, and, or

Examples:
    "io_robot.input[0] == true"
    "io_robot.output[1] == false"
    "{{label_data.label}} == 'product_A'"
    "io_robot.input[0] == true and io_robot.output[1] == false"
"""

import logging
import re
from typing import TYPE_CHECKING, Any, Optional

if TYPE_CHECKING:
    from executors import Executor

logger = logging.getLogger(__name__)

# Pattern for IO access: io_robot.input[0], io_robot.output[1]
IO_PATTERN = re.compile(r"io_robot\.(input|output)\[(\d+)\]")

# Pattern for variable interpolation: {{var_name}} or {{var.nested.path}}
VAR_PATTERN = re.compile(r"\{\{([\w.]+)\}\}")


def _get_nested_value(variables: dict, path: str) -> Any:
    """Get a value from variables using dot notation."""
    parts = path.split(".")
    value = variables
    for part in parts:
        if isinstance(value, dict):
            value = value.get(part)
        else:
            return None
        if value is None:
            return None
    return value


def _resolve_io_value(
    match: re.Match, executors: dict[str, "Executor"]
) -> Optional[bool]:
    """Resolve an IO pattern match to its current value."""
    io_type = match.group(1)  # "input" or "output"
    pin = int(match.group(2))

    executor = executors.get("io_robot")

    if executor is None:
        logger.warning("Executor 'io_robot' not found for condition")
        return None

    # Access the IO state synchronously from cached values
    # IOExecutor wraps nodes that have _io_states cached
    node = executor._node

    if io_type == "input":
        return node.get_digital_input(pin)
    else:
        return node.get_digital_output(pin)


def _parse_value(token: str) -> Any:
    """Parse a value token to its Python equivalent."""
    token = token.strip()

    if token.lower() == "true":
        return True
    elif token.lower() == "false":
        return False
    elif token.lower() == "none" or token.lower() == "null":
        return None

    # Try numeric
    try:
        if "." in token:
            return float(token)
        return int(token)
    except ValueError:
        pass

    # String (with or without quotes)
    if (token.startswith("'") and token.endswith("'")) or (
        token.startswith('"') and token.endswith('"')
    ):
        return token[1:-1]

    return token


def _evaluate_comparison(left: Any, op: str, right: Any) -> bool:
    """Evaluate a comparison between two values."""
    if op == "==":
        return left == right
    elif op == "!=":
        return left != right
    elif op == ">":
        return left > right if left is not None and right is not None else False
    elif op == "<":
        return left < right if left is not None and right is not None else False
    elif op == ">=":
        return left >= right if left is not None and right is not None else False
    elif op == "<=":
        return left <= right if left is not None and right is not None else False
    else:
        logger.warning(f"Unknown operator: {op}")
        return False


def _resolve_token(
    token: str, variables: dict, executors: dict[str, "Executor"]
) -> Any:
    """Resolve a token to its value (IO, variable, or literal)."""
    token = token.strip()

    # Check for IO pattern
    io_match = IO_PATTERN.fullmatch(token)
    if io_match:
        return _resolve_io_value(io_match, executors)

    # Check for variable pattern
    var_match = VAR_PATTERN.fullmatch(token)
    if var_match:
        return _get_nested_value(variables, var_match.group(1))

    # Otherwise, parse as literal value
    return _parse_value(token)


def evaluate_condition(
    condition: str,
    variables: dict,
    executors: dict[str, "Executor"],
) -> bool:
    """
    Evaluate a condition expression.

    Args:
        condition: The condition string to evaluate
        variables: Flow runtime variables
        executors: Dict of executors for IO access

    Returns:
        True if condition is met, False otherwise

    Examples:
        "io_robot.input[0] == true"
        "io_machine.input[1] == false"
        "{{label_data.label}} == 'product_A'"
        "io_robot.input[0] == true and io_machine.input[1] == false"
    """
    if not condition or not condition.strip():
        return True  # Empty condition is always true

    condition = condition.strip()
    logger.debug(f"Evaluating condition: {condition}")

    # Handle 'and' / 'or' (simple left-to-right, no precedence)
    # Split on ' and ' first, then handle ' or ' within each part
    if " or " in condition.lower():
        parts = re.split(r"\s+or\s+", condition, flags=re.IGNORECASE)
        for part in parts:
            if evaluate_condition(part, variables, executors):
                return True
        return False

    if " and " in condition.lower():
        parts = re.split(r"\s+and\s+", condition, flags=re.IGNORECASE)
        for part in parts:
            if not evaluate_condition(part, variables, executors):
                return False
        return True

    # Single comparison: left op right
    # Supported operators: ==, !=, >, <, >=, <=
    comparison_match = re.match(
        r"(.+?)\s*(==|!=|>=|<=|>|<)\s*(.+)", condition
    )
    if comparison_match:
        left_token = comparison_match.group(1)
        op = comparison_match.group(2)
        right_token = comparison_match.group(3)

        left_value = _resolve_token(left_token, variables, executors)
        right_value = _resolve_token(right_token, variables, executors)

        result = _evaluate_comparison(left_value, op, right_value)
        # logger.info(
        #     f"Condition check: {left_token}={left_value} {op} {right_token}={right_value} -> {result}"
        # )
        return result

    # Single token (truthy check)
    value = _resolve_token(condition, variables, executors)
    return bool(value)



================================================
FILE: backend/src/flow/executor.py
================================================
"""Flow executor - state machine runner with error handling."""

import asyncio
import copy
import logging
import re
import time
from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Any, Callable, Optional

from .schemas import (
    ErrorHandling,
    FlowExecutionStatus,
    FlowSchema,
    StepSchema,
)
from skills import get_skill, ExecutionContext, SkillResult

if TYPE_CHECKING:
    from executors import Executor

logger = logging.getLogger(__name__)

# Regex patterns for variable interpolation
VAR_PATTERN = re.compile(r"\{\{([\w.]+)\}\}")
LOOKUP_PATTERN = re.compile(r"\{\{lookup:([\w.]+):([\w.]+):([\w.]+)\}\}")
POP_PATTERN = re.compile(r"\{\{pop:([\w.]+):([\w.]+):([\w.]+)\}\}")
GET_PATTERN = re.compile(r"\{\{get:([\w.]+):([\w.]+):([\w.]+)\}\}")


class FlowPositionsExhausted(Exception):
    """Raised when a pop operation finds an empty list, signalling graceful flow completion."""

    pass


@dataclass
class StepExecutionResult:
    """Result of executing a single step."""

    step_id: str
    skill: str
    success: bool
    data: dict = field(default_factory=dict)
    error: Optional[str] = None
    retries: int = 0
    duration_ms: float = 0


@dataclass
class FlowExecutionResult:
    """Result of executing a complete flow."""

    flow_id: str
    status: FlowExecutionStatus
    states_completed: list[str] = field(default_factory=list)
    steps_executed: list[StepExecutionResult] = field(default_factory=list)
    error_message: Optional[str] = None
    duration_ms: float = 0


# Event callback type for WebSocket broadcasting
EventCallback = Callable[[str, dict], None]


class FlowExecutor:
    """
    State machine executor for flows.

    Traverses states sequentially, executing steps within each state.
    Handles per-step error handling strategies.
    Emits events via callback for WebSocket telemetry.
    """

    def __init__(
        self,
        flow: FlowSchema,
        executors: dict[str, "Executor"],
        on_event: Optional[EventCallback] = None,
    ):
        self._flow = flow
        self._executors = executors
        self._on_event = on_event or (lambda t, d: None)
        self._abort_requested = False
        self._finish_requested = False
        self._paused = False
        self._pause_event = asyncio.Event()
        self._pause_event.set()  # Not paused initially
        self._status = FlowExecutionStatus.IDLE
        self._current_state: Optional[str] = None
        self._current_step: Optional[str] = None
        # Runtime variables: starts with flow-defined variables (lookup tables)
        self._variables: dict[str, Any] = copy.deepcopy(flow.variables)

    def request_abort(self) -> None:
        """Request abort of current execution."""
        logger.info(f"Abort requested for flow {self._flow.id}")
        self._abort_requested = True
        # Resume if paused to allow abort to proceed
        self._pause_event.set()

    def request_pause(self) -> None:
        """Request pause of current execution."""
        logger.info(f"Pause requested for flow {self._flow.id}")
        self._paused = True
        self._pause_event.clear()
        self._emit("flow_paused", {})

    def request_resume(self) -> None:
        """Request resume of paused execution."""
        logger.info(f"Resume requested for flow {self._flow.id}")
        self._paused = False
        self._pause_event.set()
        self._emit("flow_resumed", {})

    def request_finish(self) -> None:
        """Request graceful finish — complete current loop cycle then stop."""
        logger.info(f"Finish requested for flow {self._flow.id}")
        self._finish_requested = True

    def get_status(self) -> tuple[FlowExecutionStatus, Optional[str], Optional[str]]:
        """Get current execution status."""
        if self._paused:
            return FlowExecutionStatus.PAUSED, self._current_state, self._current_step
        return self._status, self._current_state, self._current_step

    def is_paused(self) -> bool:
        """Check if execution is currently paused."""
        return self._paused

    def _emit(self, event_type: str, data: dict) -> None:
        """Emit an event via callback."""
        self._on_event(event_type, {"flow_id": self._flow.id, **data})

    def _get_nested_value(self, path: str) -> Any:
        """
        Get a value from variables using dot notation.

        Examples:
            "label" -> self._variables["label"]
            "label_data.label" -> self._variables["label_data"]["label"]
        """
        parts = path.split(".")
        value = self._variables
        for part in parts:
            if isinstance(value, dict):
                value = value.get(part)
            else:
                return None
            if value is None:
                return None
        return value

    def _resolve_value(self, value: Any) -> Any:
        """
        Resolve interpolation in a value.

        Supports:
        - {{var_name}} - get runtime variable
        - {{var.nested.path}} - get nested value from variable
        - {{lookup:map_name:key_path:default_key}} - lookup in map using variable as key
        - {{get:map_name:key_path:default_key}} - get first element from list without removing
        - {{pop:map_name:key_path:default_key}} - pop first element from list (mutating)
        """
        if isinstance(value, str):
            # Check for pop pattern: {{pop:map_name:key_path:default_key}}
            # Like lookup, but pops the first element from the list (mutates _variables).
            pop_match = POP_PATTERN.fullmatch(value)
            if pop_match:
                map_name, key_path, default_key = pop_match.groups()
                lookup_map = self._get_nested_value(map_name)
                if not isinstance(lookup_map, dict):
                    lookup_map = {}
                key_value = self._get_nested_value(key_path)
                if key_value is None:
                    key_value = default_key
                positions_list = lookup_map.get(key_value, lookup_map.get(default_key))
                if not isinstance(positions_list, list) or len(positions_list) == 0:
                    logger.info(
                        f"Pop {map_name}[{key_value}]: list empty, signalling completion"
                    )
                    raise FlowPositionsExhausted(
                        f"No more positions in {map_name}[{key_value}]"
                    )
                resolved = positions_list.pop(0)
                logger.debug(
                    f"Pop {map_name}[{key_value}] -> {resolved} "
                    f"({len(positions_list)} remaining)"
                )
                return resolved

            # Check for get pattern: {{get:map_name:key_path:default_key}}
            # Like pop, but returns first element WITHOUT removing it (non-mutating).
            get_match = GET_PATTERN.fullmatch(value)
            if get_match:
                map_name, key_path, default_key = get_match.groups()
                lookup_map = self._get_nested_value(map_name)
                if not isinstance(lookup_map, dict):
                    lookup_map = {}
                key_value = self._get_nested_value(key_path)
                if key_value is None:
                    key_value = default_key
                positions_list = lookup_map.get(key_value, lookup_map.get(default_key))
                if not isinstance(positions_list, list) or len(positions_list) == 0:
                    logger.warning(f"Get {map_name}[{key_value}]: list empty or not found")
                    return None
                resolved = positions_list[0]  # Get first element without removing
                logger.debug(f"Get {map_name}[{key_value}] -> {resolved}")
                return resolved

            # Check for lookup pattern: {{lookup:map_name:key_path:default_key}}
            lookup_match = LOOKUP_PATTERN.fullmatch(value)
            if lookup_match:
                map_name, key_path, default_key = lookup_match.groups()
                lookup_map = self._get_nested_value(map_name)
                if not isinstance(lookup_map, dict):
                    lookup_map = {}
                key_value = self._get_nested_value(key_path)
                if key_value is None:
                    key_value = default_key
                resolved = lookup_map.get(key_value, lookup_map.get(default_key))
                logger.debug(f"Lookup {map_name}[{key_value}] -> {resolved}")
                return resolved

            # Check for simple variable: {{var_name}} or {{var.nested.path}}
            var_match = VAR_PATTERN.fullmatch(value)
            if var_match:
                var_path = var_match.group(1)
                resolved = self._get_nested_value(var_path)
                logger.debug(f"Variable {var_path} -> {resolved}")
                return resolved

            return value

        elif isinstance(value, dict):
            return {k: self._resolve_value(v) for k, v in value.items()}

        elif isinstance(value, list):
            return [self._resolve_value(v) for v in value]

        return value

    def _resolve_params(self, params: dict) -> dict:
        """Resolve all interpolations in step parameters."""
        return self._resolve_value(params)

    async def _get_next_state_with_condition_polling(
        self, current_state: str, poll_interval_ms: int = 100
    ) -> Optional[str]:
        """
        Get next state, polling conditions if needed.

        If there are conditional transitions from current state:
        - If a sequential fallback also exists, evaluate conditions once
          and use the sequential transition as an "else" branch.
        - If no sequential fallback, poll conditions until one matches.
        - Respect pause/abort requests while polling.

        If no conditional transitions, fall back to sequential.

        Args:
            current_state: Current state name
            poll_interval_ms: Interval between condition checks

        Returns:
            Next state name or None
        """
        # Check if there are conditional transitions from this state
        if not self._flow.has_conditional_transitions(current_state):
            # No conditionals, use sequential transition
            return self._flow.get_sequential_transition(current_state)

        # Check for a sequential fallback (acts as "else" branch)
        sequential_fallback = self._flow.get_sequential_transition(current_state)

        if sequential_fallback is not None:
            # Mixed mode: evaluate conditions once, fall back to sequential
            next_state = self._flow.evaluate_conditional_transitions(
                current_state,
                variables=self._variables,
                executors=self._executors,
            )
            if next_state:
                logger.info(f"Condition met, transitioning to: {next_state}")
                return next_state
            logger.info(
                f"No condition met from '{current_state}', "
                f"using sequential fallback to '{sequential_fallback}'"
            )
            return sequential_fallback

        # No sequential fallback: poll conditional transitions until one matches
        self._emit("waiting_condition", {"state": current_state})
        logger.info(f"Waiting for condition from state: {current_state}")

        poll_count = 0
        while True:
            # Check for abort
            if self._abort_requested:
                return None

            # Check for pause
            await self._pause_event.wait()

            poll_count += 1

            # Evaluate conditional transitions
            next_state = self._flow.evaluate_conditional_transitions(
                current_state,
                variables=self._variables,
                executors=self._executors,
            )

            if next_state:
                logger.info(f"Condition met after {poll_count} polls, transitioning to: {next_state}")
                return next_state

            # Log every 50 polls (5 seconds at 100ms interval)
            if poll_count % 50 == 0:
                logger.info(f"Still waiting for condition from '{current_state}' (poll #{poll_count})")

            # Wait before next poll
            await asyncio.sleep(poll_interval_ms / 1000.0)

    async def execute(self) -> FlowExecutionResult:
        """
        Execute the flow from initial state.

        Returns:
            FlowExecutionResult with status and step results.
        """
        self._abort_requested = False
        self._status = FlowExecutionStatus.RUNNING
        start_time = time.monotonic()

        result = FlowExecutionResult(
            flow_id=self._flow.id, status=FlowExecutionStatus.RUNNING
        )

        self._emit("flow_started", {"name": self._flow.name})
        logger.info(f"Starting flow: {self._flow.id} ({self._flow.name})")

        current_state_name = self._flow.initial_state

        try:
            while current_state_name is not None:
                if self._abort_requested:
                    logger.info("Flow aborted by user")
                    result.status = FlowExecutionStatus.ABORTED
                    self._emit("flow_aborted", {})
                    break

                state = self._flow.get_state(current_state_name)
                if state is None:
                    error_msg = f"State '{current_state_name}' not found"
                    logger.error(error_msg)
                    result.status = FlowExecutionStatus.ERROR
                    result.error_message = error_msg
                    self._emit("flow_error", {"error": error_msg})
                    break

                self._current_state = current_state_name
                self._emit("state_entered", {"state": current_state_name})
                logger.info(f"Entering state: {current_state_name}")

                # Execute all steps in this state
                try:
                    for step in state.steps:
                        # Check for pause before each step
                        await self._pause_event.wait()

                        if self._abort_requested:
                            break

                        step_result = await self._execute_step(step)
                        result.steps_executed.append(step_result)

                        if not step_result.success:
                            # Error handling is done in _execute_step
                            # If we get here with failure, it means we should stop
                            if step.error_handling.strategy == ErrorHandling.STOP:
                                result.status = FlowExecutionStatus.ERROR
                                result.error_message = step_result.error
                                self._emit(
                                    "flow_error",
                                    {"error": step_result.error, "step_id": step.id},
                                )
                                return self._finalize_result(result, start_time)
                except FlowPositionsExhausted as e:
                    logger.info(f"Flow completing: {e}")
                    result.status = FlowExecutionStatus.COMPLETED
                    self._emit("flow_completed", {"status": "completed", "reason": str(e)})
                    return self._finalize_result(result, start_time)

                if self._abort_requested:
                    continue

                result.states_completed.append(current_state_name)
                self._emit("state_completed", {"state": current_state_name})

                # Get next state with condition polling
                current_state_name = await self._get_next_state_with_condition_polling(
                    current_state_name
                )
                if current_state_name is None and self._flow.loop and not self._finish_requested:
                    current_state_name = self._flow.initial_state
                    logger.info(f"Looping back to initial state: {current_state_name}")
                    self._emit("loop_restart", {"initial_state": current_state_name})
                elif current_state_name is None and self._finish_requested:
                    logger.info("Finish requested — exiting loop")

            # Flow completed successfully (if not aborted/errored)
            if result.status == FlowExecutionStatus.RUNNING:
                result.status = FlowExecutionStatus.COMPLETED
                self._emit("flow_completed", {"status": "completed"})
                logger.info(f"Flow completed: {self._flow.id}")

        except Exception as e:
            logger.exception(f"Unexpected error in flow execution: {e}")
            result.status = FlowExecutionStatus.ERROR
            result.error_message = str(e)
            self._emit("flow_error", {"error": str(e)})

        return self._finalize_result(result, start_time)

    def _finalize_result(
        self, result: FlowExecutionResult, start_time: float
    ) -> FlowExecutionResult:
        """Finalize result with timing and status update."""
        result.duration_ms = (time.monotonic() - start_time) * 1000
        self._status = result.status
        self._current_state = None
        self._current_step = None
        return result

    async def _execute_step(self, step: StepSchema) -> StepExecutionResult:
        """
        Execute a single step with error handling.

        Implements retry, skip, and fallback strategies.
        """
        self._current_step = step.id
        start_time = time.monotonic()

        self._emit(
            "step_started",
            {"step_id": step.id, "skill": step.skill, "executor": step.executor},
        )
        logger.info(f"Executing step: {step.id} (skill={step.skill})")

        result = StepExecutionResult(
            step_id=step.id,
            skill=step.skill,
            success=False,
        )

        # Get the skill
        try:
            skill = get_skill(step.skill)
        except KeyError as e:
            result.error = str(e)
            self._emit("step_error", {"step_id": step.id, "error": result.error})
            return result

        # Resolve parameter interpolation and parse
        try:
            resolved_params = self._resolve_params(step.params)
            logger.debug(f"Resolved params for {step.id}: {resolved_params}")
            params = skill.parse_params(resolved_params)
            valid, validation_error = await skill.validate(params)
            if not valid:
                result.error = f"Validation failed: {validation_error}"
                self._emit("step_error", {"step_id": step.id, "error": result.error})
                return result
        except Exception as e:
            result.error = f"Parameter error: {e}"
            self._emit("step_error", {"step_id": step.id, "error": result.error})
            return result

        # Create execution context with variables
        context = ExecutionContext(
            flow_id=self._flow.id,
            step_id=step.id,
            state_name=self._current_state or "",
            executor_type=step.executor,
            executors=self._executors,
            variables=self._variables,
        )

        # Execute with retry logic
        max_attempts = (
            step.error_handling.max_retries + 1
            if step.error_handling.strategy == ErrorHandling.RETRY
            else 1
        )

        last_error: Optional[str] = None

        for attempt in range(max_attempts):
            if self._abort_requested:
                result.error = "Aborted"
                return result

            try:
                # Execute with timeout
                skill_result = await asyncio.wait_for(
                    skill.execute(params, context),
                    timeout=step.timeout_ms / 1000.0,
                )

                if skill_result.success:
                    result.success = True
                    result.data = skill_result.data
                    result.retries = attempt
                    result.duration_ms = (time.monotonic() - start_time) * 1000

                    # Store result in variables if store_result is specified
                    if step.store_result:
                        self._variables[step.store_result] = skill_result.data
                        logger.info(f"Stored result in variable '{step.store_result}': {skill_result.data}")

                    self._emit(
                        "step_completed",
                        {
                            "step_id": step.id,
                            "result": skill_result.data,
                            "retries": attempt,
                        },
                    )
                    logger.info(f"Step completed: {step.id}")
                    return result
                else:
                    last_error = skill_result.error
                    logger.warning(
                        f"Step {step.id} failed (attempt {attempt + 1}): {last_error}"
                    )

            except asyncio.TimeoutError:
                last_error = f"Timeout after {step.timeout_ms}ms"
                logger.warning(f"Step {step.id} timed out (attempt {attempt + 1})")

            except Exception as e:
                last_error = str(e)
                logger.exception(f"Step {step.id} exception (attempt {attempt + 1})")

            # Retry delay (if not last attempt)
            if attempt < max_attempts - 1:
                self._emit(
                    "step_retry",
                    {
                        "step_id": step.id,
                        "attempt": attempt + 1,
                        "max_retries": step.error_handling.max_retries,
                    },
                )
                await asyncio.sleep(step.error_handling.retry_delay_ms / 1000.0)

        # All attempts failed
        result.error = last_error
        result.retries = max_attempts - 1
        result.duration_ms = (time.monotonic() - start_time) * 1000

        # Apply error handling strategy
        strategy = step.error_handling.strategy

        if strategy == ErrorHandling.SKIP:
            logger.warning(f"Step {step.id} failed but SKIP strategy - continuing")
            result.success = True  # Mark as "successful" for flow continuation
            self._emit(
                "step_skipped",
                {"step_id": step.id, "error": result.error, "strategy": "skip"},
            )
        elif strategy == ErrorHandling.FALLBACK:
            # TODO: Execute fallback skill
            logger.warning(f"FALLBACK strategy not yet implemented for step {step.id}")
            self._emit(
                "step_error",
                {"step_id": step.id, "error": result.error, "strategy": "fallback"},
            )
        else:
            self._emit(
                "step_error",
                {"step_id": step.id, "error": result.error, "strategy": "stop"},
            )

        return result



================================================
FILE: backend/src/flow/loader.py
================================================
"""File-based flow persistence."""

import json
import logging
from pathlib import Path
from typing import Optional

from .schemas import FlowSchema

logger = logging.getLogger(__name__)


class FlowLoader:
    """
    Load and save flows from/to JSON files.

    Flows are stored in a configured directory, one file per flow.
    File naming: {flow_id}.json
    """

    def __init__(self, flows_dir: str = "/app/flows"):
        self._flows_dir = Path(flows_dir)
        self._flows_dir.mkdir(parents=True, exist_ok=True)
        logger.info(f"FlowLoader initialized with directory: {self._flows_dir}")

    def _flow_path(self, flow_id: str) -> Path:
        """Get file path for a flow ID."""
        # Sanitize flow_id to prevent path traversal
        safe_id = "".join(c for c in flow_id if c.isalnum() or c in "-_")
        return self._flows_dir / f"{safe_id}.json"

    def list_flows(self) -> list[str]:
        """List all available flow IDs."""
        flow_ids = []
        for path in self._flows_dir.glob("*.json"):
            flow_ids.append(path.stem)
        return sorted(flow_ids)

    def load(self, flow_id: str) -> Optional[FlowSchema]:
        """
        Load a flow by ID.

        Returns:
            FlowSchema if found, None otherwise.
        """
        path = self._flow_path(flow_id)
        if not path.exists():
            logger.warning(f"Flow file not found: {path}")
            return None

        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
            flow = FlowSchema.model_validate(data)
            logger.info(f"Loaded flow: {flow_id}")
            return flow
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON in flow file {path}: {e}")
            return None
        except Exception as e:
            logger.error(f"Error loading flow {flow_id}: {e}")
            return None

    def save(self, flow: FlowSchema) -> bool:
        """
        Save a flow to file.

        Returns:
            True if saved successfully, False otherwise.
        """
        path = self._flow_path(flow.id)

        try:
            with open(path, "w", encoding="utf-8") as f:
                json.dump(flow.model_dump(), f, indent=2)
            logger.info(f"Saved flow: {flow.id} to {path}")
            return True
        except Exception as e:
            logger.error(f"Error saving flow {flow.id}: {e}")
            return False

    def delete(self, flow_id: str) -> bool:
        """
        Delete a flow file.

        Returns:
            True if deleted, False if not found or error.
        """
        path = self._flow_path(flow_id)
        if not path.exists():
            return False

        try:
            path.unlink()
            logger.info(f"Deleted flow: {flow_id}")
            return True
        except Exception as e:
            logger.error(f"Error deleting flow {flow_id}: {e}")
            return False

    def load_all(self) -> list[FlowSchema]:
        """Load all available flows."""
        flows = []
        for flow_id in self.list_flows():
            flow = self.load(flow_id)
            if flow:
                flows.append(flow)
        return flows



================================================
FILE: backend/src/flow/manager.py
================================================
"""Flow manager - orchestration layer for flow execution."""

import asyncio
import logging
from typing import TYPE_CHECKING, Optional

from .executor import FlowExecutor, FlowExecutionResult
from .loader import FlowLoader
from .schemas import FlowExecutionStatus, FlowSchema, FlowStatusResponse

if TYPE_CHECKING:
    from api.websocket.manager import WebSocketManager
    from executors import Executor

logger = logging.getLogger(__name__)


class FlowManager:
    """
    Orchestration layer for flow execution.

    - Enforces single flow execution (rejects new requests while busy)
    - Manages flow loading/saving
    - Creates executors and FlowExecutor instances
    - Provides status queries
    """

    def __init__(
        self,
        executors: dict[str, "Executor"],
        ws_manager: "WebSocketManager",
        flows_dir: str = "/app/flows",
    ):
        self._executors = executors
        self._ws_manager = ws_manager
        self._loader = FlowLoader(flows_dir)

        self._current_executor: Optional[FlowExecutor] = None
        self._current_task: Optional[asyncio.Task] = None
        self._last_result: Optional[FlowExecutionResult] = None
        self._lock = asyncio.Lock()

    # --- Flow CRUD ---

    def list_flows(self) -> list[str]:
        """List all available flow IDs."""
        return self._loader.list_flows()

    def get_flow(self, flow_id: str) -> Optional[FlowSchema]:
        """Get a flow by ID."""
        return self._loader.load(flow_id)

    def save_flow(self, flow: FlowSchema) -> tuple[bool, Optional[str]]:
        """
        Save a flow.

        Returns:
            Tuple of (success, error_message).
        """
        # Validate flow structure
        valid, error = flow.validate_flow()
        if not valid:
            return False, error

        if self._loader.save(flow):
            return True, None
        return False, "Failed to save flow"

    def delete_flow(self, flow_id: str) -> bool:
        """Delete a flow."""
        return self._loader.delete(flow_id)

    # --- Execution Control ---

    async def start_flow(self, flow_id: str) -> tuple[bool, str]:
        """
        Start executing a flow.

        Returns:
            Tuple of (started, message).
        """
        async with self._lock:
            # Check if already running
            if self._is_running_locked():
                return False, "A flow is already running"

            # Load the flow
            flow = self._loader.load(flow_id)
            if flow is None:
                return False, f"Flow '{flow_id}' not found"

            # Validate
            valid, error = flow.validate_flow()
            if not valid:
                return False, f"Flow validation failed: {error}"

            # Create executor
            self._current_executor = FlowExecutor(
                flow=flow,
                executors=self._executors,
                on_event=self._ws_manager.create_event_callback(),
            )

            # Start execution task
            self._current_task = asyncio.create_task(self._run_flow())
            logger.info(f"Started flow: {flow_id}")
            return True, f"Flow '{flow_id}' started"

    async def _run_flow(self) -> None:
        """Execute the flow and store result."""
        if self._current_executor is None:
            return

        try:
            self._last_result = await self._current_executor.execute()
        except Exception as e:
            logger.exception(f"Flow execution error: {e}")
            self._last_result = FlowExecutionResult(
                flow_id=self._current_executor._flow.id,
                status=FlowExecutionStatus.ERROR,
                error_message=str(e),
            )
        finally:
            async with self._lock:
                self._current_executor = None
                self._current_task = None

    async def abort_flow(self) -> tuple[bool, str]:
        """
        Abort the currently running flow.

        Returns:
            Tuple of (aborted, message).
        """
        async with self._lock:
            if not self._is_running_locked():
                return False, "No flow is currently running"

            if self._current_executor:
                self._current_executor.request_abort()
                logger.info("Abort requested")
                return True, "Abort requested"

            return False, "No executor to abort"

    async def finish_flow(self) -> tuple[bool, str]:
        """
        Request graceful finish — complete current loop cycle then stop.

        Returns:
            Tuple of (success, message).
        """
        async with self._lock:
            if not self._is_running_locked():
                return False, "No flow is currently running"

            if self._current_executor:
                self._current_executor.request_finish()
                logger.info("Finish requested")
                return True, "Finish requested — flow will stop after current cycle"

            return False, "No executor to finish"

    async def pause_flow(self) -> tuple[bool, str]:
        """
        Pause the currently running flow.

        Returns:
            Tuple of (paused, message).
        """
        async with self._lock:
            if not self._is_running_locked():
                return False, "No flow is currently running"

            if self._current_executor:
                if self._current_executor.is_paused():
                    return False, "Flow is already paused"
                self._current_executor.request_pause()
                logger.info("Pause requested")
                return True, "Flow paused"

            return False, "No executor to pause"

    async def resume_flow(self) -> tuple[bool, str]:
        """
        Resume a paused flow.

        Returns:
            Tuple of (resumed, message).
        """
        async with self._lock:
            if not self._is_running_locked():
                return False, "No flow is currently running"

            if self._current_executor:
                if not self._current_executor.is_paused():
                    return False, "Flow is not paused"
                self._current_executor.request_resume()
                logger.info("Resume requested")
                return True, "Flow resumed"

            return False, "No executor to resume"

    def _is_running_locked(self) -> bool:
        """Check if a flow is running (must hold lock)."""
        return (
            self._current_task is not None
            and not self._current_task.done()
        )

    # --- Status ---

    def get_status(self) -> FlowStatusResponse:
        """Get current execution status."""
        if self._current_executor is not None and self._current_task is not None:
            if not self._current_task.done():
                status, state, step = self._current_executor.get_status()
                return FlowStatusResponse(
                    status=status,
                    flow_id=self._current_executor._flow.id,
                    current_state=state,
                    current_step=step,
                )

        # Not running - return last result status or idle
        if self._last_result is not None:
            return FlowStatusResponse(
                status=self._last_result.status,
                flow_id=self._last_result.flow_id,
                error_message=self._last_result.error_message,
            )

        return FlowStatusResponse(status=FlowExecutionStatus.IDLE)

    def get_last_result(self) -> Optional[FlowExecutionResult]:
        """Get the result of the last flow execution."""
        return self._last_result

    def is_running(self) -> bool:
        """Check if a flow is currently running."""
        return (
            self._current_task is not None
            and not self._current_task.done()
        )



================================================
FILE: backend/src/flow/schemas.py
================================================
"""Flow schema definitions for the flowdiagram execution system."""

from enum import Enum
from typing import TYPE_CHECKING, Any, Literal, Optional

from pydantic import BaseModel, Field

if TYPE_CHECKING:
    from executors import Executor


class ErrorHandling(str, Enum):
    """Error handling strategies for skill execution."""

    STOP = "stop"  # Abort entire flow
    RETRY = "retry"  # Retry N times, then stop
    SKIP = "skip"  # Log error, continue to next step
    FALLBACK = "fallback"  # Execute fallback skill


class ErrorConfig(BaseModel):
    """Configuration for error handling on a per-step basis."""

    strategy: ErrorHandling = ErrorHandling.STOP
    max_retries: int = Field(default=3, ge=0, le=10)
    retry_delay_ms: int = Field(default=1000, ge=0, le=60000)
    fallback_skill: Optional[str] = None


class StepSchema(BaseModel):
    """A single step within a state, executing a skill."""

    id: str = Field(..., min_length=1, description="Unique step identifier")
    skill: str = Field(..., min_length=1, description="Skill name to execute")
    executor: Literal["robot", "camera", "io_robot", "hand"] = Field(
        default="robot", description="Executor type for this step"
    )
    params: dict = Field(default_factory=dict, description="Skill parameters")
    store_result: Optional[str] = Field(
        default=None, description="Variable name to store the skill result (stores result.data)"
    )
    error_handling: ErrorConfig = Field(
        default_factory=ErrorConfig, description="Error handling configuration"
    )
    timeout_ms: int = Field(
        default=30000, ge=100, le=600000, description="Timeout in milliseconds"
    )


class StateSchema(BaseModel):
    """A state in the flow containing zero or more steps."""

    name: str = Field(..., min_length=1, description="State name (unique within flow)")
    steps: list[StepSchema] = Field(
        default_factory=list, description="Steps to execute in this state"
    )


class TransitionSchema(BaseModel):
    """Transition between states."""

    type: Literal["sequential", "conditional"] = Field(
        default="sequential", description="Transition type"
    )
    from_state: str = Field(..., min_length=1, description="Source state name")
    to_state: str = Field(..., min_length=1, description="Target state name")
    condition: Optional[str] = Field(
        default=None, description="Condition expression for conditional transitions"
    )


class FlowSchema(BaseModel):
    """Complete flow definition."""

    id: str = Field(..., min_length=1, description="Unique flow identifier")
    name: str = Field(..., min_length=1, description="Human-readable flow name")
    initial_state: str = Field(..., min_length=1, description="Starting state name")
    loop: bool = Field(
        default=False,
        description="If True, restart from initial_state after last state completes",
    )
    variables: dict = Field(
        default_factory=dict, description="Flow variables and lookup tables"
    )
    states: list[StateSchema] = Field(..., min_length=1, description="List of states")
    transitions: list[TransitionSchema] = Field(
        default_factory=list, description="State transitions"
    )

    def get_state(self, name: str) -> Optional[StateSchema]:
        """Get a state by name."""
        for state in self.states:
            if state.name == name:
                return state
        return None

    def has_conditional_transitions(self, state_name: str) -> bool:
        """Check if a state has any conditional transitions."""
        return any(
            t.from_state == state_name and t.type == "conditional"
            for t in self.transitions
        )

    def get_sequential_transition(self, current_state: str) -> Optional[str]:
        """Get the sequential transition target from a state (if any)."""
        for transition in self.transitions:
            if transition.from_state == current_state and transition.type == "sequential":
                return transition.to_state
        return None

    def evaluate_conditional_transitions(
        self,
        current_state: str,
        variables: Optional[dict[str, Any]] = None,
        executors: Optional[dict[str, "Executor"]] = None,
    ) -> Optional[str]:
        """
        Evaluate conditional transitions from a state.

        Args:
            current_state: Current state name
            variables: Flow runtime variables
            executors: Dict of executors (for IO-based conditions)

        Returns:
            Target state name if a condition matches, None otherwise
        """
        from .conditions import evaluate_condition

        variables = variables or {}
        executors = executors or {}

        for transition in self.transitions:
            if (
                transition.from_state == current_state
                and transition.type == "conditional"
                and transition.condition
            ):
                if evaluate_condition(transition.condition, variables, executors):
                    return transition.to_state

        return None

    def get_next_state(
        self,
        current_state: str,
        variables: Optional[dict[str, Any]] = None,
        executors: Optional[dict[str, "Executor"]] = None,
    ) -> Optional[str]:
        """
        Get the next state based on transitions.

        Evaluates conditional transitions first (in order), then falls back
        to sequential transitions if no conditional matches.

        Args:
            current_state: Current state name
            variables: Flow runtime variables (for condition evaluation)
            executors: Dict of executors (for IO-based conditions)

        Returns:
            Next state name or None if no transition found
        """
        # First, check conditional transitions
        result = self.evaluate_conditional_transitions(current_state, variables, executors)
        if result:
            return result

        # Fall back to sequential transition
        return self.get_sequential_transition(current_state)

    def validate_flow(self) -> tuple[bool, Optional[str]]:
        """Validate flow structure."""
        state_names = {s.name for s in self.states}

        # Check initial state exists
        if self.initial_state not in state_names:
            return False, f"Initial state '{self.initial_state}' not found in states"

        # Check all transitions reference valid states
        for t in self.transitions:
            if t.from_state not in state_names:
                return False, f"Transition from_state '{t.from_state}' not found"
            if t.to_state not in state_names:
                return False, f"Transition to_state '{t.to_state}' not found"

        # Check for duplicate state names
        if len(state_names) != len(self.states):
            return False, "Duplicate state names found"

        # Check for duplicate step IDs within the flow
        step_ids: set[str] = set()
        for state in self.states:
            for step in state.steps:
                if step.id in step_ids:
                    return False, f"Duplicate step ID '{step.id}' found"
                step_ids.add(step.id)

        return True, None


class FlowExecutionStatus(str, Enum):
    """Status of flow execution."""

    IDLE = "idle"
    RUNNING = "running"
    PAUSED = "paused"
    WAITING_CONDITION = "waiting_condition"  # Waiting for a conditional transition
    COMPLETED = "completed"
    ABORTED = "aborted"
    ERROR = "error"


class FlowStatusResponse(BaseModel):
    """Response for flow status queries."""

    status: FlowExecutionStatus
    flow_id: Optional[str] = None
    current_state: Optional[str] = None
    current_step: Optional[str] = None
    error_message: Optional[str] = None



================================================
FILE: backend/src/nodes/camera_bridge_node.py
================================================
"""ROS 2 node that bridges WebSocket camera frames to ROS topics."""

import asyncio
import logging
import os
import threading
from typing import Optional

import cv2
import numpy as np
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from sensor_msgs.msg import Image

logger = logging.getLogger(__name__)

MAX_QUEUE_SIZE = 1  # Always use freshest frame


class CameraBridgeNode(Node):
    """
    ROS 2 node that receives camera frames from a WebSocket server
    and publishes them as ROS Image messages.

    This enables streaming from a Windows RealSense camera to the
    Docker backend via WebSocket, then republishing to the standard
    ROS camera topic that CameraNode subscribes to.
    """

    def __init__(self):
        super().__init__("camera_bridge_node")

        # Configuration from environment
        self.ws_host = os.environ.get("CAMERA_BRIDGE_HOST", "host.docker.internal")
        self.ws_port = int(os.environ.get("CAMERA_BRIDGE_PORT", "8765"))
        self.ws_uri = f"ws://{self.ws_host}:{self.ws_port}"

        # QoS matching RealSense defaults (BEST_EFFORT)
        qos = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            history=HistoryPolicy.KEEP_LAST,
            depth=1,
        )

        # Publisher for raw camera images
        self.image_pub = self.create_publisher(
            Image, "/camera/camera/color/image_raw", qos
        )

        # Connection state
        self._connected = False
        self._reconnect_delay = 2.0
        self._running = True

        # Frame queue for dropping old frames
        self._frame_queue: Optional[asyncio.Queue] = None

        # Start WebSocket client in background thread
        self._ws_thread = threading.Thread(target=self._run_ws_client, daemon=True)
        self._ws_thread.start()

        self.get_logger().info(
            f"CameraBridgeNode initialized — connecting to {self.ws_uri}"
        )

    def _run_ws_client(self) -> None:
        """Run the WebSocket client in its own asyncio event loop."""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            loop.run_until_complete(self._ws_client_loop())
        except Exception as e:
            self.get_logger().error(f"WebSocket client loop error: {e}")
        finally:
            loop.close()

    async def _ws_client_loop(self) -> None:
        """Main WebSocket client loop with auto-reconnect."""
        try:
            import websockets
        except ImportError:
            self.get_logger().error(
                "websockets package not installed. Run: pip install websockets"
            )
            return

        while self._running:
            try:
                self.get_logger().info(f"Connecting to camera server at {self.ws_uri}")
                async with websockets.connect(self.ws_uri) as websocket:
                    self._connected = True
                    self.get_logger().info("Connected to camera server")

                    # Create bounded queue and start processor
                    self._frame_queue = asyncio.Queue(maxsize=MAX_QUEUE_SIZE)
                    processor_task = asyncio.create_task(self._process_loop())

                    try:
                        async for message in websocket:
                            if not self._running:
                                break
                            # Drop oldest frame if queue is full
                            if self._frame_queue.full():
                                try:
                                    self._frame_queue.get_nowait()
                                except asyncio.QueueEmpty:
                                    pass
                            try:
                                self._frame_queue.put_nowait(message)
                            except asyncio.QueueFull:
                                pass  # Skip frame
                    finally:
                        processor_task.cancel()
                        try:
                            await processor_task
                        except asyncio.CancelledError:
                            pass

            except websockets.exceptions.ConnectionClosed:
                self.get_logger().warn("Camera server connection closed")
            except ConnectionRefusedError:
                self.get_logger().warn(
                    f"Camera server not available at {self.ws_uri}",
                    throttle_duration_sec=10.0,
                )
            except Exception as e:
                self.get_logger().error(f"WebSocket error: {e}")
            finally:
                self._connected = False
                self._frame_queue = None

            if self._running:
                self.get_logger().info(
                    f"Reconnecting in {self._reconnect_delay} seconds..."
                )
                await asyncio.sleep(self._reconnect_delay)

    async def _process_loop(self) -> None:
        """Process frames from the queue."""
        while self._running and self._frame_queue:
            try:
                jpeg_data = await asyncio.wait_for(
                    self._frame_queue.get(), timeout=0.033
                )
                self._process_frame(jpeg_data)
            except asyncio.TimeoutError:
                continue
            except asyncio.CancelledError:
                break
            except Exception as e:
                self.get_logger().error(f"Process loop error: {e}")

    def _process_frame(self, jpeg_data: bytes) -> None:
        """Decode JPEG and publish as ROS Image message."""
        try:
            # Decode JPEG to numpy array
            np_arr = np.frombuffer(jpeg_data, dtype=np.uint8)
            frame_bgr = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)

            if frame_bgr is None:
                self.get_logger().warn("Failed to decode JPEG frame")
                return

            # Convert BGR to RGB for ROS
            frame_rgb = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2RGB)

            # Create ROS Image message
            msg = Image()
            msg.header.stamp = self.get_clock().now().to_msg()
            msg.header.frame_id = "camera_color_optical_frame"
            msg.height, msg.width = frame_rgb.shape[:2]
            msg.encoding = "rgb8"
            msg.is_bigendian = False
            msg.step = msg.width * 3
            msg.data = frame_rgb.tobytes()

            self.image_pub.publish(msg)

            # Log periodically
            if not hasattr(self, '_frame_count'):
                self._frame_count = 0
            self._frame_count += 1
            if self._frame_count % 100 == 0:
                self.get_logger().info(f"Published {self._frame_count} frames ({msg.width}x{msg.height})")

        except Exception as e:
            self.get_logger().error(f"Error processing frame: {e}")

    def is_connected(self) -> bool:
        """Check if connected to the camera server."""
        return self._connected

    def destroy_node(self) -> None:
        """Clean up resources."""
        self._running = False
        super().destroy_node()



================================================
FILE: backend/src/nodes/camera_node.py
================================================
"""ROS 2 node for RealSense camera image subscription."""

import threading
from typing import Optional

import cv2
import numpy as np
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from sensor_msgs.msg import Image


class CameraNode(Node):
    """
    ROS 2 node that subscribes to RealSense camera images.

    Stores the latest frame and a cached JPEG in a thread-safe manner
    for access by the executor.
    """

    def __init__(self):
        super().__init__("camera_node")

        self._frame: Optional[np.ndarray] = None
        self._frame_jpeg: Optional[bytes] = None
        self._frame_lock = threading.Lock()

        # QoS must match the RealSense publisher (BEST_EFFORT)
        qos = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            history=HistoryPolicy.KEEP_LAST,
            depth=1,
        )

        # Subscribe to RealSense color image topic
        self.create_subscription(
            Image,
            "/camera/camera/color/image_raw",
            self._on_image,
            qos,
        )

        self.get_logger().info(
            "CameraNode initialized — waiting for /camera/camera/color/image_raw"
        )

    def _on_image(self, msg: Image) -> None:
        """Convert ROS Image (rgb8) to OpenCV BGR numpy array and cache it + JPEG."""
        if msg.encoding not in ("rgb8", "RGB8"):
            self.get_logger().warn(
                f"Unexpected encoding: {msg.encoding}", throttle_duration_sec=5.0
            )
            return

        frame_rgb = np.frombuffer(msg.data, dtype=np.uint8).reshape(
            (msg.height, msg.width, 3)
        )
        frame_bgr = cv2.cvtColor(frame_rgb, cv2.COLOR_RGB2BGR)

        # Encode JPEG once and cache it alongside the raw frame
        success, jpeg_data = cv2.imencode(
            ".jpg", frame_bgr, [cv2.IMWRITE_JPEG_QUALITY, 70]
        )

        with self._frame_lock:
            self._frame = frame_bgr
            if success:
                self._frame_jpeg = jpeg_data.tobytes()

        # Log periodically
        if not hasattr(self, '_recv_count'):
            self._recv_count = 0
        self._recv_count += 1
        if self._recv_count % 100 == 0:
            self.get_logger().info(f"Received {self._recv_count} frames ({msg.width}x{msg.height})")

    def get_latest_frame(self) -> Optional[np.ndarray]:
        """
        Get the latest camera frame.

        Returns:
            BGR numpy array or None if no frame received yet.
        """
        with self._frame_lock:
            if self._frame is None:
                return None
            return self._frame.copy()

    def get_frame_jpeg(self, quality: int = 80) -> Optional[bytes]:
        """
        Get the latest frame as JPEG bytes (cached, no re-encoding).

        Args:
            quality: JPEG quality (ignored, uses cached encode).

        Returns:
            JPEG bytes or None if no frame available.
        """
        with self._frame_lock:
            return self._frame_jpeg

    def get_frame_dimensions(self) -> Optional[tuple[int, int]]:
        """
        Get current frame dimensions.

        Returns:
            Tuple of (width, height) or None if no frame.
        """
        with self._frame_lock:
            if self._frame is None:
                return None
            h, w = self._frame.shape[:2]
            return (w, h)

    def has_frame(self) -> bool:
        """Check if at least one frame has been received."""
        with self._frame_lock:
            return self._frame is not None



================================================
FILE: backend/src/nodes/covvi_hand_node.py
================================================
"""ROS 2 node wrapping the COVVI prosthetic hand via the eci SDK."""

import logging
import os
import threading
import time
from typing import Optional

from rclpy.node import Node

logger = logging.getLogger(__name__)


class CovviHandNode(Node):
    """
    ROS 2 node that manages a persistent connection to the COVVI hand.

    The eci.CovviInterface uses a context manager for connection lifetime,
    so the connection is kept alive in a background thread (same pattern as
    CameraBridgeNode). Realtime finger position callbacks arrive at ~10Hz.

    Env vars:
        HAND_IP: IP address of the COVVI hand (default: 192.168.163.169)
    """

    def __init__(self):
        super().__init__("covvi_hand_node")

        self._hand_ip = os.environ.get("HAND_IP", "192.168.163.169")
        self._connected = False
        self._running = True
        self._hand = None  # CovviInterface instance (set inside background thread)
        self._hand_state: Optional[dict] = None
        self._hand_status: Optional[dict] = None
        self._lock = threading.Lock()

        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

        self.get_logger().info(
            f"CovviHandNode initialized — connecting to {self._hand_ip}"
        )

    def _run(self) -> None:
        """Open CovviInterface and keep the connection alive."""
        try:
            from eci import CovviInterface

            with CovviInterface(self._hand_ip) as hand:
                hand.setHandPowerOn()
                hand.callbackDigitPosnAll = self._on_hand_state
                hand.callbackDigitStatusAll = self._on_hand_status
                hand.setRealtimeCfg(digit_posn=True, digit_status=True)

                with self._lock:
                    self._hand = hand
                    self._connected = True

                self.get_logger().info(
                    f"Connected to COVVI hand at {self._hand_ip}"
                )

                # Keep the context manager alive until node is destroyed
                while self._running:
                    time.sleep(0.1)

                hand.disableAllRealtimeCfg()

        except ImportError:
            self.get_logger().error(
                "eci package not installed — COVVI hand unavailable"
            )
        except ConnectionRefusedError:
            self.get_logger().warning(
                f"Could not reach COVVI hand at {self._hand_ip}"
            )
        except Exception as e:
            self.get_logger().error(f"COVVI hand error: {e}")
        finally:
            with self._lock:
                self._connected = False
                self._hand = None

    def _on_hand_state(self, msg) -> None:
        """Realtime callback (~10Hz) for finger position updates."""
        with self._lock:
            self._hand_state = {
                "thumb": msg.thumb_pos,
                "index": msg.index_pos,
                "middle": msg.middle_pos,
                "ring": msg.ring_pos,
                "little": msg.little_pos,
                "rotate": msg.rotate_pos,
            }

    def _on_hand_status(self, msg) -> None:
        """Realtime callback (~10Hz) for stall/gripping status."""
        with self._lock:
            self._hand_status = {
                "thumb":  msg.thumb_stall  or msg.thumb_gripping,
                "index":  msg.index_stall  or msg.index_gripping,
                "middle": msg.middle_stall or msg.middle_gripping,
                "little": msg.little_stall or msg.little_gripping,
            }

    # ── Public interface (called from HandExecutor) ─────────────────────────

    def set_grip(self, grip_name: str) -> None:
        """Set a predefined grip by name (e.g. 'POWER', 'RELAXED')."""
        from eci.enums import CurrentGripID

        grip_id = getattr(CurrentGripID, grip_name, None)
        if grip_id is None:
            raise ValueError(f"Unknown grip name: {grip_name!r}")

        with self._lock:
            if self._hand is None:
                raise RuntimeError("COVVI hand not connected")
            self._hand.setCurrentGrip(grip_id)

    def set_finger_positions(self, speed: int = 50, **fingers) -> None:
        """
        Set individual finger positions.

        Args:
            speed: Movement speed (15-100).
            **fingers: Keyword args for each finger (thumb, index, middle,
                       ring, little, rotate), each 0-100. Omitted fingers
                       stay at their current position.
        """
        from eci.primitives.speed import Speed

        with self._lock:
            if self._hand is None:
                raise RuntimeError("COVVI hand not connected")
            self._hand.setDigitPosn(Speed(speed), **fingers)

    def get_hand_state(self) -> Optional[dict]:
        """Return the latest finger positions, or None if not yet received."""
        with self._lock:
            return dict(self._hand_state) if self._hand_state else None

    def get_hand_status(self) -> Optional[dict]:
        """Return latest stall/gripping flags per finger, or None if not yet received."""
        with self._lock:
            return dict(self._hand_status) if self._hand_status else None

    def stop_fingers(self) -> None:
        """Freeze all finger motors in place."""
        with self._lock:
            if self._hand is None:
                raise RuntimeError("COVVI hand not connected")
            self._hand.setDigitPosnStop()

    def is_connected(self) -> bool:
        """Return True if the hand is connected and operational."""
        return self._connected

    def destroy_node(self) -> None:
        self._running = False
        super().destroy_node()



================================================
FILE: backend/src/nodes/dobot_nova5_node.py
================================================
"""ROS 2 node wrapper for DOBOT Nova 5 robot arm (driver V4)."""

import math
import time
from typing import Optional, List

from rclpy.node import Node
from sensor_msgs.msg import JointState
from dobot_msgs_v4.srv import MovJ, MovL, EnableRobot, ClearError, ToolDO


# Joint names as published by the DOBOT V4 feedback node on /joint_states_robot.
# Verify at runtime with: ros2 topic echo /joint_states_robot --once
DOBOT_JOINT_NAMES = ["joint1", "joint2", "joint3", "joint4", "joint5", "joint6"]

# Service namespace (confirmed from DOBOT_6Axis_ROS2_V4 source)
_SRV_PREFIX = "/dobot_bringup_ros2/srv"


class DobotNova5Node(Node):
    """
    Thin ROS 2 node for DOBOT Nova 5 (V4 driver).

    Subscribes to joint state feedback and exposes synchronous motion
    methods (service calls) that can be safely called from a thread pool
    via asyncio.get_event_loop().run_in_executor().

    V4 API notes:
    - MovJ(mode=True,  a-f = J1-J6 degrees)  → joint-space move
    - MovJ(mode=False, a-f = X,Y,Z,Rx,Ry,Rz) → Cartesian point-to-point
    - MovL(a-f = X,Y,Z,Rx,Ry,Rz)             → Cartesian linear move
    - All services return res=0 on success; res=-2 = not in Remote TCP mode
    """

    def __init__(self):
        super().__init__("dobot_nova5_node")

        # Joint state cache (populated by /joint_states_robot subscription)
        self._joint_positions: Optional[dict] = None

        self.create_subscription(
            JointState,
            "/joint_states_robot",
            self._on_joint_states,
            10,
        )

        # Service clients
        self._enable_client = self.create_client(
            EnableRobot, f"{_SRV_PREFIX}/EnableRobot"
        )
        self._movj_client = self.create_client(
            MovJ, f"{_SRV_PREFIX}/MovJ"
        )
        self._movl_client = self.create_client(
            MovL, f"{_SRV_PREFIX}/MovL"
        )
        self._clear_error_client = self.create_client(
            ClearError, f"{_SRV_PREFIX}/ClearError"
        )
        self._tool_do_client = self.create_client(
            ToolDO, f"{_SRV_PREFIX}/ToolDO"
        )

        self.get_logger().info("DobotNova5Node initialized")

    # ── ROS callbacks ────────────────────────────────────────────────────────

    def _on_joint_states(self, msg: JointState) -> None:
        if len(msg.name) == len(msg.position):
            self._joint_positions = dict(zip(msg.name, msg.position))

    # ── Internal: blocking service call helper ───────────────────────────────

    def _call_service(self, client, request, timeout: float = 10.0) -> Optional[object]:
        """
        Call a ROS 2 service synchronously (blocks the calling thread).

        Safe to call from a thread pool (run_in_executor). The MultiThreadedExecutor
        running in a separate thread handles the DDS response callback.

        Returns the response object, or None on timeout/error.
        """
        future = client.call_async(request)
        t0 = time.monotonic()
        while not future.done() and time.monotonic() - t0 < timeout:
            time.sleep(0.05)
        if not future.done():
            self.get_logger().error(
                f"Service call timed out after {timeout}s: {client.srv_name}"
            )
            return None
        return future.result()

    # ── Public sync API ──────────────────────────────────────────────────────

    def enable_robot(self) -> bool:
        """Enable the DOBOT arm. Must be called once before any motion.

        Requires the teach pendant to be in Remote TCP mode (res=-2 otherwise).
        """
        req = EnableRobot.Request()
        resp = self._call_service(self._enable_client, req, timeout=10.0)
        if resp is None:
            return False
        success = resp.res == 0
        if success:
            self.get_logger().info("DOBOT robot enabled")
        else:
            self.get_logger().warning(
                f"EnableRobot returned code {resp.res}"
                + (" (not in Remote TCP mode?)" if resp.res == -2 else "")
            )
        return success

    def clear_error(self) -> bool:
        """Clear active alarms. Call before enable_robot if res=-4."""
        req = ClearError.Request()
        resp = self._call_service(self._clear_error_client, req, timeout=5.0)
        if resp is None:
            return False
        return resp.res == 0

    def tool_do(self, index: int, status: int) -> bool:
        """Control a tool digital output (ToolDO).

        Dual-solenoid pneumatic gripper convention:
          index=1, status=1 → close gripper
          index=2, status=1 → open gripper
        """
        req = ToolDO.Request()
        req.index = index
        req.status = status
        resp = self._call_service(self._tool_do_client, req, timeout=5.0)
        if resp is None:
            return False
        if resp.res != 0:
            self.get_logger().warning(f"ToolDO(index={index}, status={status}) returned code {resp.res}")
            return False
        return True

    def send_joint_move(self, j1: float, j2: float, j3: float,
                        j4: float, j5: float, j6: float) -> bool:
        """
        Send a joint-space move command (degrees) via MovJ with mode=True.

        The service returns quickly after accepting the command — motion is
        still in progress. Completion is detected by polling joint stability
        in the executor.
        """
        req = MovJ.Request()
        req.mode = True  # True = joint space (a-f are J1-J6 in degrees)
        req.a = float(j1)
        req.b = float(j2)
        req.c = float(j3)
        req.d = float(j4)
        req.e = float(j5)
        req.f = float(j6)
        resp = self._call_service(self._movj_client, req, timeout=5.0)
        if resp is None:
            return False
        if resp.res != 0:
            self.get_logger().warning(f"MovJ (joint) returned code {resp.res}")
            return False
        return True

    def send_linear_move(self, x: float, y: float, z: float,
                         rx: float, ry: float, rz: float) -> bool:
        """
        Send a Cartesian linear move command via MovL.

        Units expected by DOBOT firmware: x/y/z in mm, rx/ry/rz in degrees.
        The executor is responsible for converting from SI units (m, rad).

        The service returns quickly after accepting; completion detected by
        polling joint stability in the executor.
        """
        req = MovL.Request()
        req.a = float(x)
        req.b = float(y)
        req.c = float(z)
        req.d = float(rx)
        req.e = float(ry)
        req.f = float(rz)
        resp = self._call_service(self._movl_client, req, timeout=5.0)
        if resp is None:
            return False
        if resp.res != 0:
            self.get_logger().warning(f"MovL returned code {resp.res}")
            return False
        return True

    # ── State queries ────────────────────────────────────────────────────────

    def get_joint_positions(self) -> Optional[List[float]]:
        """Return current joint positions in radians, or None if not yet received.

        The V4 feedback node publishes values already converted to radians.
        """
        if self._joint_positions is None:
            return None
        return [self._joint_positions.get(name, 0.0) for name in DOBOT_JOINT_NAMES]

    def get_joint_positions_deg(self) -> Optional[List[float]]:
        """Return current joint positions in degrees, or None if not yet received."""
        if self._joint_positions is None:
            return None
        return [math.degrees(self._joint_positions.get(name, 0.0))
                for name in DOBOT_JOINT_NAMES]

    def joints_at_target(self, target_deg: List[float], tolerance_deg: float = 1.0) -> bool:
        """Check whether each joint is within tolerance of target (degrees)."""
        current_deg = self.get_joint_positions_deg()
        if current_deg is None:
            return False
        return all(abs(c - t) < tolerance_deg for c, t in zip(current_deg, target_deg))

    def get_state_summary(self) -> dict:
        return {
            "timestamp": time.time(),
            "connected": self._joint_positions is not None,
            "joints_deg": self.get_joint_positions_deg(),
            "io": {"digital_in": [], "digital_out": []},
        }



================================================
FILE: backend/src/nodes/ur_node.py
================================================
import json
import math
import os
import time
from typing import Optional, List

from rclpy.node import Node
from std_msgs.msg import String
from std_srvs.srv import Trigger
from sensor_msgs.msg import JointState
from ur_msgs.msg import IOStates


# UR3 joint names
JOINT_NAMES = [
    "shoulder_pan_joint",
    "shoulder_lift_joint",
    "elbow_joint",
    "wrist_1_joint",
    "wrist_2_joint",
    "wrist_3_joint",
]


class RobotNode(Node):
    def __init__(self):
        super().__init__("robot_node")

        # Publishers
        self.script_pub = self.create_publisher(String, "/urscript_interface/script_command", 10)
        self.digital_in_pub = self.create_publisher(String, "/events/digital_input_change", 10)

        # Subscribers
        self._joint_positions: Optional[dict] = None
        self.create_subscription(JointState, "/joint_states", self._on_joint_states, 10)

        self._io_states: Optional[IOStates] = None
        self._prev_digital_in: dict[int, bool] = {}
        self.create_subscription(IOStates, "/io_and_status_controller/io_states", self._on_io_states, 10)

        # Service Client
        self._resend_client = self.create_client(
            Trigger,
            "/io_and_status_controller/resend_robot_program",
        )

        # TCP configuration from environment (format: "x,y,z,rx,ry,rz" in meters and radians)
        # Default: 55mm Z offset (0.055 meters)
        tcp_str = os.environ.get("ROBOT_TCP_OFFSET", "0,0,0.055,0,0,0")
        self._tcp_offset: List[float] = [float(v.strip()) for v in tcp_str.split(",")]
        self.get_logger().info(f"TCP offset configured: {self._tcp_offset}")

        self.get_logger().info("RobotNode initialized")

    def _on_joint_states(self, msg: JointState):
        if len(msg.name) == len(msg.position):
            self._joint_positions = dict(zip(msg.name, msg.position))

    def _on_io_states(self, msg: IOStates):
        # Detect rising edges on digital inputs
        for s in msg.digital_in_states:
            pin = s.pin
            current = s.state
            prev = self._prev_digital_in.get(pin, False)
            if current and not prev:
                self.get_logger().info(f"Rising edge on digital_in[{pin}]")
                event = String()
                event.data = json.dumps({
                    "pin": pin,
                    "edge": "rising",
                    "timestamp": time.time(),
                })
                self.digital_in_pub.publish(event)
            self._prev_digital_in[pin] = current
        self._io_states = msg


    def send_script(self, script: str) -> None:
        """
        Publish raw URScript to the robot.

        WARNING: this INTERRUPTS the External Control program. The robot will
        execute this script, then stop. After it finishes, call
        resend_robot_program() to restore ros2_control.

        For commands that should NOT interrupt (IO, popups), use
        send_secondary_script() instead.
        """
        msg = String()
        msg.data = script
        self.script_pub.publish(msg)
        self.get_logger().info(f"URScript sent ({len(script)} chars)")

    def send_secondary_script(self, script_body: str) -> None:
        """
        Wrap as secondary program — runs in parallel, does NOT interrupt
        the External Control program or any active motion controller.

        Use for: set_digital_out, popup, textmsg, or any quick command.
        """
        indented = "\n".join(f"  {line}" for line in script_body.strip().split("\n"))
        full_script = f"sec my_sec_prog():\n{indented}\nend\n"
        self.send_script(full_script)

    def set_tcp(self, tcp: Optional[List[float]] = None) -> None:
        """
        Set the Tool Center Point (TCP) offset.

        Args:
            tcp: TCP offset [x, y, z, rx, ry, rz] in meters and radians.
                 If None, uses the configured TCP from environment.
        """
        tcp = tcp or self._tcp_offset
        tcp_str = ", ".join(f"{v:.6f}" for v in tcp)
        self.send_secondary_script(f"set_tcp(p[{tcp_str}])")
        self.get_logger().info(f"TCP set to: {tcp}")

    def send_movej(self, target_rad: List[float], accel: float = 1.4, vel: float = 1.05) -> None:
        joints_str = ", ".join(f"{j:.5f}" for j in target_rad)
        tcp_str = ", ".join(f"{v:.6f}" for v in self._tcp_offset)
        script = f"set_tcp(p[{tcp_str}])\nmovej([{joints_str}], a={accel}, v={vel})\n"
        self.send_script(script)

    def send_movel(self, pose: List[float], accel: float = 1.2, vel: float = 0.25) -> None:
        pose_str = ", ".join(f"{p:.5f}" for p in pose)
        tcp_str = ", ".join(f"{v:.6f}" for v in self._tcp_offset)
        script = f"set_tcp(p[{tcp_str}])\nmovel(p[{pose_str}], a={accel}, v={vel})\n"
        self.send_script(script)

    def set_digital_output(self, pin: int, value: bool) -> None:
        val_str = "True" if value else "False"
        self.send_secondary_script(f"set_digital_out({pin}, {val_str})")

    def resend_robot_program(self) -> bool:
        """
        Must be called after send_script() / send_movej() / send_movel()
        once the robot has finished executing the script.
        """
        if not self._resend_client.service_is_ready():
            self.get_logger().warn("resend_robot_program service not available")
            return False

        future = self._resend_client.call_async(Trigger.Request())

        # Wait for the result — the MultiThreadedExecutor handles the callback
        t0 = time.monotonic()
        while not future.done() and time.monotonic() - t0 < 5.0:
            time.sleep(0.1)

        if not future.done():
            self.get_logger().error("resend_robot_program timed out")
            return False

        result = future.result()
        if not result.success:
            self.get_logger().warn(f"resend_robot_program failed: {result.message}")
            return False

        self.get_logger().info("Robot program resent — control restored")
        return True

    def joints_at_target(self, target_rad: List[float], tolerance: float = 0.02) -> bool:
        """Check if current joints are within tolerance of target.
        Pipelines poll this to know when motion is complete."""
        current = self.get_joint_positions()
        if current is None:
            return False
        return all(abs(c - t) < tolerance for c, t in zip(current, target_rad))

    def get_joint_positions(self) -> Optional[List[float]]:
        if self._joint_positions is None:
            return None
        return [self._joint_positions[name] for name in JOINT_NAMES]

    def get_joint_positions_deg(self) -> Optional[List[float]]:
        rads = self.get_joint_positions()
        if rads is None:
            return None
        return [math.degrees(r) for r in rads]

    def get_digital_input(self, pin: int) -> Optional[bool]:
        if self._io_states is None:
            return None
        if pin >= len(self._io_states.digital_in_states):
            return None
        return self._io_states.digital_in_states[pin].state

    def get_digital_output(self, pin: int) -> Optional[bool]:
        if self._io_states is None:
            return None
        if pin >= len(self._io_states.digital_out_states):
            return None
        return self._io_states.digital_out_states[pin].state

    def get_state_summary(self) -> dict:
        return {
            "timestamp": time.time(),
            "connected": self._joint_positions is not None,
            "joints_deg": self.get_joint_positions_deg(),
            "io": {
                "digital_in": [
                    {"pin": s.pin, "state": s.state}
                    for s in (self._io_states.digital_in_states if self._io_states else [])
                ],
                "digital_out": [
                    {"pin": s.pin, "state": s.state}
                    for s in (self._io_states.digital_out_states if self._io_states else [])
                ],
            },
        }


================================================
FILE: backend/src/skills/__init__.py
================================================
"""Skill system for flowdiagram execution."""

from .base import ExecutionContext, Skill, SkillResult
from .registry import get_skill, list_skills, register_skill

__all__ = [
    "ExecutionContext",
    "Skill",
    "SkillResult",
    "get_skill",
    "list_skills",
    "register_skill",
]



================================================
FILE: backend/src/skills/base.py
================================================
"""Base classes for the skill system."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Generic, Optional, TypeVar

from pydantic import BaseModel


@dataclass
class ExecutionContext:
    """Context passed to skills during execution."""

    flow_id: str
    step_id: str
    state_name: str
    executor_type: str = "robot"
    executors: dict[str, Any] = field(default_factory=dict)
    variables: dict[str, Any] = field(default_factory=dict)

    def get_executor(self, executor_type: Optional[str] = None) -> Any:
        """Get an executor by type. Defaults to step's executor_type if not specified."""
        exec_type = executor_type or self.executor_type
        executor = self.executors.get(exec_type)
        if executor is None:
            raise ValueError(f"Executor '{exec_type}' not available in context")
        return executor

    def get_variable(self, name: str, default: Any = None) -> Any:
        """Get a variable from the flow context."""
        return self.variables.get(name, default)

    def set_variable(self, name: str, value: Any) -> None:
        """Set a variable in the flow context."""
        self.variables[name] = value


@dataclass
class SkillResult:
    """Result returned from skill execution."""

    success: bool
    data: dict = field(default_factory=dict)
    error: Optional[str] = None

    @classmethod
    def ok(cls, data: Optional[dict] = None) -> "SkillResult":
        """Create a successful result."""
        return cls(success=True, data=data or {})

    @classmethod
    def fail(cls, error: str, data: Optional[dict] = None) -> "SkillResult":
        """Create a failed result."""
        return cls(success=False, data=data or {}, error=error)


TParams = TypeVar("TParams", bound=BaseModel)


class Skill(ABC, Generic[TParams]):
    """Abstract base class for all skills."""

    # Class attributes to be defined by subclasses
    name: str = ""
    executor_type: str = "robot"
    description: str = ""

    @classmethod
    @abstractmethod
    def params_schema(cls) -> type[BaseModel]:
        """Return the Pydantic model for this skill's parameters."""
        ...

    @abstractmethod
    async def validate(self, params: TParams) -> tuple[bool, Optional[str]]:
        """
        Validate parameters before execution.

        Returns:
            Tuple of (is_valid, error_message).
            If valid, error_message is None.
        """
        ...

    @abstractmethod
    async def execute(self, params: TParams, context: ExecutionContext) -> SkillResult:
        """
        Execute the skill with the given parameters.

        Args:
            params: Validated parameters for this skill.
            context: Execution context with access to executors.

        Returns:
            SkillResult indicating success/failure and any output data.
        """
        ...

    def parse_params(self, raw_params: dict) -> TParams:
        """Parse raw dict parameters into the typed params model."""
        schema = self.params_schema()
        return schema.model_validate(raw_params)

    def get_metadata(self) -> dict:
        """Get skill metadata for API discovery."""
        schema = self.params_schema()
        return {
            "name": self.name,
            "executor_type": self.executor_type,
            "description": self.description,
            "params_schema": schema.model_json_schema(),
        }



================================================
FILE: backend/src/skills/registry.py
================================================
"""Skill registry with auto-discovery via @register_skill decorator."""

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .base import Skill

_REGISTRY: dict[str, "Skill"] = {}


def register_skill(cls: type["Skill"]) -> type["Skill"]:
    """
    Class decorator to register a skill in the global registry.

    Usage:
        @register_skill
        class MoveJointSkill(Skill[MoveJointParams]):
            name = "move_joint"
            ...
    """
    instance = cls()
    if not instance.name:
        raise ValueError(f"Skill class {cls.__name__} must define a 'name' attribute")
    if instance.name in _REGISTRY:
        raise ValueError(f"Skill '{instance.name}' is already registered")
    _REGISTRY[instance.name] = instance
    return cls


def get_skill(name: str) -> "Skill":
    """
    Get a skill instance by name.

    Raises:
        KeyError: If skill is not registered.
    """
    if name not in _REGISTRY:
        raise KeyError(f"Skill '{name}' not found. Available: {list(_REGISTRY.keys())}")
    return _REGISTRY[name]


def list_skills() -> list[dict]:
    """
    List all registered skills with their metadata.

    Returns:
        List of skill metadata dicts (name, executor_type, description, params_schema).
    """
    return [skill.get_metadata() for skill in _REGISTRY.values()]


def get_skills_by_executor(executor_type: str) -> list["Skill"]:
    """Get all skills for a specific executor type."""
    return [s for s in _REGISTRY.values() if s.executor_type == executor_type]


def clear_registry() -> None:
    """Clear the registry (useful for testing)."""
    _REGISTRY.clear()



================================================
FILE: backend/src/skills/camera/__init__.py
================================================
"""Camera skills for vision and streaming operations."""

from .start_streaming import StartStreamingSkill
from .stop_streaming import StopStreamingSkill
from .get_bounding_box import GetBoundingBoxSkill
from .get_label import GetLabelSkill

__all__ = [
    "StartStreamingSkill",
    "StopStreamingSkill",
    "GetBoundingBoxSkill",
    "GetLabelSkill",
]



================================================
FILE: backend/src/skills/camera/get_bounding_box.py
================================================
"""GetBoundingBox skill for YOLO object detection."""

from typing import Optional

from pydantic import BaseModel, Field

from ..base import ExecutionContext, Skill, SkillResult
from ..registry import register_skill


class GetBoundingBoxParams(BaseModel):
    """Parameters for the get_bounding_box skill."""

    object_class: str = Field(
        ...,
        min_length=1,
        description="Object class to detect (e.g., 'bottle', 'person', 'cup')",
    )
    confidence_threshold: float = Field(
        default=0.5,
        ge=0.0,
        le=1.0,
        description="Minimum confidence threshold for detection",
    )


@register_skill
class GetBoundingBoxSkill(Skill[GetBoundingBoxParams]):
    """Detect objects using YOLOv8 and return bounding boxes."""

    name = "get_bounding_box"
    executor_type = "camera"
    description = "Run YOLO object detection and return bounding box for specified class"

    @classmethod
    def params_schema(cls) -> type[BaseModel]:
        return GetBoundingBoxParams

    async def validate(self, params: GetBoundingBoxParams) -> tuple[bool, Optional[str]]:
        return True, None

    async def execute(
        self, params: GetBoundingBoxParams, context: ExecutionContext
    ) -> SkillResult:
        camera_executor = context.get_executor("camera")

        if not camera_executor.is_ready():
            return SkillResult.fail("Camera not connected")

        detections = await camera_executor.detect_objects(
            class_name=params.object_class,
            confidence_threshold=params.confidence_threshold,
        )

        if not detections:
            return SkillResult.ok({
                "found": False,
                "bbox": None,
                "confidence": 0.0,
                "object_class": params.object_class,
            })

        # Return the first (highest confidence) detection
        best = detections[0]
        return SkillResult.ok({
            "found": True,
            "bbox": {
                "x": best.x,
                "y": best.y,
                "width": best.width,
                "height": best.height,
            },
            "confidence": best.confidence,
            "object_class": best.class_name,
            "total_detections": len(detections),
        })



================================================
FILE: backend/src/skills/camera/get_label.py
================================================
"""GetLabel skill for GPT-4V OCR / label reading."""

from typing import Optional

from pydantic import BaseModel, Field

from ..base import ExecutionContext, Skill, SkillResult
from ..registry import register_skill


class GetLabelParams(BaseModel):
    """Parameters for the get_label skill."""

    prompt: str = Field(
        default="Read any text visible in the image and return it exactly as written.",
        min_length=1,
        description="Instruction prompt for GPT-4V (what to read/extract)",
    )
    use_bbox: bool = Field(
        default=True,
        description="If True, crop to last detected bounding box before sending to GPT-4V",
    )
    crop_margin: float = Field(
        default=0.1,
        ge=0.0,
        le=0.5,
        description="Margin around bbox as fraction of bbox size (only if use_bbox=True)",
    )


@register_skill
class GetLabelSkill(Skill[GetLabelParams]):
    """Read text/labels from image using GPT-4V (OpenAI Vision)."""

    name = "get_label"
    executor_type = "camera"
    description = "Use GPT-4V to read text or labels from the camera image"

    @classmethod
    def params_schema(cls) -> type[BaseModel]:
        return GetLabelParams

    async def validate(self, params: GetLabelParams) -> tuple[bool, Optional[str]]:
        return True, None

    async def execute(
        self, params: GetLabelParams, context: ExecutionContext
    ) -> SkillResult:

        camera_executor = context.get_executor("camera")

        if not camera_executor.is_ready():
            return SkillResult.fail("Camera not connected")

        # Check if we have a bbox to crop to (if requested)
        if params.use_bbox and camera_executor.get_last_bbox() is None:
            return SkillResult.fail(
                "use_bbox=True but no previous detection available. "
                "Run get_bounding_box first or set use_bbox=False."
            )

        result = await camera_executor.read_label(
            prompt=params.prompt,
            use_bbox=params.use_bbox,
            crop_margin=params.crop_margin,
        )

        if result["success"]:
            return SkillResult.ok({
                "label": result["label"],
                "used_bbox": params.use_bbox and camera_executor.get_last_bbox() is not None,
            })
        else:
            return SkillResult.fail(
                result.get("error", "Failed to read label"),
                {"label": ""},
            )



================================================
FILE: backend/src/skills/camera/start_streaming.py
================================================
"""StartStreaming skill for starting WebSocket camera frame broadcast."""

from typing import Optional

from pydantic import BaseModel, Field

from ..base import ExecutionContext, Skill, SkillResult
from ..registry import register_skill


class StartStreamingParams(BaseModel):
    """Parameters for the start_streaming skill."""

    fps: int = Field(
        default=15,
        ge=1,
        le=30,
        description="Target frames per second for streaming",
    )


@register_skill
class StartStreamingSkill(Skill[StartStreamingParams]):
    """Start streaming camera frames over WebSocket."""

    name = "start_streaming"
    executor_type = "camera"
    description = "Start streaming camera frames over WebSocket at specified FPS"

    @classmethod
    def params_schema(cls) -> type[BaseModel]:
        return StartStreamingParams

    async def validate(self, params: StartStreamingParams) -> tuple[bool, Optional[str]]:
        return True, None

    async def execute(
        self, params: StartStreamingParams, context: ExecutionContext
    ) -> SkillResult:
        camera_executor = context.get_executor("camera")

        if not camera_executor.is_ready():
            return SkillResult.fail("Camera not connected")

        started = await camera_executor.start_streaming(fps=params.fps)

        if started:
            return SkillResult.ok({"streaming": True, "fps": params.fps})
        else:
            return SkillResult.fail(
                "Streaming already active",
                {"streaming": True, "fps": params.fps},
            )



================================================
FILE: backend/src/skills/camera/stop_streaming.py
================================================
"""StopStreaming skill for stopping WebSocket camera frame broadcast."""

from typing import Optional

from pydantic import BaseModel

from ..base import ExecutionContext, Skill, SkillResult
from ..registry import register_skill


class StopStreamingParams(BaseModel):
    """Parameters for the stop_streaming skill (none required)."""

    pass


@register_skill
class StopStreamingSkill(Skill[StopStreamingParams]):
    """Stop streaming camera frames over WebSocket."""

    name = "stop_streaming"
    executor_type = "camera"
    description = "Stop streaming camera frames over WebSocket"

    @classmethod
    def params_schema(cls) -> type[BaseModel]:
        return StopStreamingParams

    async def validate(self, params: StopStreamingParams) -> tuple[bool, Optional[str]]:
        return True, None

    async def execute(
        self, params: StopStreamingParams, context: ExecutionContext
    ) -> SkillResult:
        camera_executor = context.get_executor("camera")

        stopped = await camera_executor.stop_streaming()

        if stopped:
            return SkillResult.ok({"streaming": False})
        else:
            return SkillResult.ok(
                {"streaming": False, "message": "Streaming was not active"}
            )



================================================
FILE: backend/src/skills/hand/__init__.py
================================================
"""Hand skills for COVVI prosthetic hand control."""

from .set_grip import SetGripSkill
from .set_finger_positions import SetFingerPositionsSkill
from .grip_until_contact import GripUntilContactSkill

__all__ = ["SetGripSkill", "SetFingerPositionsSkill", "GripUntilContactSkill"]



================================================
FILE: backend/src/skills/hand/grip_until_contact.py
================================================
"""GripUntilContact skill — close fingers until stall-based contact is detected."""

from typing import Literal, Optional

from pydantic import BaseModel, Field

from ..base import ExecutionContext, Skill, SkillResult
from ..registry import register_skill

FingerName = Literal["thumb", "index", "middle", "little"]


class GripUntilContactParams(BaseModel):
    """Parameters for the grip_until_contact skill."""

    speed: int = Field(
        default=25,
        ge=15,
        le=100,
        description="Closing speed (lower = gentler contact, recommended: 20-30)",
    )
    fingers: list[FingerName] = Field(
        default=["thumb", "index", "middle", "little"],
        description="Which fingers to close (ring/rotate excluded — no stall detection)",
    )
    min_contacts: int = Field(
        default=2,
        ge=1,
        le=4,
        description="Minimum number of fingers that must stall to count as a successful grip",
    )
    timeout_s: float = Field(
        default=5.0,
        ge=0.1,
        le=30.0,
        description="Max time to wait for contact before releasing fingers",
    )


@register_skill
class GripUntilContactSkill(Skill[GripUntilContactParams]):
    """Close fingers until stall-based contact is detected."""

    name = "grip_until_contact"
    executor_type = "hand"
    description = (
        "Close COVVI hand fingers at low speed until stall-based contact is detected. "
        "Holds grip on contact; releases and returns contacted=false on timeout."
    )

    @classmethod
    def params_schema(cls) -> type[BaseModel]:
        return GripUntilContactParams

    async def validate(
        self, params: GripUntilContactParams
    ) -> tuple[bool, Optional[str]]:
        if not params.fingers:
            return False, "At least one finger must be specified"
        if params.min_contacts > len(params.fingers):
            return (
                False,
                f"min_contacts ({params.min_contacts}) cannot exceed "
                f"number of fingers ({len(params.fingers)})",
            )
        return True, None

    async def execute(
        self, params: GripUntilContactParams, context: ExecutionContext
    ) -> SkillResult:
        hand_executor = context.get_executor()

        if not hand_executor.is_ready():
            return SkillResult.fail("COVVI hand not connected")

        try:
            result = await hand_executor.grip_until_contact(
                speed=params.speed,
                fingers=params.fingers,
                min_contacts=params.min_contacts,
                timeout_s=params.timeout_s,
            )
            return SkillResult.ok(result)
        except Exception as e:
            return SkillResult.fail(f"grip_until_contact failed: {e}")



================================================
FILE: backend/src/skills/hand/set_finger_positions.py
================================================
"""SetFingerPositions skill for individual finger control on the COVVI hand."""

from typing import Optional

from pydantic import BaseModel, Field

from ..base import ExecutionContext, Skill, SkillResult
from ..registry import register_skill


class SetFingerPositionsParams(BaseModel):
    """Parameters for the set_finger_positions skill."""

    speed: int = Field(
        default=50,
        ge=15,
        le=100,
        description="Movement speed (15=minimum firmware speed, 100=maximum)",
    )
    thumb: Optional[int] = Field(
        default=None,
        ge=0,
        le=100,
        description="Thumb position (0=open, 100=closed). Omit to leave unchanged.",
    )
    index: Optional[int] = Field(
        default=None,
        ge=0,
        le=100,
        description="Index finger position (0=open, 100=closed). Omit to leave unchanged.",
    )
    middle: Optional[int] = Field(
        default=None,
        ge=0,
        le=100,
        description="Middle finger position (0=open, 100=closed). Omit to leave unchanged.",
    )
    ring: Optional[int] = Field(
        default=None,
        ge=0,
        le=100,
        description="Ring finger position (0=open, 100=closed). Omit to leave unchanged.",
    )
    little: Optional[int] = Field(
        default=None,
        ge=0,
        le=100,
        description="Little finger position (0=open, 100=closed). Omit to leave unchanged.",
    )
    rotate: Optional[int] = Field(
        default=None,
        ge=0,
        le=100,
        description="Wrist rotation position (0=open, 100=closed). Omit to leave unchanged.",
    )


@register_skill
class SetFingerPositionsSkill(Skill[SetFingerPositionsParams]):
    """Set individual finger positions on the COVVI prosthetic hand."""

    name = "set_finger_positions"
    executor_type = "hand"
    description = (
        "Set individual COVVI hand finger positions (0=open, 100=closed). "
        "Only specified fingers move; others stay in place."
    )

    @classmethod
    def params_schema(cls) -> type[BaseModel]:
        return SetFingerPositionsParams

    async def validate(
        self, params: SetFingerPositionsParams
    ) -> tuple[bool, Optional[str]]:
        fingers = {
            k: v
            for k, v in {
                "thumb": params.thumb,
                "index": params.index,
                "middle": params.middle,
                "ring": params.ring,
                "little": params.little,
                "rotate": params.rotate,
            }.items()
            if v is not None
        }
        if not fingers:
            return False, "At least one finger position must be specified"
        return True, None

    async def execute(
        self, params: SetFingerPositionsParams, context: ExecutionContext
    ) -> SkillResult:
        hand_executor = context.get_executor()

        if not hand_executor.is_ready():
            return SkillResult.fail("COVVI hand not connected")

        # Only pass fingers that were explicitly set
        fingers = {
            k: v
            for k, v in {
                "thumb": params.thumb,
                "index": params.index,
                "middle": params.middle,
                "ring": params.ring,
                "little": params.little,
                "rotate": params.rotate,
            }.items()
            if v is not None
        }

        try:
            await hand_executor.set_finger_positions(params.speed, **fingers)
            return SkillResult.ok({"speed": params.speed, "fingers": fingers})
        except Exception as e:
            return SkillResult.fail(
                f"Failed to set finger positions: {e}",
                {"speed": params.speed, "fingers": fingers},
            )



================================================
FILE: backend/src/skills/hand/set_grip.py
================================================
"""SetGrip skill for selecting a predefined COVVI hand grip."""

from typing import Literal, Optional

from pydantic import BaseModel, Field

from ..base import ExecutionContext, Skill, SkillResult
from ..registry import register_skill

GripName = Literal[
    "POWER",
    "TRIPOD",
    "TRIPOD_OPEN",
    "PREC_OPEN",
    "PREC_CLOSED",
    "TRIGGER",
    "KEY",
    "FINGER",
    "CYLINDER",
    "COLUMN",
    "RELAXED",
    "GLOVE",
    "TAP",
    "GRAB",
]


class SetGripParams(BaseModel):
    """Parameters for the set_grip skill."""

    grip: GripName = Field(
        ...,
        description="Predefined grip name to activate",
    )


@register_skill
class SetGripSkill(Skill[SetGripParams]):
    """Activate a predefined grip on the COVVI prosthetic hand."""

    name = "set_grip"
    executor_type = "hand"
    description = "Set the COVVI hand to a predefined grip position"

    @classmethod
    def params_schema(cls) -> type[BaseModel]:
        return SetGripParams

    async def validate(self, params: SetGripParams) -> tuple[bool, Optional[str]]:
        return True, None

    async def execute(
        self, params: SetGripParams, context: ExecutionContext
    ) -> SkillResult:
        hand_executor = context.get_executor()

        if not hand_executor.is_ready():
            return SkillResult.fail("COVVI hand not connected")

        try:
            await hand_executor.set_grip(params.grip)
            return SkillResult.ok({"grip": params.grip})
        except Exception as e:
            return SkillResult.fail(
                f"Failed to set grip: {e}",
                {"grip": params.grip},
            )



================================================
FILE: backend/src/skills/io/__init__.py
================================================
"""I/O skills for digital input/output control."""

from .wait_digital_input import WaitDigitalInputSkill
from .set_digital_output import IOSetDigitalOutputSkill

__all__ = ["WaitDigitalInputSkill", "IOSetDigitalOutputSkill"]



================================================
FILE: backend/src/skills/io/set_digital_output.py
================================================
"""SetDigitalOutput skill (I/O executor version)."""

from typing import Optional

from pydantic import BaseModel, Field

from ..base import ExecutionContext, Skill, SkillResult
from ..registry import register_skill


class IOSetDigitalOutputParams(BaseModel):
    """Parameters for the io_set_digital_output skill."""

    pin: int = Field(
        ...,
        ge=0,
        le=7,
        description="Digital output pin number (0-7)",
    )
    value: bool = Field(
        ...,
        description="Output value (true=HIGH, false=LOW)",
    )


@register_skill
class IOSetDigitalOutputSkill(Skill[IOSetDigitalOutputParams]):
    """Set a digital output pin via I/O executor."""

    name = "io_set_digital_output"
    executor_type = "io_robot"
    description = "Set a digital output pin to HIGH or LOW (via I/O executor)"

    @classmethod
    def params_schema(cls) -> type[BaseModel]:
        return IOSetDigitalOutputParams

    async def validate(
        self, params: IOSetDigitalOutputParams
    ) -> tuple[bool, Optional[str]]:
        return True, None

    async def execute(
        self, params: IOSetDigitalOutputParams, context: ExecutionContext
    ) -> SkillResult:
        io_executor = context.get_executor()

        try:
            await io_executor.set_digital_output(params.pin, params.value)
            return SkillResult.ok({"pin": params.pin, "value": params.value})
        except Exception as e:
            return SkillResult.fail(
                f"Failed to set digital output: {e}",
                {"pin": params.pin, "value": params.value},
            )



================================================
FILE: backend/src/skills/io/wait_digital_input.py
================================================
"""WaitDigitalInput skill for waiting on digital input state."""

import asyncio
from typing import Optional

from pydantic import BaseModel, Field

from ..base import ExecutionContext, Skill, SkillResult
from ..registry import register_skill


class WaitDigitalInputParams(BaseModel):
    """Parameters for the wait_digital_input skill."""

    pin: int = Field(
        ...,
        ge=0,
        le=7,
        description="Digital input pin number (0-7)",
    )
    expected_value: bool = Field(
        ...,
        description="Expected value to wait for (true=HIGH, false=LOW)",
    )
    poll_interval_ms: int = Field(
        default=100,
        ge=10,
        le=1000,
        description="Polling interval in milliseconds",
    )


@register_skill
class WaitDigitalInputSkill(Skill[WaitDigitalInputParams]):
    """Wait for a digital input pin to reach a specific state."""

    name = "wait_digital_input"
    executor_type = "io_robot"
    description = "Wait for a digital input to become HIGH or LOW"

    @classmethod
    def params_schema(cls) -> type[BaseModel]:
        return WaitDigitalInputParams

    async def validate(
        self, params: WaitDigitalInputParams
    ) -> tuple[bool, Optional[str]]:
        return True, None

    async def execute(
        self, params: WaitDigitalInputParams, context: ExecutionContext
    ) -> SkillResult:
        io_executor = context.get_executor()
        poll_interval_s = params.poll_interval_ms / 1000.0

        # Note: Timeout is handled by the FlowExecutor at the step level
        while True:
            current_value = await io_executor.get_digital_input(params.pin)

            if current_value is None:
                return SkillResult.fail(
                    f"Digital input pin {params.pin} not available",
                    {"pin": params.pin},
                )

            if current_value == params.expected_value:
                return SkillResult.ok(
                    {
                        "pin": params.pin,
                        "expected_value": params.expected_value,
                        "matched": True,
                    }
                )

            await asyncio.sleep(poll_interval_s)



================================================
FILE: backend/src/skills/robot/__init__.py
================================================
"""Robot skills for UR robot control."""

from .move_joint import MoveJointSkill
from .move_linear import MoveLinearSkill
from .palletize import PalletizeSkill
from .set_tool_output import SetToolOutputSkill

__all__ = ["MoveJointSkill", "MoveLinearSkill", "PalletizeSkill", "SetToolOutputSkill"]



================================================
FILE: backend/src/skills/robot/move_joint.py
================================================
"""MoveJoint skill for moving the robot to target joint positions."""

import math
from typing import Optional

from pydantic import BaseModel, Field

from ..base import ExecutionContext, Skill, SkillResult
from ..registry import register_skill


class MoveJointParams(BaseModel):
    """Parameters for the move_joint skill."""

    target_joints_deg: list[float] = Field(
        ...,
        min_length=6,
        max_length=6,
        description="Target joint positions in degrees [j0, j1, j2, j3, j4, j5]",
    )
    acceleration: float = Field(
        default=2.0,
        ge=0.1,
        le=2.0,
        description="Joint acceleration in rad/s²",
    )
    velocity: float = Field(
        default=2.0,
        ge=0.1,
        le=2.0,
        description="Joint velocity in rad/s",
    )
    tolerance_deg: float = Field(
        default=1.0,
        ge=0.1,
        le=10.0,
        description="Position tolerance in degrees to consider motion complete",
    )


@register_skill
class MoveJointSkill(Skill[MoveJointParams]):
    """Move robot to target joint positions using movej command."""

    name = "move_joint"
    executor_type = "robot"
    description = "Move robot joints to specified positions in degrees"

    @classmethod
    def params_schema(cls) -> type[BaseModel]:
        return MoveJointParams

    async def validate(self, params: MoveJointParams) -> tuple[bool, Optional[str]]:
        # Validate joint limits (UR3 typical limits)
        joint_limits_deg = [
            (-360, 360),  # Base
            (-360, 360),  # Shoulder
            (-360, 360),  # Elbow
            (-360, 360),  # Wrist 1
            (-360, 360),  # Wrist 2
            (-360, 360),  # Wrist 3
        ]

        for i, (joint_deg, (min_deg, max_deg)) in enumerate(
            zip(params.target_joints_deg, joint_limits_deg)
        ):
            if not min_deg <= joint_deg <= max_deg:
                return False, f"Joint {i} ({joint_deg}°) outside limits [{min_deg}, {max_deg}]"

        return True, None

    async def execute(
        self, params: MoveJointParams, context: ExecutionContext
    ) -> SkillResult:
        robot_executor = context.get_executor("robot")

        # Convert degrees to radians
        target_rad = [math.radians(deg) for deg in params.target_joints_deg]

        # Execute the move
        success = await robot_executor.move_joint(
            target_rad=target_rad,
            acceleration=params.acceleration,
            velocity=params.velocity,
            tolerance_rad=math.radians(params.tolerance_deg),
        )

        if success:
            return SkillResult.ok(
                {"target_joints_deg": params.target_joints_deg, "reached": True}
            )
        else:
            return SkillResult.fail(
                "Failed to reach target position",
                {"target_joints_deg": params.target_joints_deg, "reached": False},
            )



================================================
FILE: backend/src/skills/robot/move_linear.py
================================================
"""MoveLinear skill for moving the robot in a straight line to a Cartesian pose."""

from typing import Optional

from pydantic import BaseModel, Field

from ..base import ExecutionContext, Skill, SkillResult
from ..registry import register_skill


class MoveLinearParams(BaseModel):
    """Parameters for the move_linear skill."""

    target_pose: list[float] = Field(
        ...,
        min_length=6,
        max_length=6,
        description="Target pose [x, y, z, rx, ry, rz] in meters and radians",
    )
    z_offset: float = Field(
        default=0.0,
        description="Vertical offset added to Z component before execution (meters). Positive = up.",
    )
    acceleration: float = Field(
        default=1.2,
        ge=0.01,
        le=3.0,
        description="Tool acceleration in m/s²",
    )
    velocity: float = Field(
        default=0.8,
        ge=0.01,
        le=1.0,
        description="Tool velocity in m/s",
    )


@register_skill
class MoveLinearSkill(Skill[MoveLinearParams]):
    """Move robot TCP in a straight line to a Cartesian pose using movel command."""

    name = "move_linear"
    executor_type = "robot"
    description = "Move robot TCP linearly to a Cartesian pose [x, y, z, rx, ry, rz]"

    @classmethod
    def params_schema(cls) -> type[BaseModel]:
        return MoveLinearParams

    async def validate(self, params: MoveLinearParams) -> tuple[bool, Optional[str]]:
        return True, None

    async def execute(
        self, params: MoveLinearParams, context: ExecutionContext
    ) -> SkillResult:
        robot_executor = context.get_executor("robot")

        # Apply z_offset to Z component
        pose = list(params.target_pose)
        pose[2] += params.z_offset

        success = await robot_executor.move_linear(
            pose=pose,
            acceleration=params.acceleration,
            velocity=params.velocity,
        )

        if success:
            return SkillResult.ok({
                "target_pose": params.target_pose,
                "z_offset": params.z_offset,
            })
        else:
            return SkillResult.fail(
                "Failed to reach target pose",
                {"target_pose": params.target_pose, "z_offset": params.z_offset},
            )



================================================
FILE: backend/src/skills/robot/palletize.py
================================================
"""Palletize skill — move_linear with automatic position popping from a list."""

import logging
from typing import Optional

from pydantic import BaseModel, Field

from ..base import ExecutionContext, Skill, SkillResult
from ..registry import register_skill

logger = logging.getLogger(__name__)


class PalletizeParams(BaseModel):
    """Parameters for the palletize skill."""

    positions_var: str = Field(
        ...,
        description="Name of the flow variable holding the positions map (e.g. 'place_positions')",
    )
    key: str = Field(
        ...,
        description="Zone key to look up in the positions map (e.g. 'product_A')",
    )
    default_key: str = Field(
        default="default",
        description="Fallback key if the zone key is not found in the map",
    )
    z_offset: float = Field(
        default=0.0,
        description="Vertical offset added to Z component before execution (meters). Positive = up.",
    )
    acceleration: float = Field(
        default=1.2,
        ge=0.01,
        le=3.0,
        description="Tool acceleration in m/s²",
    )
    velocity: float = Field(
        default=0.8,
        ge=0.01,
        le=1.0,
        description="Tool velocity in m/s",
    )


@register_skill
class PalletizeSkill(Skill[PalletizeParams]):
    """Move robot to the next position from a palletizing list, popping it after use."""

    name = "palletize"
    executor_type = "robot"
    description = "Move to next pallet position from a list, removing it for the next cycle"

    @classmethod
    def params_schema(cls) -> type[BaseModel]:
        return PalletizeParams

    async def validate(self, params: PalletizeParams) -> tuple[bool, Optional[str]]:
        return True, None

    @staticmethod
    def _normalize_key(key: str) -> str:
        """Normalize a zone key: strip, lowercase, collapse whitespace to underscore."""
        return "_".join(key.strip().lower().split())

    def _find_key(self, positions_map: dict, raw_key: str, default_key: str) -> str:
        """Find the best matching key in positions_map, with fuzzy normalization."""
        # Exact match first
        if raw_key in positions_map:
            return raw_key

        # Normalized match: compare normalized forms of all keys
        norm = self._normalize_key(raw_key)
        for map_key in positions_map:
            if map_key == default_key:
                continue
            if self._normalize_key(map_key) == norm:
                logger.info(f"Palletize: fuzzy matched key '{raw_key}' -> '{map_key}'")
                return map_key

        # Nothing matched — fall back to default
        logger.warning(
            f"Palletize: key '{raw_key}' (norm='{norm}') not found in "
            f"{list(positions_map.keys())}, using default '{default_key}'"
        )
        return default_key

    async def execute(
        self, params: PalletizeParams, context: ExecutionContext
    ) -> SkillResult:
        # Look up the positions map from flow variables
        positions_map = context.get_variable(params.positions_var)
        if not isinstance(positions_map, dict):
            return SkillResult.fail(
                f"Variable '{params.positions_var}' is not a dict",
                {"positions_var": params.positions_var},
            )

        # Find the best matching key (handles GPT label variations)
        matched_key = self._find_key(positions_map, params.key, params.default_key)
        positions_list = positions_map.get(matched_key)
        if not isinstance(positions_list, list) or len(positions_list) == 0:
            return SkillResult.fail(
                "positions_exhausted",
                {"positions_var": params.positions_var, "key": params.key,
                 "matched_key": matched_key, "remaining": 0},
            )

        # Pop the first position (mutates the list in-place)
        original_pose = list(positions_list.pop(0))
        remaining = len(positions_list)
        logger.info(
            f"Palletize: key='{params.key}' matched='{matched_key}' "
            f"-> {original_pose} ({remaining} remaining)"
        )

        # Apply z_offset to Z component for the actual move
        move_pose = list(original_pose)
        move_pose[2] += params.z_offset

        # Execute move_linear
        robot_executor = context.get_executor("robot")
        success = await robot_executor.move_linear(
            pose=move_pose,
            acceleration=params.acceleration,
            velocity=params.velocity,
        )

        if success:
            return SkillResult.ok({
                "target_pose": original_pose,
                "z_offset": params.z_offset,
                "remaining": remaining,
            })
        else:
            return SkillResult.fail(
                "Failed to reach pallet position",
                {"target_pose": original_pose, "z_offset": params.z_offset, "remaining": remaining},
            )



================================================
FILE: backend/src/skills/robot/set_tool_output.py
================================================
"""SetToolOutput skill — controls a tool digital output (DOBOT ToolDO)."""

from typing import Optional

from pydantic import BaseModel, Field

from ..base import ExecutionContext, Skill, SkillResult
from ..registry import register_skill


class SetToolOutputParams(BaseModel):
    """Parameters for the set_tool_output skill."""

    index: int = Field(
        ...,
        ge=1,
        description="ToolDO index (1=close gripper, 2=open gripper on dual-solenoid)",
    )
    status: int = Field(
        default=1,
        ge=0,
        le=1,
        description="Output status (1=activate, 0=deactivate)",
    )


@register_skill
class SetToolOutputSkill(Skill[SetToolOutputParams]):
    """Activate or deactivate a tool digital output via the robot executor."""

    name = "set_tool_output"
    executor_type = "robot"
    description = "Control a DOBOT tool digital output (e.g. pneumatic gripper via ToolDO)"

    @classmethod
    def params_schema(cls) -> type[BaseModel]:
        return SetToolOutputParams

    async def validate(
        self, params: SetToolOutputParams
    ) -> tuple[bool, Optional[str]]:
        return True, None

    async def execute(
        self, params: SetToolOutputParams, context: ExecutionContext
    ) -> SkillResult:
        robot_executor = context.get_executor("robot")

        try:
            success = await robot_executor.set_tool_output(params.index, params.status)
            if success:
                return SkillResult.ok({"index": params.index, "status": params.status})
            return SkillResult.fail(
                f"ToolDO(index={params.index}, status={params.status}) returned error",
                {"index": params.index, "status": params.status},
            )
        except Exception as e:
            return SkillResult.fail(
                f"set_tool_output failed: {e}",
                {"index": params.index, "status": params.status},
            )



================================================
FILE: flows/pick_and_place_v1.json
================================================
{
  "id": "pick_and_place_v1",
  "name": "Basic Pick and Place",
  "initial_state": "start_midair",
  "variables": {
    "place_positions": {
      "product_A": [-58.50, -103.66, -75.31, -90.16, 89.94, 118.72],
      "product_B": [-45.00, -110.00, -70.00, -85.00, 89.94, 118.72],
      "product_C": [-70.00, -100.00, -65.00, -95.00, 89.94, 118.72],
      "default": [-58.50, -103.66, -75.31, -90.16, 89.94, 118.72]
    }
  },
  "states": [
    {
      "name": "start_midair",
      "steps": [
        {
          "id": "go_midair_1",
          "skill": "move_joint",
          "executor": "robot",
          "params": {
            "target_joints_deg": [-122.69, -109.26, -44.24, -112.69, 89.94, 118.72]
          },
          "error_handling": {
            "strategy": "retry",
            "max_retries": 2
          },
          "timeout_ms": 30000
        }
      ]
    },
    {
      "name": "labelling_analysis",
      "steps": [
        {
          "id": "wait_machine_ready",
          "skill": "wait_digital_input",
          "executor": "io_machine",
          "params": {
            "pin": 0,
            "expected_value": true
          },
          "timeout_ms": 60000
        },
        {
          "id": "read_label",
          "skill": "get_label",
          "executor": "camera",
          "params": {
            "prompt": "Read the product label. Return only the product code (e.g., product_A, product_B, product_C).",
            "use_bbox": false
          },
          "store_result": "label_data",
          "timeout_ms": 30000
        }
      ]
    },
    {
      "name": "pick",
      "steps": [
        {
          "id": "wait_di4",
          "skill": "wait_digital_input",
          "executor": "io_robot",
          "params": {
            "pin": 4,
            "expected_value": true
          },
          "timeout_ms": 60000
        },
        {
          "id": "move_to_pick",
          "skill": "move_joint",
          "executor": "robot",
          "params": {
            "target_joints_deg": [-141.27, -129.96, -80.55, -59.00, 88.25, 118.72]
          },
          "timeout_ms": 30000
        },
        {
          "id": "vacuum_on",
          "skill": "io_set_digital_output",
          "executor": "io_robot",
          "params": {
            "pin": 0,
            "value": true
          },
          "timeout_ms": 5000
        }
      ]
    },
    {
      "name": "return_midair",
      "steps": [
        {
          "id": "go_midair_2",
          "skill": "move_joint",
          "executor": "robot",
          "params": {
            "target_joints_deg": [-122.69, -109.26, -44.24, -112.69, 89.94, 118.72]
          },
          "timeout_ms": 30000
        }
      ]
    },
    {
      "name": "place",
      "steps": [
        {
          "id": "move_to_place",
          "skill": "move_joint",
          "executor": "robot",
          "params": {
            "target_joints_deg": "{{lookup:place_positions:label_data.label:default}}"
          },
          "timeout_ms": 30000
        },
        {
          "id": "vacuum_off",
          "skill": "io_set_digital_output",
          "executor": "io_robot",
          "params": {
            "pin": 0,
            "value": false
          },
          "timeout_ms": 5000
        }
      ]
    },
    {
      "name": "end_midair",
      "steps": [
        {
          "id": "go_midair_3",
          "skill": "move_joint",
          "executor": "robot",
          "params": {
            "target_joints_deg": [-122.69, -109.26, -44.24, -112.69, 89.94, 118.72]
          },
          "timeout_ms": 30000
        }
      ]
    }
  ],
  "transitions": [
    {
      "type": "sequential",
      "from_state": "start_midair",
      "to_state": "labelling_analysis"
    },
    {
      "type": "sequential",
      "from_state": "labelling_analysis",
      "to_state": "pick"
    },
    {
      "type": "sequential",
      "from_state": "pick",
      "to_state": "return_midair"
    },
    {
      "type": "sequential",
      "from_state": "return_midair",
      "to_state": "place"
    },
    {
      "type": "sequential",
      "from_state": "place",
      "to_state": "end_midair"
    }
  ]
}



================================================
FILE: flows/pick_and_place_v2.json
================================================
{
  "id": "pick_and_place_v2",
  "name": "Pick and Place with Conditional Routing",
  "initial_state": "start_midair",
  "loop": true,
  "variables": {
    "place_positions": {
      "product_A": [-58.50, -103.66, -75.31, -90.16, 89.94, 118.72],
      "product_B": [-45.00, -110.00, -70.00, -85.00, 89.94, 118.72],
      "product_C": [-70.00, -100.00, -65.00, -95.00, 89.94, 118.72],
      "default": [-58.50, -103.66, -75.31, -90.16, 89.94, 118.72]
    }
  },
  "states": [
    {
      "name": "start_midair",
      "steps": [
        {
          "id": "go_midair_1",
          "skill": "move_joint",
          "executor": "robot",
          "params": {
            "target_joints_deg": [-122.69, -109.26, -44.24, -112.69, 89.94, 118.72]
          },
          "timeout_ms": 30000
        }
      ]
    },
    {
      "name": "labelling_analysis",
      "steps": [
        {
          "id": "wait_machine_ready",
          "skill": "wait_digital_input",
          "executor": "io_machine",
          "params": {
            "pin": 0,
            "expected_value": true
          },
          "timeout_ms": 60000
        },
        {
          "id": "read_label",
          "skill": "get_label",
          "executor": "camera",
          "params": {
            "prompt": "Read the product label. Return only the product code (e.g., product_A, product_B, product_C).",
            "use_bbox": false
          },
          "store_result": "label_data",
          "error_handling": {
            "strategy": "skip",
            "max_retries": 1
          },
          "timeout_ms": 10000
        }
      ]
    },
    {
      "name": "pick",
      "steps": [
        {
          "id": "wait_di4",
          "skill": "wait_digital_input",
          "executor": "io_robot",
          "params": {
            "pin": 4,
            "expected_value": true
          },
          "timeout_ms": 60000
        },
        {
          "id": "move_to_pick",
          "skill": "move_joint",
          "executor": "robot",
          "params": {
            "target_joints_deg": [-141.27, -129.96, -80.55, -59.00, 88.25, 118.72]
          },
          "timeout_ms": 30000
        },
        {
          "id": "vacuum_on",
          "skill": "io_set_digital_output",
          "executor": "io_robot",
          "params": {
            "pin": 0,
            "value": true
          },
          "timeout_ms": 5000
        }
      ]
    },
    {
      "name": "return_midair",
      "steps": [
        {
          "id": "go_midair_2",
          "skill": "move_joint",
          "executor": "robot",
          "params": {
            "target_joints_deg": [-122.69, -109.26, -44.24, -112.69, 89.94, 118.72]
          },
          "timeout_ms": 30000
        }
      ]
    },
    {
      "name": "place",
      "steps": [
        {
          "id": "move_to_place",
          "skill": "move_joint",
          "executor": "robot",
          "params": {
            "target_joints_deg": "{{lookup:place_positions:label_data.label:default}}"
          },
          "timeout_ms": 30000
        },
        {
          "id": "vacuum_off",
          "skill": "io_set_digital_output",
          "executor": "io_robot",
          "params": {
            "pin": 0,
            "value": false
          },
          "timeout_ms": 5000
        }
      ]
    },
    {
      "name": "end_midair",
      "steps": [
        {
          "id": "go_midair_3",
          "skill": "move_joint",
          "executor": "robot",
          "params": {
            "target_joints_deg": [-122.69, -109.26, -44.24, -112.69, 89.94, 118.72]
          },
          "timeout_ms": 30000
        }
      ]
    }
  ],
  "transitions": [
    {
      "type": "conditional",
      "from_state": "start_midair",
      "to_state": "labelling_analysis",
      "condition": "io_machine.input[0] == true"
    },
    {
      "type": "conditional",
      "from_state": "labelling_analysis",
      "to_state": "pick",
      "condition": "io_robot.input[4] == true"
    },
    {
      "type": "sequential",
      "from_state": "labelling_analysis",
      "to_state": "end_midair"
    },
    {
      "type": "sequential",
      "from_state": "pick",
      "to_state": "return_midair"
    },
    {
      "type": "sequential",
      "from_state": "return_midair",
      "to_state": "place"
    },
    {
      "type": "sequential",
      "from_state": "place",
      "to_state": "end_midair"
    }
  ]
}



================================================
FILE: flows/test_label.json
================================================
{
  "id": "test_label",
  "name": "Test Get Label",
  "initial_state": "read_label",
  "variables": {},
  "states": [
    {
      "name": "read_label",
      "steps": [
        {
          "id": "get_label_step",
          "skill": "get_label",
          "executor": "camera",
          "params": {
            "prompt": "Read any text visible in the image. Return the exact text you see.",
            "use_bbox": false
          },
          "store_result": "label_result",
          "timeout_ms": 30000
        }
      ]
    }
  ],
  "transitions": []
}



================================================
FILE: flows/.gitkeep
================================================
[Empty file]


================================================
FILE: frontend/README.md
================================================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```



================================================
FILE: frontend/components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}



================================================
FILE: frontend/Dockerfile
================================================
# Build
FROM node:20-alpine AS build
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

# Serve
FROM nginx:alpine
COPY nginx.conf /etc/nginx/conf.d/default.conf
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80


================================================
FILE: frontend/eslint.config.js
================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])



================================================
FILE: frontend/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Forgis Robot Control</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



================================================
FILE: frontend/nginx.conf
================================================
server {
    listen 80;

    root /usr/share/nginx/html;
    index index.html;

    # Serve static files
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Proxy API requests to backend
    location /api/ {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Proxy WebSocket
    location /ws {
        proxy_pass http://127.0.0.1:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_read_timeout 86400;
    }
}


================================================
FILE: frontend/package.json
================================================
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@monaco-editor/react": "^4.7.0",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-separator": "^1.1.8",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-tabs": "^1.1.13",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@xyflow/react": "^12.10.1",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.575.0",
    "radix-ui": "^1.4.3",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router-dom": "^7.13.0",
    "recharts": "^3.7.0",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.5.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@tailwindcss/vite": "^4.2.0",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "tailwindcss": "^4.2.0",
    "tw-animate-css": "^1.4.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.48.0",
    "vite": "^7.3.1"
  }
}



================================================
FILE: frontend/tsconfig.app.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,

    /* Path aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}



================================================
FILE: frontend/tsconfig.json
================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



================================================
FILE: frontend/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}



================================================
FILE: frontend/vite.config.ts
================================================
import path from 'path'
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    host: '0.0.0.0',
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      },
      '/ws': {
        target: 'ws://localhost:8000',
        ws: true,
      },
    },
  },
})



================================================
FILE: frontend/.dockerignore
================================================
node_modules
dist
.git


================================================
FILE: frontend/src/App.tsx
================================================
import { RobotControlPage } from "./pages/RobotControlPage";

function App() {
  return <RobotControlPage />;
}

export default App;



================================================
FILE: frontend/src/index.css
================================================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

/* ============================================
   CUSTOM FONTS - Forgis Brand Fonts
   ============================================
   @font-face registers custom font files so the browser
   can download and use them. Without this, only system
   fonts (Arial, Times, etc.) are available.
   ============================================ */

@font-face {
  font-family: 'Forgis Body';
  src: url('/01 - Forgis Body Regular.otf') format('opentype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
  /* Shows fallback font while loading, then swaps */
}

@font-face {
  font-family: 'Forgis Body';
  src: url('/02 - Forgis Body Header.otf') format('opentype');
  font-weight: 700;
  /* Header variant = bold weight */
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Forgis Digit';
  src: url('/04 - Forgis Digit Regular.otf') format('opentype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

/* ============================================
   FORGIS DESIGN SYSTEM - CSS Variables
   ============================================ */

:root {
  /* ── Brand Colors – 3 oranges ── */
  --orange: #FF5A00;
  --tiger: #FF9030;
  --flicker: #FDD358;

  /* ── Core Palette – 8 colors (dark → light) ── */
  --gunmetal: #122128;
  --gunmetal-highlight: #FF9030;
  --gunmetal-50: #889093;
  --gunmetal-10: #DDDFE0;
  --steel: #BDC3C7;
  --cloudy: #E9EEF2;
  --platinum: #F1F5F7;
  --white: #FFFFFF;

  /* ── Extended Palette ── */
  --green: #00dd3b;

  /* ── Semantic – Surfaces ── */
  --panel: var(--white);
  --panel-elevated: var(--cloudy);

  /* ── Semantic – Backgrounds ── */
  --bg-app: var(--white);
  --bg-panel: var(--white);
  --bg-panel-hover: var(--platinum);
  --bg-input: color-mix(in srgb, var(--gunmetal-50) 8%, transparent);

  /* ── Semantic – Text ── */
  --text-primary: var(--gunmetal);
  --text-secondary: var(--gunmetal-highlight);
  --text-muted: var(--gunmetal-50);

  /* ── Borders ── */
  --border-default: var(--gunmetal-10);
  --border-subtle: color-mix(in srgb, var(--gunmetal-50) 20%, transparent);

  /* ── Accent / Interactive ── */
  --accent-hover: var(--orange);
  --accent: var(--accent-hover);
  --critical: var(--orange);

  /* ── Status Colors ── */
  --status-healthy: var(--green);
  --status-warning: var(--flicker);
  --status-critical: var(--orange);
  --status-offline: var(--gunmetal-50);

  /* ── Flow / Node Colors ── */
  --node-header: var(--cloudy);
  --node-glow: color-mix(in srgb, var(--orange) 30%, transparent);
  --handle-bg: var(--gunmetal-10);
  --handle-border: var(--steel);
  --selection-highlight: var(--flicker);

  /* ── Sidebar / Chat Colors ── */
  --sidebar-bg: var(--platinum);
  --chat-user-bg: var(--white);
  --chat-user-border: var(--gunmetal-10);
  --chat-assistant-bg: var(--cloudy);

  /* ── Robot Node Colors (3 concentric circles) ── */
  --robot-ring-bg: var(--gunmetal-10);
  --robot-ring-border: var(--gunmetal-50);
  --robot-middle-bg: var(--gunmetal-highlight);
  --robot-inner-bg: var(--gunmetal-10);

  /* ── Dot Grid Background ── */
  --dot-grid-color: var(--platinum);

  /* ── Vertical Colors ── */
  --vertical-predictive: var(--accent-hover);
  --vertical-quality: var(--tiger);
  --vertical-energy: var(--green);
  --vertical-robot: var(--gunmetal-50);
  --vertical-optimization: var(--flicker);

  /* ── Chart Palette – 8 distinct colors ── */
  --chart-1-orange: var(--orange);
  --chart-2-cyan: var(--green);
  --chart-3-tiger: var(--tiger);
  --chart-4-purple: var(--gunmetal-50);
  --chart-5-flicker: var(--flicker);
  --chart-6-blue: var(--gunmetal);
  --chart-7-green: var(--green);
  --chart-8-pink: var(--steel);

  /* ── Shadows ── */
  --shadow-sm: 0 1px 2px color-mix(in srgb, black 5%, transparent);
  --shadow-md: 0 4px 12px color-mix(in srgb, black 8%, transparent);
  --shadow-lg: 0 8px 24px color-mix(in srgb, black 12%, transparent);

  /* ── Layout ── */
  --sidebar-width: 240px;
  --sidebar-collapsed: 56px;
  --topbar-height: 48px;

  /* ── Typography – Size Scale ── */
  --fs-9:  9px;
  --fs-10: 10px;
  --fs-11: 11px;
  --fs-12: 12px;
  --fs-13: 13px;
  --fs-14: 14px;
  --fs-16: 16px;

  /* ── Typography – Semantic Tokens ── */
  --text-size-micro:   var(--fs-9);   /* timestamps, shot numbers, step indices */
  --text-size-caption: var(--fs-10);  /* status labels, form labels, counters */
  --text-size-detail:  var(--fs-11);  /* subtitles, log entries, form inputs */
  --text-size-label:   var(--fs-12);  /* section headings, buttons, breadcrumbs */
  --text-size-body:    var(--fs-13);  /* chat messages, chat input */
  --text-size-reading: var(--fs-14);  /* node labels, placeholders, logo */
  --text-size-title:   var(--fs-16);  /* panel titles */

  /* ── shadcn/ui variables ── */
  --radius: 0.5rem;
  --background: var(--white);
  --foreground: var(--gunmetal);
  --card: var(--white);
  --card-foreground: var(--gunmetal);
  --popover: var(--white);
  --popover-foreground: var(--gunmetal);
  --primary: var(--accent-hover);
  --primary-foreground: var(--white);
  --secondary: var(--cloudy);
  --secondary-foreground: var(--gunmetal-highlight);
  --muted: var(--cloudy);
  --muted-foreground: var(--gunmetal-50);
  --accent-foreground: var(--white);
  --destructive: var(--orange);
  --destructive-foreground: var(--white);
  --border: var(--border-subtle);
  --input: var(--bg-input);
  --ring: var(--accent-hover);
  --chart-1: var(--vertical-predictive);
  --chart-2: var(--vertical-quality);
  --chart-3: var(--vertical-energy);
  --chart-4: var(--vertical-robot);
  --chart-5: var(--vertical-optimization);
  --sidebar: var(--sidebar-bg);
  --sidebar-foreground: var(--gunmetal);
  --sidebar-primary: var(--accent-hover);
  --sidebar-primary-foreground: var(--white);
  --sidebar-accent: var(--cloudy);
  --sidebar-accent-foreground: var(--gunmetal);
  --sidebar-border: var(--border-subtle);
  --sidebar-ring: var(--accent-hover);
}


/* ============================================
   BASE
   ============================================ */

html,
body,
#root {
  height: 100%;
  width: 100%;
}

body {
  font-family: 'Forgis Body', 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Use Forgis Digit for headings, numbers, labels */
h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: 'Forgis Digit', 'Forgis Body', sans-serif;
}

/* ============================================
   FORGIS FONT UTILITY CLASSES
   Use these classes to apply Forgis fonts consistently
   ============================================ */

.font-forgis-body {
  font-family: 'Forgis Body', 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

.font-forgis-digit {
  font-family: 'Forgis Digit', 'Forgis Body', sans-serif;
}

/* ============================================
   FORGIS TYPOGRAPHY SIZE UTILITIES
   Maps semantic tokens to utility classes.
   Uses @layer utilities for correct specificity.
   ============================================ */

@layer utilities {
  .forgis-text-micro   { font-size: var(--text-size-micro); }
  .forgis-text-caption { font-size: var(--text-size-caption); }
  .forgis-text-detail  { font-size: var(--text-size-detail); }
  .forgis-text-label   { font-size: var(--text-size-label); }
  .forgis-text-body    { font-size: var(--text-size-body); }
  .forgis-text-reading { font-size: var(--text-size-reading); }
  .forgis-text-title   { font-size: var(--text-size-title); }
}

/* ============================================
   SCROLLBARS (browser-specific)
   ============================================ */

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: var(--border-subtle);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--steel);
}

/* ============================================
   THIRD-PARTY: React Resizable Panels
   ============================================ */

.panel-resize-handle {
  background: var(--border-subtle);
  transition: background 150ms ease;
}

.panel-resize-handle:hover,
.panel-resize-handle[data-resize-handle-active] {
  background: var(--accent);
}

.panel-resize-handle-horizontal {
  width: 4px;
  cursor: col-resize;
}

.panel-resize-handle-vertical {
  height: 4px;
  cursor: row-resize;
}

/* ============================================
   SHADCN/UI THEME
   ============================================ */

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }

  body {
    @apply bg-background text-foreground;
  }
}

/* ============================================
   KEYFRAME ANIMATIONS
   Consolidated from all .module.css files
   ============================================ */

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

@keyframes slideDown {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes slideUp {
  from { opacity: 1; transform: translateY(0); }
  to { opacity: 0; transform: translateY(-10px); }
}

@keyframes slideIn {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes scaleIn {
  from { opacity: 0; transform: scale(0.95); }
  to { opacity: 1; transform: scale(1); }
}

@keyframes scaleOut {
  from { opacity: 1; transform: scale(1); }
  to { opacity: 0; transform: scale(0.95); }
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-4px); }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

@keyframes pulse-warning {
  0%, 100% { stroke-width: 2; opacity: 1; }
  50% { stroke-width: 3; opacity: 0.8; }
}

@keyframes pulse-critical {
  0%, 100% { box-shadow: 0 0 0 0 color-mix(in srgb, var(--orange) 40%, transparent); }
  50% { box-shadow: 0 0 0 8px transparent; }
}

@keyframes pulse-root-cause {
  0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 color-mix(in srgb, var(--orange) 40%, transparent); }
  50% { transform: scale(1.02); box-shadow: 0 0 0 10px transparent; }
}

@keyframes pulse-border {
  0%, 100% { box-shadow: 0 0 0 0 var(--accent-hover); }
  50% { box-shadow: 0 0 0 4px transparent; }
}

@keyframes pulse-dot {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

@keyframes expandFullscreen {
  from { opacity: 0; transform: scale(0.95); }
  to { opacity: 1; transform: scale(1); }
}

@keyframes flowDash {
  from { stroke-dashoffset: 20; }
  to { stroke-dashoffset: 0; }
}

@keyframes pulseConnection {
  0%, 100% { stroke-width: 2; opacity: 0.8; }
  50% { stroke-width: 3; opacity: 1; }
}

@keyframes conveyorSlide {
  from { transform: translateX(-100%); }
  to { transform: translateX(300%); }
}

/* ============================================
   ANIMATION UTILITY CLASSES
   ============================================ */

.animate-fade-in {
  animation: fadeIn 200ms ease-out forwards;
}

.animate-fade-out {
  animation: fadeOut 200ms ease-out forwards;
}

.animate-slide-down {
  animation: slideDown 200ms ease-out forwards;
}

.animate-slide-up {
  animation: slideUp 200ms ease-out forwards;
}

.animate-slide-in {
  animation: slideIn 300ms ease-out forwards;
}

.animate-scale-in {
  animation: scaleIn 200ms ease-out forwards;
}

.animate-scale-out {
  animation: scaleOut 200ms ease-out forwards;
}

.animate-spin {
  animation: spin 1s linear infinite;
}

.animate-bounce {
  animation: bounce 1s ease-in-out infinite;
}

.animate-pulse {
  animation: pulse 2s ease-in-out infinite;
}

.animate-pulse-warning {
  animation: pulse-warning 1.5s ease-in-out infinite;
}

.animate-pulse-critical {
  animation: pulse-critical 2s ease-in-out infinite;
}

.animate-pulse-root-cause {
  animation: pulse-root-cause 2s ease-in-out infinite;
}

.animate-pulse-border {
  animation: pulse-border 2s ease-in-out infinite;
}

.animate-pulse-dot {
  animation: pulse-dot 1.5s ease-in-out infinite;
}

.animate-expand-fullscreen {
  animation: expandFullscreen 300ms ease-out forwards;
}

.animate-flow-dash {
  animation: flowDash 1s linear infinite;
}

.animate-pulse-connection {
  animation: pulseConnection 2s ease-in-out infinite;
}

/* ============================================
   GRADIENT UTILITY CLASSES
   ============================================ */

.gradient-brand {
  background: linear-gradient(135deg, var(--primary) 0%, var(--accent-hover) 100%);
}

.gradient-tiger-subtle {
  background: linear-gradient(135deg, color-mix(in srgb, var(--tiger) 10%, transparent) 0%, transparent 100%);
}

.gradient-warning-subtle {
  background: linear-gradient(135deg, color-mix(in srgb, var(--flicker) 8%, transparent) 0%, transparent 100%);
}

.gradient-critical-subtle {
  background: linear-gradient(135deg, color-mix(in srgb, var(--orange) 8%, transparent) 0%, transparent 100%);
}

.gradient-canvas {
  background: linear-gradient(135deg, var(--platinum) 0%, var(--cloudy) 100%);
}

/* ============================================
   DOT GRID BACKGROUND
   Used for plant graph canvas
   ============================================ */

.dot-grid-bg {
  background-color: var(--bg-panel);
  background-image: radial-gradient(
    circle,
    var(--dot-grid-color) 1px,
    transparent 1px
  );
  background-size: 16px 16px;
}

@media (min-width: 1400px) {
  .dot-grid-bg {
    background-image: radial-gradient(
      circle,
      var(--dot-grid-color) 1.25px,
      transparent 1.25px
    );
    background-size: 20px 20px;
  }
}

@media (min-width: 1800px) {
  .dot-grid-bg {
    background-image: radial-gradient(
      circle,
      var(--dot-grid-color) 1.5px,
      transparent 1.5px
    );
    background-size: 24px 24px;
  }
}

/* ============================================
   VISUAL EFFECT UTILITIES
   ============================================ */

.backdrop-blur-panel {
  backdrop-filter: blur(4px);
}

.filter-drop-shadow-tiger {
  filter: drop-shadow(0 0 4px var(--accent-hover));
}

.filter-drop-shadow-tiger-lg {
  filter: drop-shadow(0 0 6px var(--accent-hover));
}

.text-shadow-light {
  text-shadow: 0 1px 2px color-mix(in srgb, white 80%, transparent);
}

/* SVG stroke outline effect for labels */
.svg-stroke-outline {
  paint-order: stroke;
  stroke: white;
  stroke-width: 3px;
}

/* Vertical text for collapsed panels */
.text-vertical {
  writing-mode: vertical-rl;
  text-orientation: mixed;
}

/* Text truncation utility */
.text-truncate {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Hide scrollbar utility */
.scrollbar-hidden {
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.scrollbar-hidden::-webkit-scrollbar {
  display: none;
}


================================================
FILE: frontend/src/main.tsx
================================================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </StrictMode>,
)



================================================
FILE: frontend/src/api/cameraApi.ts
================================================
import { postJson } from "./httpClient";

export async function startCameraStream(fps = 15): Promise<void> {
  await postJson("/camera/stream/start", { fps });
}

export async function stopCameraStream(): Promise<void> {
  await postJson("/camera/stream/stop");
}



================================================
FILE: frontend/src/api/flowApi.ts
================================================
import { postJson } from "./httpClient";
import type { Flow } from "@/types";

export async function generateFlow(prompt: string): Promise<Flow> {
  return postJson<Flow>("/flows/generate", { prompt });
}

export async function startFlow(flowId: string): Promise<void> {
  await postJson(`/flows/${flowId}/start`);
}

export async function pauseFlow(): Promise<void> {
  await postJson("/flows/pause");
}

export async function resumeFlow(): Promise<void> {
  await postJson("/flows/resume");
}

export async function abortFlow(): Promise<void> {
  await postJson("/flows/abort");
}

export async function finishFlow(): Promise<void> {
  await postJson("/flows/finish");
}



================================================
FILE: frontend/src/api/flowSocket.ts
================================================
import type { ServerMessage } from "@/types";

const WS_URL = `ws://${window.location.host}/ws`;

export function createFlowSocket(
  onMessage: (msg: ServerMessage) => void,
  onClose?: () => void,
): Promise<{ close: () => void }> {
  return new Promise((resolve, reject) => {
    const ws = new WebSocket(WS_URL);

    ws.onopen = () => {
      // Connection established — from here on, errors surface via onclose
      ws.onerror = null;
      resolve({ close: () => ws.close() });
    };

    ws.onerror = () => reject(new Error("WebSocket connection failed"));

    ws.onmessage = (event) => {
      try {
        onMessage(JSON.parse(event.data) as ServerMessage);
      } catch {
        // Ignore non-JSON messages (e.g. binary frames)
      }
    };

    ws.onclose = () => onClose?.();
  });
}



================================================
FILE: frontend/src/api/httpClient.ts
================================================
const API_BASE = "/api";

export function apiUrl(path: string): string {
  return `${API_BASE}${path}`;
}

export async function postJson<T>(path: string, body?: unknown): Promise<T> {
  const response = await fetch(apiUrl(path), {
    method: "POST",
    headers: body !== undefined ? { "Content-Type": "application/json" } : undefined,
    body: body !== undefined ? JSON.stringify(body) : undefined,
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: response.statusText }));
    throw new Error(error.detail || `Request failed: ${response.statusText}`);
  }

  const text = await response.text();
  return text ? (JSON.parse(text) as T) : (undefined as T);
}

export async function getJson<T>(path: string): Promise<T> {
  const response = await fetch(apiUrl(path), { 
    method: "GET" });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: response.statusText }));
    throw new Error(error.detail || `Request failed: ${response.statusText}`);
  }

  return response.json() as Promise<T>;
}



================================================
FILE: frontend/src/components/camera/BboxOverlay.tsx
================================================
import type { BoundingBoxOverlay } from "@/types";

interface BboxOverlayProps {
  bboxStyle: { left: number; top: number; width: number; height: number };
  overlay: BoundingBoxOverlay;
}

export function BboxOverlay({ bboxStyle, overlay }: BboxOverlayProps) {
  return (
    <div
      className="absolute border-2 border-[var(--status-healthy)] pointer-events-none animate-pulse"
      style={{
        left: bboxStyle.left,
        top: bboxStyle.top,
        width: bboxStyle.width,
        height: bboxStyle.height,
      }}
    >
      <span className="absolute -top-5 left-0 forgis-text-label bg-[var(--status-healthy)] text-white px-1 rounded">
        {overlay.bbox.class_name} ({(overlay.bbox.confidence * 100).toFixed(0)}%)
      </span>
    </div>
  );
}



================================================
FILE: frontend/src/components/camera/CameraFeed.tsx
================================================
import { useEffect, useRef, useState } from "react";
import { ChevronLeft, ChevronRight, Video } from "lucide-react";
import { cn } from "@/lib/utils";
import type { BoundingBoxOverlay } from "@/types";
import { CONTAINER_CAPACITY, ZONE_LABELS_V2 } from "@/constants/cameraConfig";
import { BboxOverlay } from "./BboxOverlay";
import { DetectionStatus, type LatestDetection } from "./DetectionStatus";
import { StationMap } from "./StationMap";

interface CameraFeedProps {
  frameUrl: string | null;
  streaming: boolean;
  lastLabel?: { label: string; version: number } | null;
  bboxOverlay?: BoundingBoxOverlay | null;
}

export function CameraFeed({ frameUrl, streaming, lastLabel, bboxOverlay }: CameraFeedProps) {
  const zoneLabels = ZONE_LABELS_V2;
  const [collapsed, setCollapsed] = useState(false);
  const [latestDetection, setLatestDetection] = useState<LatestDetection | null>(null);
  const lastBboxRef = useRef<string | null>(null);
  const shotCounterRef = useRef(0);
  const [zoneCounts, setZoneCounts] = useState<Record<string, number>>({
    Zone_A: 0, Zone_B: 0, Zone_C: 0,
  });

  // Track latest label + increment zone count
  useEffect(() => {
    if (lastLabel) {
      shotCounterRef.current += 1;
      setLatestDetection({ type: "label", label: zoneLabels[lastLabel.label] ?? lastLabel.label, shot: shotCounterRef.current });
      setZoneCounts((prev) => {
        if (lastLabel.label in prev) {
          return { ...prev, [lastLabel.label]: prev[lastLabel.label] + 1 };
        }
        return prev;
      });
    }
  }, [lastLabel, zoneLabels]);

  // Track latest bbox detection
  useEffect(() => {
    if (bboxOverlay) {
      const bboxKey = `${bboxOverlay.bbox.class_name}-${bboxOverlay.bbox.confidence.toFixed(2)}`;
      if (lastBboxRef.current !== bboxKey) {
        lastBboxRef.current = bboxKey;
        shotCounterRef.current += 1;
        setLatestDetection({
          type: "bbox",
          label: bboxOverlay.bbox.class_name,
          confidence: bboxOverlay.bbox.confidence,
          shot: shotCounterRef.current,
        });
      }
    }
  }, [bboxOverlay]);

const imgRef = useRef<HTMLImageElement>(null);
  const [imgRect, setImgRect] = useState<{ width: number; height: number; left: number; top: number } | null>(null);

  // Update image rect on load and resize
  useEffect(() => {
    const updateRect = () => {
      if (imgRef.current) {
        const rect = imgRef.current.getBoundingClientRect();
        const parent = imgRef.current.parentElement?.getBoundingClientRect();
        if (parent) {
          setImgRect({
            width: rect.width,
            height: rect.height,
            left: rect.left - parent.left,
            top: rect.top - parent.top,
          });
        }
      }
    };

    updateRect();
    window.addEventListener("resize", updateRect);
    return () => window.removeEventListener("resize", updateRect);
  }, [frameUrl]);

  // Calculate bbox overlay position scaled to displayed image
  const getBboxStyle = () => {
    if (!bboxOverlay || !imgRect) return null;

    const scaleX = imgRect.width / bboxOverlay.frameWidth;
    const scaleY = imgRect.height / bboxOverlay.frameHeight;

    return {
      left: imgRect.left + bboxOverlay.bbox.x * scaleX,
      top: imgRect.top + bboxOverlay.bbox.y * scaleY,
      width: bboxOverlay.bbox.width * scaleX,
      height: bboxOverlay.bbox.height * scaleY,
    };
  };

  const bboxStyle = getBboxStyle();

  return (
    <div
      className={cn(
        "relative flex flex-col bg-card border-r border-border transition-[width] duration-250 ease-in-out overflow-hidden",
        collapsed ? "w-9" : "w-96",
      )}
    >
      {/* Toggle */}
      <button
        className="absolute top-2 right-1 z-10 flex items-center justify-center w-7 h-7 rounded bg-transparent text-muted-foreground hover:bg-muted hover:text-foreground cursor-pointer border-none"
        onClick={() => setCollapsed((c) => !c)}
      >
        {collapsed ? <ChevronRight size={14} /> : <ChevronLeft size={14} />}
      </button>

      {!collapsed && (
        <div className="flex flex-col pt-10 px-3 pb-0 overflow-hidden h-full">
          {/* ── Camera Feed Section ──────────────────────── */}
          <div className="flex items-center justify-between mb-3">
            <h2 className="forgis-text-label font-normal uppercase tracking-wider text-[var(--gunmetal-50)] font-forgis-digit">
              Camera Feed
            </h2>
            <Video size={12} className="text-[var(--gunmetal-50)]" />
          </div>

          {/* Subtitle */}
          <span className="forgis-text-detail text-[var(--gunmetal-50)] leading-none mb-4 font-forgis-body">
            Real time acquisition from robot camera
          </span>

          {/* Image container */}
          <div className="relative bg-[var(--platinum)] rounded-[8px] aspect-video overflow-hidden shrink-0">
            {streaming && frameUrl ? (
              <>
                <img
                  ref={imgRef}
                  src={frameUrl}
                  alt="Camera stream"
                  className="absolute inset-0 w-full h-full object-cover"
                  onLoad={() => {
                    if (imgRef.current) {
                      const rect = imgRef.current.getBoundingClientRect();
                      const parent = imgRef.current.parentElement?.getBoundingClientRect();
                      if (parent) {
                        setImgRect({
                          width: rect.width,
                          height: rect.height,
                          left: rect.left - parent.left,
                          top: rect.top - parent.top,
                        });
                      }
                    }
                  }}
                />
                {bboxStyle && bboxOverlay && (
                  <BboxOverlay bboxStyle={bboxStyle} overlay={bboxOverlay} />
                )}
              </>
            ) : (
              <div className="absolute inset-0 flex items-center justify-center">
                <span className="text-[var(--gunmetal-50)] forgis-text-reading font-forgis-body">
                  Waiting for stream...
                </span>
              </div>
            )}
          </div>

          <DetectionStatus latestDetection={latestDetection} />

          <StationMap
            zoneCounts={zoneCounts}
            zoneLabels={zoneLabels}
            containerCapacity={CONTAINER_CAPACITY}
          />
        </div>
      )}
    </div>
  );
}



================================================
FILE: frontend/src/components/camera/DetectionStatus.tsx
================================================
import { Box, Tag, ShieldCheck } from "lucide-react";
import { cn } from "@/lib/utils";

type DetectionType = "bbox" | "label" | "qc";

export interface LatestDetection {
  type: DetectionType;
  label: string;
  confidence?: number;
  shot: number;
}

interface DetectionStatusProps {
  latestDetection: LatestDetection | null;
}

export function DetectionStatus({ latestDetection }: DetectionStatusProps) {
  return (
    <div className="flex items-center justify-between mt-2 mb-3">
      {latestDetection ? (
        <>
          <div className="flex items-center gap-1.5">
            {latestDetection.type === "bbox" ? (
              <Box size={11} className="text-[var(--status-healthy)]" />
            ) : latestDetection.type === "qc" ? (
              <ShieldCheck size={12} className={latestDetection.label === "Readable" ? "text-[var(--status-healthy)]" : "text-[var(--status-critical)]"} />
            ) : (
              <Tag size={13} className="text-[var(--gunmetal-50)]" />
            )}
            <span className={cn(
              "forgis-text-caption leading-none font-forgis-body truncate",
              latestDetection.type === "bbox" ? "text-[var(--status-healthy)]" : latestDetection.type === "qc" ? (latestDetection.label === "Readable" ? "text-[var(--status-healthy)]" : "text-[var(--status-critical)]") : "text-[var(--gunmetal-50)]"
            )}>
              {latestDetection.label}
              {latestDetection.confidence !== undefined && ` (${(latestDetection.confidence * 100).toFixed(0)}%)`}
            </span>
          </div>
          <span className="forgis-text-micro text-[var(--gunmetal-50)] font-forgis-digit whitespace-nowrap">
            Shot {latestDetection.shot}
          </span>
        </>
      ) : (
        <span className="forgis-text-caption text-[var(--gunmetal-50)] font-forgis-body">
          No detections yet
        </span>
      )}
    </div>
  );
}



================================================
FILE: frontend/src/components/camera/StationMap.tsx
================================================
interface ZoneCardProps {
  zoneKey: string;
  zoneLabel: string;
  count: number;
  capacity: number;
}

function ZoneCard({ zoneKey, zoneLabel, count, capacity }: ZoneCardProps) {
  const pct = Math.min(count / capacity, 1);
  return (
    <div className="flex flex-col gap-1 rounded-lg border border-border bg-[var(--platinum)] p-2">
      <span className="forgis-text-caption text-[var(--gunmetal-50)] font-forgis-digit leading-none">
        {zoneKey} ({zoneLabel})
      </span>
      <span
        className="forgis-text-label font-medium font-forgis-digit leading-none"
        style={{ color: pct >= 1 ? "var(--orange)" : "var(--gunmetal)" }}
      >
        {count}/{capacity}
      </span>
      <div className="h-[3px] w-full rounded-full bg-[var(--gunmetal-10)] mt-0.5">
        <div
          className="h-full rounded-full transition-all duration-300"
          style={{ width: `${pct * 100}%`, background: pct >= 1 ? "var(--orange)" : "var(--accent-hover)" }}
        />
      </div>
    </div>
  );
}

interface StationMapProps {
  zoneCounts: Record<string, number>;
  zoneLabels: Record<string, string>;
  containerCapacity: number;
}

export function StationMap({ zoneCounts, zoneLabels, containerCapacity }: StationMapProps) {
  const total = zoneCounts.Zone_A + zoneCounts.Zone_B + zoneCounts.Zone_C;

  return (
    <div className="flex flex-col flex-1 min-h-0 border-t border-border -mx-3 px-3 pt-3">
      <h2 className="forgis-text-label font-normal uppercase tracking-wider text-[var(--gunmetal-50)] font-forgis-digit mb-3">
        Station Map
      </h2>

      {/* 2×2 grid: 3 containers (L-shape) + total (top-right) */}
      <div className="grid grid-cols-2 gap-2">
        {/* Top-left: Zone A */}
        <ZoneCard
          zoneKey="Zone A"
          zoneLabel={zoneLabels.Zone_A}
          count={zoneCounts.Zone_A}
          capacity={containerCapacity}
        />

        {/* Top-right: Total metric */}
        <div className="flex flex-col items-center justify-center p-2">
          <div className="flex items-baseline gap-0.5 leading-none">
            <span className="text-[1.5rem] font-medium font-forgis-digit text-[var(--gunmetal)]">
              {total}
            </span>
            <span className="forgis-text-caption font-forgis-digit text-[var(--gunmetal-50)]">
              /{containerCapacity * 3}
            </span>
          </div>
          <span className="forgis-text-caption text-[var(--gunmetal-50)] font-forgis-digit leading-none mt-1">
            Total
          </span>
        </div>

        {/* Bottom-left: Zone B */}
        <ZoneCard
          zoneKey="Zone B"
          zoneLabel={zoneLabels.Zone_B}
          count={zoneCounts.Zone_B}
          capacity={containerCapacity}
        />

        {/* Bottom-right: Zone C */}
        <ZoneCard
          zoneKey="Zone C"
          zoneLabel={zoneLabels.Zone_C}
          count={zoneCounts.Zone_C}
          capacity={containerCapacity}
        />
      </div>
    </div>
  );
}



================================================
FILE: frontend/src/components/chat/CoderSidebar.tsx
================================================
import { useRef, useState, useEffect } from "react";
import { ChevronLeft, ChevronRight, Send } from "lucide-react";
import { cn } from "@/lib/utils";
import type { ChatMessage } from "@/types";
import { CHAT_TEXTAREA_MAX_HEIGHT } from "@/constants/chatConfig";

interface CoderSidebarProps {
  messages: ChatMessage[];
  loading: boolean;
  onSend: (message: string) => void;
}

export function CoderSidebar({ messages, loading, onSend }: CoderSidebarProps) {
  const [collapsed, setCollapsed] = useState(false);
  const [input, setInput] = useState("");
  const bottomRef = useRef<HTMLDivElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    const trimmed = input.trim();
    if (!trimmed || loading) return;
    onSend(trimmed);
    setInput("");
  };

  return (
    <div
      className={cn(
        "relative flex flex-col border-l transition-[width] duration-250 ease-in-out overflow-hidden",
        collapsed ? "w-9" : "w-80"
      )}
      style={{ background: "var(--sidebar-bg)", borderColor: "var(--sidebar-border)" }}
    >
      {/* Toggle */}
      <button
        className="absolute top-2 left-1 z-10 flex items-center justify-center w-7 h-7 rounded bg-transparent text-muted-foreground hover:bg-muted hover:text-foreground cursor-pointer border-none"
        onClick={() => setCollapsed((c) => !c)}
      >
        {collapsed ? <ChevronLeft size={14} /> : <ChevronRight size={14} />}
      </button>

      {!collapsed && (
        <div className="flex flex-col pt-10 px-3 pb-0 overflow-hidden h-full">
          <h2 className="forgis-text-title font-normal uppercase text-[var(--gunmetal-50)] leading-none font-forgis-digit mb-3">
            Chat
          </h2>

          {/* Messages */}
          <div className="flex-1 overflow-y-auto flex flex-col gap-2 pb-2">
            {/* Welcome message always shown first */}
            <div
              className="self-start text-foreground max-w-[90%] px-3 py-2 rounded-lg rounded-bl-sm forgis-text-body leading-snug font-forgis-body"
              style={{ background: "var(--chat-assistant-bg)" }}
            >
              Welcome! Describe a robot task and I'll generate an execution flow for you.
            </div>
            {messages.map((msg) => (
              <div
                key={msg.id}
                className={cn(
                  "max-w-[90%] px-3 py-2 rounded-lg forgis-text-body leading-snug break-words text-foreground font-forgis-body",
                  msg.role === "user"
                    ? "self-end rounded-br-sm border"
                    : "self-start rounded-bl-sm"
                )}
                style={
                  msg.role === "user"
                    ? { background: "var(--chat-user-bg)", borderColor: "var(--chat-user-border)" }
                    : { background: "var(--chat-assistant-bg)" }
                }
              >
                {msg.content}
              </div>
            ))}
            {loading && (
              <div
                className="self-start text-[var(--gunmetal-50)] max-w-[90%] px-3 py-2 rounded-lg rounded-bl-sm forgis-text-body italic opacity-70 font-forgis-body"
                style={{ background: "var(--chat-assistant-bg)" }}
              >
                Thinking...
              </div>
            )}
            <div ref={bottomRef} />
          </div>

          {/* Input form */}
          <form className="flex items-end gap-1.5 py-2.5 border-t border-border" onSubmit={handleSubmit}>
            <textarea
              ref={textareaRef}
              className="flex-1 px-2.5 py-2 bg-input border border-border rounded-md text-foreground forgis-text-body outline-none focus:border-[var(--tiger)] placeholder:text-muted-foreground font-forgis-body resize-none overflow-hidden"
              value={input}
              onChange={(e) => {
                setInput(e.target.value);
                e.target.style.height = "auto";
                e.target.style.height = `${Math.min(e.target.scrollHeight, CHAT_TEXTAREA_MAX_HEIGHT)}px`;
              }}
              onKeyDown={(e) => {
                if (e.key === "Enter" && !e.shiftKey) {
                  e.preventDefault();
                  handleSubmit(e);
                }
              }}
              placeholder="Describe the task..."
              disabled={loading}
              rows={1}
              style={{ maxHeight: CHAT_TEXTAREA_MAX_HEIGHT }}
            />
            <button
              className="px-3 py-2 bg-[var(--tiger)] text-white rounded-md forgis-text-body font-normal cursor-pointer border-none hover:bg-[var(--tiger)]/90 disabled:opacity-40 disabled:cursor-not-allowed shrink-0"
              type="submit"
              disabled={loading || !input.trim()}
            >
              <Send size={14} />
            </button>
          </form>
        </div>
      )}
    </div>
  );
}



================================================
FILE: frontend/src/components/devices/AddDeviceDialog.tsx
================================================
import { useState, type ReactNode } from "react";
import type { Device, DeviceType } from "@/types";
import { BRANDS, EMPTY_FORM, type DeviceFormData } from "@/constants/deviceConfig";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface AddDeviceDialogProps {
  trigger: ReactNode;
  onAdd: (device: Device) => void;
}

export function AddDeviceDialog({ trigger, onAdd }: AddDeviceDialogProps) {
  const [open, setOpen] = useState(false);
  const [form, setForm] = useState<DeviceFormData>(EMPTY_FORM);

  const set = <K extends keyof DeviceFormData>(key: K, value: DeviceFormData[K]) => {
    setForm((prev) => ({ ...prev, [key]: value }));
  };

  const handleTypeChange = (value: DeviceType) => {
    setForm((prev) => ({ ...prev, type: value, brand: "", robotModel: "" }));
  };

  const handleOpenChange = (next: boolean) => {
    setOpen(next);
    if (!next) setForm(EMPTY_FORM);
  };

  const handleAdd = () => {
    const newDevice: Device = {
      id: `device-${Date.now()}`,
      name: form.name.trim(),
      vendor: "Universal Robots",
      type: "robot",
      status: "connected",
      ip: form.apiEndpoint.trim() || "192.168.1.10",
    };
    onAdd(newDevice);
    handleOpenChange(false);
  };

  const canAdd =
    form.type !== "" &&
    form.brand !== "" &&
    form.name.trim().length > 0;

  return (
    <Dialog open={open} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>{trigger}</DialogTrigger>

      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Add Device</DialogTitle>
          <DialogDescription>
            Configure a device to connect to this station.
          </DialogDescription>
        </DialogHeader>

        <div className="flex flex-col gap-4 py-2">
          <div className="flex flex-col gap-1.5">
            <Label htmlFor="device-type">Device Type</Label>
            <Select
              value={form.type}
              onValueChange={(v) => handleTypeChange(v as DeviceType)}
            >
              <SelectTrigger id="device-type">
                <SelectValue placeholder="Select type..." />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="robot">Robot</SelectItem>
                <SelectItem value="camera">Camera</SelectItem>
                <SelectItem value="sensor">Sensor</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="flex flex-col gap-1.5">
            <Label htmlFor="device-brand">Brand</Label>
            <Select
              value={form.brand}
              onValueChange={(v) => set("brand", v)}
              disabled={!form.type}
            >
              <SelectTrigger id="device-brand">
                <SelectValue placeholder={form.type ? "Select brand..." : "Select a type first"} />
              </SelectTrigger>
              <SelectContent>
                {form.type &&
                  BRANDS[form.type].map((brand) => (
                    <SelectItem key={brand} value={brand}>
                      {brand}
                    </SelectItem>
                  ))}
              </SelectContent>
            </Select>
          </div>

          {form.type === "robot" && (
            <div className="flex flex-col gap-1.5">
              <Label htmlFor="robot-model">Model</Label>
              <Input
                id="robot-model"
                value={form.robotModel}
                onChange={(e) => set("robotModel", e.target.value)}
                placeholder="e.g. UR3, UR10e, IRB 120"
              />
            </div>
          )}

          <div className="flex flex-col gap-1.5">
            <Label htmlFor="device-name">Device Name</Label>
            <Input
              id="device-name"
              value={form.name}
              onChange={(e) => set("name", e.target.value)}
              placeholder="e.g. Robot_01, PLC_Main"
            />
          </div>

          <div className="flex flex-col gap-1.5">
            <Label htmlFor="api-endpoint">
              API Endpoint{" "}
              <span className="text-muted-foreground font-normal">(optional)</span>
            </Label>
            <Input
              id="api-endpoint"
              value={form.apiEndpoint}
              onChange={(e) => set("apiEndpoint", e.target.value)}
              placeholder="e.g. 192.168.1.10"
              onKeyDown={(e) => e.key === "Enter" && canAdd && handleAdd()}
            />
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={() => handleOpenChange(false)}>
            Cancel
          </Button>
          <Button
            disabled={!canAdd}
            onClick={handleAdd}
            className="bg-primary text-primary-foreground hover:bg-primary/80"
          >
            Add Device
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}



================================================
FILE: frontend/src/components/devices/DeviceList.tsx
================================================
import type { Device } from "@/types";
import { DEVICE_ICONS, STATUS_COLOR, STATUS_LABEL } from "@/constants/deviceConfig";
import { cn } from "@/lib/utils";

interface DeviceListProps {
  devices: Device[];
  compact?: boolean;
}

export function DeviceList({ devices, compact = false }: DeviceListProps) {
  if (devices.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center gap-1.5 py-5 text-muted-foreground">
        <span className="forgis-text-label font-forgis-body">No devices connected.</span>
      </div>
    );
  }

  if (compact) {
    return (
      <div className="divide-y divide-border">
        {devices.map((device) => {
          const Icon = DEVICE_ICONS[device.type];
          const color = STATUS_COLOR[device.status];
          const label = STATUS_LABEL[device.status];
          return (
            <div key={device.id} className="flex items-center gap-2.5 px-3 py-2">
              <div className="shrink-0 w-6 h-6 rounded-md bg-muted/50 flex items-center justify-center">
                <Icon className="w-3.5 h-3.5 text-muted-foreground" />
              </div>
              <div className="flex-1 min-w-0">
                <div className="forgis-text-detail font-normal text-foreground leading-tight truncate font-forgis-digit">
                  {device.name}
                </div>
                <div className="forgis-text-detail text-[var(--gunmetal-50)] truncate font-forgis-body">
                  {device.vendor} · {device.ip}
                </div>
              </div>
              <div className="flex items-center gap-1 shrink-0">
                <span
                  className={cn(
                    "w-1.5 h-1.5 rounded-full shrink-0",
                    device.status === "warning" && "animate-pulse",
                  )}
                  style={{ background: color }}
                />
                <span className="forgis-text-detail font-forgis-digit" style={{ color }}>{label}</span>
              </div>
            </div>
          );
        })}
      </div>
    );
  }

  return (
    <div className="divide-y divide-border">
      {devices.map((device) => {
        const Icon = DEVICE_ICONS[device.type];
        const color = STATUS_COLOR[device.status];
        const label = STATUS_LABEL[device.status];
        return (
          <div key={device.id} className="flex items-center gap-3 px-6 py-2.5">
            <div className="shrink-0 w-7 h-7 rounded-md bg-muted/50 flex items-center justify-center">
              <Icon className="w-4 h-4 text-muted-foreground" />
            </div>
            <div className="flex-1 min-w-0">
              <div className="forgis-text-label font-medium text-foreground leading-tight truncate">
                {device.name}
              </div>
              <div className="forgis-text-caption text-muted-foreground truncate">{device.vendor}</div>
            </div>
            <span className="forgis-text-caption text-muted-foreground font-mono shrink-0">
              {device.ip}
            </span>
            <div className="flex items-center gap-1.5 shrink-0 w-[76px] justify-end">
              <span
                className={cn(
                  "w-1.5 h-1.5 rounded-full shrink-0",
                  device.status === "warning" && "animate-pulse",
                )}
                style={{ background: color }}
              />
              <span className="forgis-text-caption" style={{ color }}>{label}</span>
            </div>
          </div>
        );
      })}
    </div>
  );
}



================================================
FILE: frontend/src/components/devices/DevicesSidebar.tsx
================================================
import { useState } from "react";
import { ChevronLeft, ChevronRight, Plus } from "lucide-react";
import type { Device, SelectedStep } from "@/types";
import { DEFAULT_DEVICES } from "@/constants/deviceConfig";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { DeviceList } from "./DeviceList";
import { AddDeviceDialog } from "./AddDeviceDialog";
import { NodeCreatorDialog } from "./NodeCreatorDialog";
import { ParameterEditor } from "./ParameterEditor";

interface DevicesSidebarProps {
  selectedStep?: SelectedStep | null;
  onDeselectStep?: () => void;
  onParamChange?: (nodeId: string, stepId: string, key: string, value: unknown) => void;
  nodeCreatorOpen?: boolean;
  onCloseNodeCreator?: () => void;
}

export function DevicesSidebar({ selectedStep, onDeselectStep, onParamChange, nodeCreatorOpen, onCloseNodeCreator }: DevicesSidebarProps) {
  const [devices, setDevices] = useState<Device[]>(DEFAULT_DEVICES);
  const [collapsed, setCollapsed] = useState(false);

  return (
    <div
      className={cn(
        "relative flex flex-col bg-card border-r border-border transition-[width] duration-250 ease-in-out overflow-hidden",
        collapsed ? "w-9" : "w-64"
      )}
    >
      {/* Toggle */}
      <button
        className="absolute top-2 right-1 z-10 flex items-center justify-center w-7 h-7 rounded bg-transparent text-muted-foreground hover:bg-muted hover:text-foreground cursor-pointer border-none"
        onClick={() => setCollapsed((c) => !c)}
      >
        {collapsed ? <ChevronRight size={14} /> : <ChevronLeft size={14} />}
      </button>

      {!collapsed && (
        <div className="flex flex-col pt-10 px-3 pb-0 overflow-hidden h-full">
          {/* Header */}
          <div className="flex items-center justify-between mb-3">
            <h2 className="forgis-text-title font-normal uppercase text-[var(--gunmetal-50)] leading-none font-forgis-digit">
              Devices
            </h2>
            <AddDeviceDialog
              trigger={
                <Button variant="outline" size="sm" className="h-6 gap-1 px-1.5 forgis-text-detail">
                  <Plus className="w-3 h-3" />
                  Add
                </Button>
              }
              onAdd={(device) => setDevices((prev) => [...prev, device])}
            />
          </div>

          {/* Device list */}
          <div className={cn("overflow-y-auto -mx-3", selectedStep ? "shrink-0 max-h-[40%]" : "flex-1")}>
            <DeviceList devices={devices} compact />
          </div>

          {/* Node creator dialog */}
          <NodeCreatorDialog
            open={!!nodeCreatorOpen}
            onClose={() => onCloseNodeCreator?.()}
          />

          {/* Parameter editor (inline) */}
          {selectedStep && (
            <ParameterEditor
              selectedStep={selectedStep}
              onDeselectStep={onDeselectStep}
              onParamChange={onParamChange}
            />
          )}
        </div>
      )}
    </div>
  );
}



================================================
FILE: frontend/src/components/devices/NodeCreatorDialog.tsx
================================================
import { useEffect, useState } from "react";
import type { NodeCreatorState } from "@/types";
import { NODE_TYPES, TASKS, EMPTY_CREATOR } from "@/constants/executorConfig";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface NodeCreatorDialogProps {
  open: boolean;
  onClose: () => void;
  onAdd?: (creator: NodeCreatorState) => void;
}

export function NodeCreatorDialog({ open, onClose, onAdd }: NodeCreatorDialogProps) {
  const [creator, setCreator] = useState<NodeCreatorState>(EMPTY_CREATOR);

  // Reset creator form when panel opens
  useEffect(() => {
    if (open) setCreator(EMPTY_CREATOR);
  }, [open]);

  return (
    <Dialog open={open} onOpenChange={(v) => { if (!v) onClose(); }}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>New Node</DialogTitle>
          <DialogDescription>
            Configure a new node to add to the flow.
          </DialogDescription>
        </DialogHeader>

        <div className="flex flex-col gap-4 py-2">
          <div className="flex flex-col gap-1.5">
            <Label htmlFor="node-type">Node Type</Label>
            <Select
              value={creator.nodeType ?? ""}
              onValueChange={(v) => setCreator({ nodeType: v, task: null, label: "" })}
            >
              <SelectTrigger id="node-type">
                <SelectValue placeholder="Select type..." />
              </SelectTrigger>
              <SelectContent>
                {NODE_TYPES.map((nt) => (
                  <SelectItem key={nt.value} value={nt.value}>{nt.label}</SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {creator.nodeType && (
            <div className="flex flex-col gap-1.5">
              <Label htmlFor="node-task">Task</Label>
              <Select
                value={creator.task ?? ""}
                onValueChange={(v) => setCreator((prev) => ({ ...prev, task: v, label: "" }))}
              >
                <SelectTrigger id="node-task">
                  <SelectValue placeholder="Select task..." />
                </SelectTrigger>
                <SelectContent>
                  {TASKS.map((t) => (
                    <SelectItem key={t.value} value={t.value}>{t.label}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          )}

          {creator.task && (
            <div className="flex flex-col gap-1.5">
              <Label htmlFor="node-label">Label</Label>
              <Input
                id="node-label"
                placeholder="Enter node label..."
                value={creator.label}
                onChange={(e) => setCreator((prev) => ({ ...prev, label: e.target.value }))}
              />
            </div>
          )}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={onClose}>
            Cancel
          </Button>
          <Button
            disabled={!creator.label.trim()}
            onClick={() => { onAdd?.(creator); onClose(); }}
            className="bg-primary text-primary-foreground hover:bg-primary/80"
          >
            Create Node
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}



================================================
FILE: frontend/src/components/devices/ParameterEditor.tsx
================================================
import { X } from "lucide-react";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import type { SelectedStep } from "@/types";

interface ParameterEditorProps {
  selectedStep: SelectedStep;
  onDeselectStep?: () => void;
  onParamChange?: (nodeId: string, stepId: string, key: string, value: unknown) => void;
}

export function ParameterEditor({ selectedStep, onDeselectStep, onParamChange }: ParameterEditorProps) {
  return (
    <div className="flex flex-col flex-1 min-h-0 border-t border-border -mx-3 mt-3">
      {/* Header */}
      <div className="flex items-center justify-between px-3 pt-2.5 pb-1.5">
        <h2 className="forgis-text-label font-normal uppercase tracking-wider text-[var(--gunmetal-50)] font-forgis-digit">
          Parameters
        </h2>
        <button
          className="flex items-center justify-center w-5 h-5 rounded bg-transparent text-muted-foreground hover:bg-muted hover:text-foreground cursor-pointer border-none"
          onClick={onDeselectStep}
        >
          <X size={12} />
        </button>
      </div>

      {/* Skill info */}
      <div className="px-3 pb-2 space-y-0.5">
        <div className="forgis-text-detail font-normal text-foreground truncate font-forgis-digit">
          {selectedStep.step.skill}
        </div>
        <div className="forgis-text-detail text-[var(--gunmetal-50)] font-forgis-body">
          executor: {selectedStep.step.executor}
        </div>
      </div>

      {/* Param fields */}
      <div className="flex-1 overflow-y-auto px-3 pb-3">
        {selectedStep.step.params && Object.keys(selectedStep.step.params).length > 0 ? (
          <div className="space-y-2.5">
            {Object.entries(selectedStep.step.params).map(([key, value]) => (
              <div key={`${selectedStep.step.id}-${key}`} className="flex flex-col gap-1">
                <label className="forgis-text-detail font-normal text-[var(--gunmetal-50)] font-forgis-digit">
                  {key}
                </label>
                {typeof value === "boolean" ? (
                  <Select
                    value={String(value)}
                    onValueChange={(v) =>
                      onParamChange?.(selectedStep.nodeId, selectedStep.step.id, key, v === "true")
                    }
                  >
                    <SelectTrigger className="h-7 forgis-text-detail text-[var(--gunmetal-50)]">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="true">true</SelectItem>
                      <SelectItem value="false">false</SelectItem>
                    </SelectContent>
                  </Select>
                ) : typeof value === "number" ? (
                  <Input
                    type="number"
                    step="any"
                    className="h-7 forgis-text-detail text-[var(--gunmetal-50)]"
                    value={value}
                    onChange={(e) =>
                      onParamChange?.(
                        selectedStep.nodeId,
                        selectedStep.step.id,
                        key,
                        e.target.value === "" ? 0 : parseFloat(e.target.value),
                      )
                    }
                  />
                ) : Array.isArray(value) ? (
                  <div className="grid grid-cols-3 gap-1">
                    {(value as unknown[]).map((v, i) => (
                      <Input
                        key={i}
                        type="number"
                        step="any"
                        className="h-7 forgis-text-detail text-[var(--gunmetal-50)]"
                        value={typeof v === "number" ? v : String(v ?? "")}
                        onChange={(e) => {
                          const arr = [...(value as unknown[])];
                          arr[i] = e.target.value === "" ? 0 : parseFloat(e.target.value);
                          onParamChange?.(selectedStep.nodeId, selectedStep.step.id, key, arr);
                        }}
                      />
                    ))}
                  </div>
                ) : (
                  <textarea
                    className="w-full px-3 py-1.5 bg-transparent border border-border rounded-md forgis-text-detail text-[var(--gunmetal-50)] font-forgis-body resize-none outline-none focus:border-ring"
                    style={{ fieldSizing: "content" } as React.CSSProperties}
                    value={String(value ?? "")}
                    rows={1}
                    onChange={(e) =>
                      onParamChange?.(selectedStep.nodeId, selectedStep.step.id, key, e.target.value)
                    }
                  />
                )}
              </div>
            ))}
          </div>
        ) : (
          <div className="forgis-text-detail text-[var(--gunmetal-50)] text-center py-4 font-forgis-body">
            No parameters for this step.
          </div>
        )}
      </div>
    </div>
  );
}



================================================
FILE: frontend/src/components/flow/ExecutionNode.tsx
================================================
import { Handle, Position, type NodeProps } from "@xyflow/react";
import { Cpu } from "lucide-react";
import { EXECUTOR_ICONS } from "@/constants/executorConfig";
import {
  getNodeBorderColor,
  getNodeOpacity,
  type ExecNode,
} from "@/services/flowTransformService";
import type { NodeExecStatus } from "@/types";

function ExecutionNode({ data }: NodeProps<ExecNode>) {
  const { label, steps, nodeType, execState, flowStatus, style, message } = data;
  const status = (execState?.status ?? "idle") as NodeExecStatus;
  const borderColor = getNodeBorderColor(status, flowStatus);
  const opacity = getNodeOpacity(status, flowStatus);
  const isRunning = status === "running";

  // Count completed steps for progress
  const totalSteps = steps?.length ?? 0;
  const doneSteps = steps?.filter(
    (s) => execState?.stepStates?.[s.id]?.status === "success",
  ).length ?? 0;

  // Start/End nodes - simple pill shape
  if (nodeType === "start" || nodeType === "end") {
    return (
      <>
        {nodeType === "end" && (
          <Handle
            type="target"
            position={Position.Top}
            id="top"
            className="!w-2 !h-2 !border !border-solid"
            style={{ background: "var(--handle-bg)", borderColor: "var(--handle-border)" }}
          />
        )}
        <div
          className="rounded-full px-6 py-2 text-center"
          style={{
            background: "var(--gunmetal-50)",
            opacity: 0.9,
          }}
        >
          <div className="forgis-text-reading font-normal text-white font-forgis-digit">{label}</div>
        </div>
        {nodeType === "start" && (
          <Handle
            type="source"
            position={Position.Bottom}
            id="bottom"
            className="!w-2 !h-2 !border !border-solid"
            style={{ background: "var(--handle-bg)", borderColor: "var(--handle-border)" }}
          />
        )}
      </>
    );
  }

  // State nodes - container with steps inside
  return (
    <>
      <Handle
        type="target"
        position={Position.Top}
        id="top"
        className="!w-2 !h-2 !border !border-solid"
            style={{ background: "var(--handle-bg)", borderColor: "var(--handle-border)" }}
      />
      {/* Left-side handles for loop edges */}
      <Handle
        type="source"
        position={Position.Left}
        id="loop-source"
        className="!w-2 !h-2 !border !border-solid"
            style={{ background: "var(--handle-bg)", borderColor: "var(--handle-border)" }}
      />
      <Handle
        type="target"
        position={Position.Left}
        id="loop-target"
        className="!w-2 !h-2 !border !border-solid"
            style={{ background: "var(--handle-bg)", borderColor: "var(--handle-border)" }}
      />
      <div
        className="rounded-lg overflow-hidden"
        style={{
          width: style?.width ?? 300,
          minHeight: 80,
          background: "var(--card)",
          border: `2px solid ${borderColor}`,
          opacity,
          boxShadow: isRunning ? "0 0 16px 4px var(--node-glow)" : undefined,
          transition: "border-color 0.3s, opacity 0.3s, box-shadow 0.3s",
        }}
      >
        {/* Header */}
        <div
          className="px-3 py-2 flex items-center justify-between"
          style={{ background: "var(--node-header)" }}
        >
          <span className="forgis-text-reading font-normal text-[var(--gunmetal)] dark:text-foreground font-forgis-digit uppercase tracking-wide">
            {label}
          </span>
          {totalSteps > 0 && status !== "idle" && (
            <span className="forgis-text-caption text-muted-foreground font-forgis-digit tabular-nums">
              {doneSteps}/{totalSteps}
            </span>
          )}
        </div>

        {/* Progress bar (thin, below header) */}
        {totalSteps > 0 && status === "running" && (
          <div className="h-[2px] bg-muted/30">
            <div
              className="h-full transition-all duration-300"
              style={{
                width: `${(doneSteps / totalSteps) * 100}%`,
                background: "var(--status-healthy)",
              }}
            />
          </div>
        )}

        {/* Steps list / empty message */}
        <div className="p-2">
          {!steps?.length && message && (
            <p className="px-2 py-3 forgis-text-label text-muted-foreground text-center font-forgis-body">{message}</p>
          )}
          {steps?.map((step, idx) => {
            const stepState = execState?.stepStates?.[step.id];
            const stepStatus = stepState?.status ?? "idle";
            const ExecIcon = EXECUTOR_ICONS[step.executor] ?? Cpu;

            // Status-based styling
            let rowBg = "transparent";
            let ringClass = "";
            if (stepStatus === "running") {
              rowBg = "color-mix(in srgb, var(--primary) 8%, transparent)";
              ringClass = "ring-1 ring-primary/40";
            } else if (stepStatus === "success") {
              rowBg = "color-mix(in srgb, var(--status-healthy) 6%, transparent)";
            } else if (stepStatus === "failure") {
              rowBg = "color-mix(in srgb, var(--status-critical) 8%, transparent)";
            }

            return (
              <div key={step.id}>
                {/* Dotted separator between steps */}
                {idx > 0 && (
                  <div className="flex items-center px-2 py-0.5">
                    <div className="w-5" />
                    <div className="flex-1 border-t border-dotted border-border/40" />
                  </div>
                )}
                <div
                  className={`flex items-stretch rounded forgis-text-label cursor-pointer transition-all ${ringClass}`}
                  style={{ background: rowBg }}
                  onClick={() => {
                    data.onSelectStep?.(data.nodeId, step);
                  }}
                >
                  {/* Accent strip */}
                  <div
                    className="w-1 shrink-0 rounded-l bg-border/60"
                  />

                  {/* Content */}
                  <div className="flex-1 px-2 py-1.5 min-w-0">
                    <div className="flex items-center gap-1.5">
                      {/* Status dot */}
                      {stepStatus === "running" && (
                        <span className="w-1.5 h-1.5 rounded-full bg-primary animate-pulse shrink-0" />
                      )}
                      {stepStatus === "success" && (
                        <span className="w-1.5 h-1.5 rounded-full shrink-0" style={{ background: "var(--status-healthy)" }} />
                      )}
                      {stepStatus === "failure" && (
                        <span className="w-1.5 h-1.5 rounded-full shrink-0" style={{ background: "var(--status-critical)" }} />
                      )}

                      {/* Skill name */}
                      <span className="font-normal text-[var(--gunmetal)] dark:text-foreground truncate font-forgis-digit">{step.skill}</span>

                    </div>

                    {/* Executor + step id */}
                    <div className="flex items-center gap-1 mt-0.5 pl-5">
                      <ExecIcon size={9} className="shrink-0 text-muted-foreground" />
                      <span className="forgis-text-caption text-muted-foreground font-forgis-body">{step.executor}</span>
                      <span className="forgis-text-caption text-muted-foreground/40 mx-0.5">|</span>
                      <span className="forgis-text-caption text-muted-foreground/60 font-forgis-body truncate">{step.id}</span>
                    </div>

                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </div>
      <Handle
        type="source"
        position={Position.Bottom}
        id="bottom"
        className="!w-2 !h-2 !border !border-solid"
            style={{ background: "var(--handle-bg)", borderColor: "var(--handle-border)" }}
      />
    </>
  );
}

// Defined outside component to avoid re-renders
export const nodeTypes = { execution: ExecutionNode };



================================================
FILE: frontend/src/components/flow/FlowAutoFit.tsx
================================================
import { useEffect } from "react";
import { useReactFlow } from "@xyflow/react";

export function FlowAutoFit({ flowId }: { flowId: string | undefined }) {
  const { fitView } = useReactFlow();
  useEffect(() => {
    fitView({ padding: 0.3, maxZoom: 0.85, duration: 0 });
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [flowId]);
  return null;
}



================================================
FILE: frontend/src/components/flow/FlowAutoFollow.tsx
================================================
import { useEffect } from "react";
import { useReactFlow } from "@xyflow/react";
import type { NodeExecState, FlowExecStatus } from "@/types";

export function FlowAutoFollow({
  nodeStates,
  flowStatus,
}: {
  nodeStates: Record<string, NodeExecState>;
  flowStatus: FlowExecStatus;
}) {
  const { setCenter, getNode } = useReactFlow();

  useEffect(() => {
    if (flowStatus !== "running" && flowStatus !== "paused") return;

    const runningId = Object.keys(nodeStates).find(
      (id) => nodeStates[id].status === "running",
    );
    if (!runningId) return;

    const node = getNode(runningId);
    if (!node) return;

    const x = node.position.x + (node.measured?.width ?? 280) / 2;
    const y = node.position.y + (node.measured?.height ?? 120) / 2;
    setCenter(x, y, { zoom: 1.1, duration: 600 });
  }, [nodeStates, flowStatus, setCenter, getNode]);

  return null;
}



================================================
FILE: frontend/src/components/flow/FlowCanvas.tsx
================================================
import { useEffect } from "react";
import {
  ReactFlow,
  useNodesState,
  useEdgesState,
  Background,
  BackgroundVariant,
  type Edge,
} from "@xyflow/react";
import "@xyflow/react/dist/style.css";
import { Plus } from "lucide-react";
import { ContentPanel } from "@/components/layout/ContentPanel";
import { FlowControls } from "./FlowControls";
import { FlowAutoFit } from "./FlowAutoFit";
import { FlowAutoFollow } from "./FlowAutoFollow";
import { nodeTypes } from "./ExecutionNode";
import type {
  Flow as FlowType,
  FlowStep,
  FlowExecStatus,
  NodeExecState,
} from "@/types";
import {
  toReactFlowNodes,
  toReactFlowEdges,
  updateEdgeStyles,
  type ExecNode,
} from "@/services/flowTransformService";

interface FlowCanvasProps {
  flow: FlowType | null;
  flowStatus: FlowExecStatus;
  nodeStates: Record<string, NodeExecState>;
  onStart: () => void;
  onPause: () => void;
  onResume: () => void;
  onFinish: () => void;
  finishing: boolean;
  onReset: () => void;
  onSelectStep?: (nodeId: string, step: FlowStep) => void;
  onAddNode?: () => void;
}

export function FlowCanvas({
  flow,
  flowStatus,
  nodeStates,
  onStart,
  onPause,
  onResume,
  onFinish,
  finishing,
  onReset,
  onSelectStep,
  onAddNode,
}: FlowCanvasProps) {
  const [nodes, setNodes, onNodesChange] = useNodesState<ExecNode>([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState<Edge>([]);

  // Sync flow data → React Flow state (only when flow changes)
  useEffect(() => {
    if (!flow) {
      setNodes([
        {
          id: "welcome",
          type: "execution" as const,
          position: { x: 0, y: 0 },
          draggable: false,
          selectable: false,
          data: {
            label: "Welcome",
            nodeType: "default",
            nodeId: "welcome",
            message: "Generate a flow to get started.",
            execState: undefined,
            flowStatus: "idle" as const,
          },
        },
      ]);
      setEdges([]);
      return;
    }

    setNodes(toReactFlowNodes(flow, nodeStates, flowStatus, onSelectStep));
    setEdges(toReactFlowEdges(flow));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [flow]);

  // Update execution state on nodes + edge styling
  useEffect(() => {
    setNodes((nds) =>
      nds.map((n) => ({
        ...n,
        data: {
          ...n.data,
          execState: nodeStates[n.id],
          flowStatus,
        },
      })),
    );
    setEdges((eds) => updateEdgeStyles(eds, nodeStates, flowStatus));
  }, [nodeStates, flowStatus, setNodes, setEdges]);

  return (
    <ContentPanel
      title="Flow"
      className="h-full"
      contentClassName="p-0"
      scrollable={false}
      centerActions={
        flow ? (
          <FlowControls
            flowStatus={flowStatus}
            finishing={finishing}
            onStart={onStart}
            onPause={onPause}
            onResume={onResume}
            onFinish={onFinish}
            onReset={onReset}
          />
        ) : undefined
      }
      actions={
        flow ? (
          <button
            onClick={onAddNode}
            className="flex items-center justify-center w-7 h-7 rounded-md border border-border forgis-text-label font-normal text-foreground cursor-pointer hover:bg-muted/60 transition-colors"
            title="Add node"
          >
            <Plus size={14} />
          </button>
        ) : undefined
      }
    >
      <div className="relative w-full h-full">
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          nodeTypes={nodeTypes}
          defaultEdgeOptions={{ type: "smoothstep" }}
          fitView
          fitViewOptions={{ padding: 0.3, maxZoom: 0.85 }}
          minZoom={0.2}
          maxZoom={2}
          proOptions={{ hideAttribution: true }}
        >
          <Background
            variant={BackgroundVariant.Dots}
            gap={16}
            size={1}
            color="var(--dot-grid-color)"
          />
          <FlowAutoFit flowId={flow?.id} />
          <FlowAutoFollow nodeStates={nodeStates} flowStatus={flowStatus} />
        </ReactFlow>
      </div>
    </ContentPanel>
  );
}



================================================
FILE: frontend/src/components/flow/FlowControls.tsx
================================================
import { Play, Pause, Flag, RotateCcw, Loader2 } from "lucide-react";
import type { FlowExecStatus } from "@/types";

interface FlowControlsProps {
  flowStatus: FlowExecStatus;
  finishing: boolean;
  onStart: () => void;
  onPause: () => void;
  onResume: () => void;
  onFinish: () => void;
  onReset: () => void;
}

export function FlowControls({
  flowStatus,
  finishing,
  onStart,
  onPause,
  onResume,
  onFinish,
  onReset,
}: FlowControlsProps) {
  return (
    <div className="flex items-center gap-2">
      {flowStatus === "idle" && (
        <button
          onClick={onStart}
          className="flex items-center gap-1.5 px-3 py-1.5 rounded-md bg-primary text-white forgis-text-label font-normal font-forgis-digit cursor-pointer border-none hover:bg-[var(--accent-hover)]"
        >
          <Play size={12} /> Run
        </button>
      )}

      {flowStatus === "running" && (
        <>
          <button
            onClick={onPause}
            className="flex items-center gap-1.5 px-3 py-1.5 rounded-md bg-muted text-foreground forgis-text-label font-normal font-forgis-digit cursor-pointer border-none hover:bg-muted/70"
          >
            <Pause size={12} /> Pause
          </button>
          {finishing ? (
            <span className="flex items-center gap-1.5 px-3 py-1.5 rounded-md bg-muted text-muted-foreground forgis-text-label font-normal font-forgis-digit">
              <Loader2 size={12} className="animate-spin" /> Finishing…
            </span>
          ) : (
            <button
              onClick={onFinish}
              className="flex items-center gap-1.5 px-3 py-1.5 rounded-md bg-muted text-foreground forgis-text-label font-normal font-forgis-digit cursor-pointer border-none hover:bg-muted/70"
            >
              <Flag size={12} /> Finish
            </button>
          )}
        </>
      )}

      {flowStatus === "paused" && (
        <>
          <button
            onClick={onResume}
            className="flex items-center gap-1.5 px-3 py-1.5 rounded-md bg-primary text-white forgis-text-label font-normal font-forgis-digit cursor-pointer border-none hover:bg-[var(--accent-hover)]"
          >
            <Play size={12} /> Resume
          </button>
          {finishing ? (
            <span className="flex items-center gap-1.5 px-3 py-1.5 rounded-md bg-muted text-muted-foreground forgis-text-label font-normal font-forgis-digit">
              <Loader2 size={12} className="animate-spin" /> Finishing…
            </span>
          ) : (
            <button
              onClick={onFinish}
              className="flex items-center gap-1.5 px-3 py-1.5 rounded-md bg-muted text-foreground forgis-text-label font-normal font-forgis-digit cursor-pointer border-none hover:bg-muted/70"
            >
              <Flag size={12} /> Finish
            </button>
          )}
        </>
      )}

      {flowStatus === "completed" && (
        <>
          <button
            onClick={onReset}
            className="flex items-center gap-1.5 px-3 py-1.5 rounded-md bg-muted text-foreground forgis-text-label font-normal font-forgis-digit cursor-pointer border-none hover:bg-muted/70"
          >
            <RotateCcw size={12} /> Reset
          </button>
          <button
            onClick={onStart}
            className="flex items-center gap-1.5 px-3 py-1.5 rounded-md bg-primary text-white forgis-text-label font-normal font-forgis-digit cursor-pointer border-none hover:bg-[var(--accent-hover)] whitespace-nowrap"
          >
            <Play size={12} /> Re-run
          </button>
        </>
      )}

      {flowStatus !== "idle" && (
        <span className="forgis-text-detail text-muted-foreground uppercase tracking-wider ml-2 font-forgis-digit">
          {flowStatus}
        </span>
      )}
    </div>
  );
}



================================================
FILE: frontend/src/components/layout/ContentPanel.tsx
================================================
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { cn } from '@/lib/utils';
import type { ContentPanelProps } from '@/types/index';

/**
 * Generic content panel wrapper with consistent header styling.
 * Matches Figma design: white bg, subtle #f1f5f7 border, 10px rounded.
 */
export function ContentPanel({
  title,
  subtitle,
  actions,
  centerActions,
  children,
  className,
  contentClassName,
  scrollable = true,
}: ContentPanelProps) {
  return (
    <Card
      className={cn(
        'flex flex-col overflow-hidden py-0 gap-0',
        'bg-card border border-border rounded-[10px]',
        className
      )}
    >
      <CardHeader className="relative flex-shrink-0 flex flex-row items-center justify-between gap-4 pt-4 pb-4 px-6">
        <div className="flex flex-col gap-1 shrink-0">
          <CardTitle className="forgis-text-title font-normal uppercase text-[var(--gunmetal-50)] leading-none font-forgis-digit">
            {title}
          </CardTitle>
          {subtitle && (
            <span className="forgis-text-detail text-[var(--gunmetal-50)] font-forgis-body leading-tight">
              {subtitle}
            </span>
          )}
        </div>
        {centerActions && (
          <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 flex items-center gap-2">
            {centerActions}
          </div>
        )}
        {actions ? <div className="flex items-center gap-2 shrink-0">{actions}</div> : <div />}
      </CardHeader>
      <CardContent className={cn(
        'flex-1 px-6 pb-4 pt-0',
        scrollable ? 'overflow-auto' : 'overflow-hidden',
        contentClassName
      )}>
        {children}
      </CardContent>
    </Card>
  );
}



================================================
FILE: frontend/src/components/layout/Topbar.tsx
================================================
import { Link } from 'react-router-dom';
import { Bell, Settings, User } from 'lucide-react';
import { cn } from '@/lib/utils';

interface TopBarProps {
  className?: string;
}

/**
 * Global app header with Forgis branding and utility icons.
 * Matches Figma: 32px height, 12px icons, dark gunmetal background.
 * Logo click navigates back to Factory View (homepage).
 */
export function TopBar({ className }: TopBarProps) {
  return (
    <header
      className={cn(
        'flex items-center justify-between h-8 px-4',
        'bg-[var(--gunmetal)]',
        className
      )}
    >
      {/* Left side - Logo (icon + wordmark) - links to Factory View */}
      <Link to="/" className="flex items-center hover:opacity-80 transition-opacity">
        <img
          src="/logo-wordmark.png"
          alt="Forgis"
          className="h-[17px] w-auto"
        />
      </Link>

      {/* Right side - Utility icons (placeholders) */}
      <div className="flex items-center gap-3">
        <button
          type="button"
          className="p-1 hover:opacity-80 transition-opacity"
          aria-label="Notifications"
        >
          <Bell size={12} className="text-white" />
        </button>
        <button
          type="button"
          className="p-1 hover:opacity-80 transition-opacity"
          aria-label="Settings"
        >
          <Settings size={12} className="text-white" />
        </button>
        <button
          type="button"
          className="p-1 hover:opacity-80 transition-opacity"
          aria-label="User profile"
        >
          <User size={12} className="text-white" />
        </button>
      </div>
    </header>
  );
}



================================================
FILE: frontend/src/components/ui/badge.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-full border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }



================================================
FILE: frontend/src/components/ui/breadcrumb.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

function Breadcrumb({ ...props }: React.ComponentProps<"nav">) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<"ol">) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        "text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5",
        className
      )}
      {...props}
    />
  )
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-item"
      className={cn("inline-flex items-center gap-1.5", className)}
      {...props}
    />
  )
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="breadcrumb-link"
      className={cn("hover:text-foreground transition-colors", className)}
      {...props}
    />
  )
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("text-foreground font-normal", className)}
      {...props}
    />
  )
}

function BreadcrumbSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn("[&>svg]:size-3.5", className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  )
}

function BreadcrumbEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  )
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}



================================================
FILE: frontend/src/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant = "default",
  size = "default",
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      data-variant={variant}
      data-size={size}
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
FILE: frontend/src/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}



================================================
FILE: frontend/src/components/ui/chart.tsx
================================================
// @ts-nocheck
import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

function ChartContainer({
  id,
  className,
  children,
  config,
  ...props
}: React.ComponentProps<"div"> & {
  config: ChartConfig
  children: React.ComponentProps<
    typeof RechartsPrimitive.ResponsiveContainer
  >["children"]
}) {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-slot="chart"
        data-chart={chartId}
        className={cn(
          "[&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border flex aspect-video justify-center text-xs [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-hidden [&_.recharts-sector]:outline-hidden [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-surface]:outline-hidden",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
}

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

function ChartTooltipContent({
  active,
  payload,
  className,
  indicator = "dot",
  hideLabel = false,
  hideIndicator = false,
  label,
  labelFormatter,
  labelClassName,
  formatter,
  color,
  nameKey,
  labelKey,
}: React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
  React.ComponentProps<"div"> & {
    hideLabel?: boolean
    hideIndicator?: boolean
    indicator?: "line" | "dot" | "dashed"
    nameKey?: string
    labelKey?: string
  }) {
  const { config } = useChart()

  const tooltipLabel = React.useMemo(() => {
    if (hideLabel || !payload?.length) {
      return null
    }

    const [item] = payload
    const key = `${labelKey || item?.dataKey || item?.name || "value"}`
    const itemConfig = getPayloadConfigFromPayload(config, item, key)
    const value =
      !labelKey && typeof label === "string"
        ? config[label as keyof typeof config]?.label || label
        : itemConfig?.label

    if (labelFormatter) {
      return (
        <div className={cn("font-medium", labelClassName)}>
          {labelFormatter(value, payload)}
        </div>
      )
    }

    if (!value) {
      return null
    }

    return <div className={cn("font-medium", labelClassName)}>{value}</div>
  }, [
    label,
    labelFormatter,
    payload,
    hideLabel,
    labelClassName,
    config,
    labelKey,
  ])

  if (!active || !payload?.length) {
    return null
  }

  const nestLabel = payload.length === 1 && indicator !== "dot"

  return (
    <div
      className={cn(
        "border-border/50 bg-background grid min-w-[8rem] items-start gap-1.5 rounded-lg border px-2.5 py-1.5 text-xs shadow-xl",
        className
      )}
    >
      {!nestLabel ? tooltipLabel : null}
      <div className="grid gap-1.5">
        {payload
          .filter((item) => item.type !== "none")
          .map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-(--color-border) bg-(--color-bg)",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="text-foreground font-mono font-medium tabular-nums">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
      </div>
    </div>
  )
}

const ChartLegend = RechartsPrimitive.Legend

function ChartLegendContent({
  className,
  hideIcon = false,
  payload,
  verticalAlign = "bottom",
  nameKey,
}: React.ComponentProps<"div"> &
  Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
    hideIcon?: boolean
    nameKey?: string
  }) {
  const { config } = useChart()

  if (!payload?.length) {
    return null
  }

  return (
    <div
      className={cn(
        "flex items-center justify-center gap-4",
        verticalAlign === "top" ? "pb-3" : "pt-3",
        className
      )}
    >
      {payload
        .filter((item) => item.type !== "none")
        .map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "[&>svg]:text-muted-foreground flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
    </div>
  )
}

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}



================================================
FILE: frontend/src/components/ui/dialog.tsx
================================================
import * as React from "react"
import { XIcon } from "lucide-react"
import { Dialog as DialogPrimitive } from "radix-ui"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 outline-none",
          // Default to max-w-lg if no custom max-width is provided
          !className?.includes('max-w-') && 'sm:max-w-lg',
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({
  className,
  showCloseButton = false,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  showCloseButton?: boolean
}) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    >
      {children}
      {showCloseButton && (
        <DialogPrimitive.Close asChild>
          <Button variant="outline">Close</Button>
        </DialogPrimitive.Close>
      )}
    </div>
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}



================================================
FILE: frontend/src/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }



================================================
FILE: frontend/src/components/ui/label.tsx
================================================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }



================================================
FILE: frontend/src/components/ui/scroll-area.tsx
================================================
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }



================================================
FILE: frontend/src/components/ui/select.tsx
================================================
import * as React from "react"
import { Select as SelectPrimitive } from "radix-ui"
import { CheckIcon, ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({ ...props }: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger>) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 dark:bg-input/30 flex h-9 w-full items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm shadow-xs outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-[min(24rem,var(--radix-select-content-available-height))] min-w-[8rem] overflow-hidden rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex w-full cursor-default select-none items-center gap-2 rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="absolute left-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-3.5" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

export { Select, SelectContent, SelectItem, SelectTrigger, SelectValue }



================================================
FILE: frontend/src/components/ui/separator.tsx
================================================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }



================================================
FILE: frontend/src/components/ui/sonner.tsx
================================================
import {
  CircleCheckIcon,
  InfoIcon,
  Loader2Icon,
  OctagonXIcon,
  TriangleAlertIcon,
} from "lucide-react"
import { Toaster as Sonner, type ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  return (
    <Sonner
      theme="dark"
      className="toaster group"
      icons={{
        success: <CircleCheckIcon className="size-4" />,
        info: <InfoIcon className="size-4" />,
        warning: <TriangleAlertIcon className="size-4" />,
        error: <OctagonXIcon className="size-4" />,
        loading: <Loader2Icon className="size-4 animate-spin" />,
      }}
      style={
        {
          "--normal-bg": "var(--panel)",
          "--normal-text": "var(--foreground)",
          "--normal-border": "var(--border-default)",
          "--border-radius": "8px",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }



================================================
FILE: frontend/src/components/ui/tabs.tsx
================================================
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
FILE: frontend/src/components/ui/tooltip.tsx
================================================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-[var(--tooltip-bg)] text-[var(--tooltip-text)] border border-[var(--border-subtle)] animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs shadow-lg whitespace-nowrap",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-[var(--tooltip-bg)] fill-[var(--tooltip-bg)] z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }



================================================
FILE: frontend/src/constants/cameraConfig.ts
================================================
/** Maximum items per container displayed in the station map. */
export const CONTAINER_CAPACITY = 25;

/** Zone display labels for the pick-and-place flow. */
export const ZONE_LABELS_V2: Record<string, string> = {
  Zone_A: "MXP-30",
  Zone_B: "MXP Speed",
  Zone_C: "MXP Torque",
};



================================================
FILE: frontend/src/constants/chatConfig.ts
================================================
/** Maximum height in pixels for the auto-growing chat textarea. */
export const CHAT_TEXTAREA_MAX_HEIGHT = 120;



================================================
FILE: frontend/src/constants/deviceConfig.ts
================================================
import { Activity, Bot, Eye } from "lucide-react";
import type { DeviceType, DeviceStatus, Device } from "@/types";

// ── Icon mapping ─────────────────────────────────────────────

export const DEVICE_ICONS: Record<DeviceType, React.ComponentType<{ className?: string }>> = {
  robot: Bot,
  camera: Eye,
  sensor: Activity,
};

// ── Status display ───────────────────────────────────────────

export const STATUS_COLOR: Record<DeviceStatus, string> = {
  connected: "var(--status-healthy)",
  warning: "var(--orange)",
  disconnected: "var(--status-critical)",
};

export const STATUS_LABEL: Record<DeviceStatus, string> = {
  connected: "Connected",
  warning: "Warning",
  disconnected: "Offline",
};

// ── Vendor brands per device type ────────────────────────────

export const BRANDS: Record<DeviceType, string[]> = {
  robot: ["Universal Robots", "ABB", "KUKA", "Fanuc", "Yaskawa", "Doosan"],
  camera: ["Intel RealSense", "Cognex", "Keyence", "Basler", "Sick", "Allied Vision"],
  sensor: ["Sick", "Pepperl+Fuchs", "Banner Engineering", "ifm", "Balluff"],
};

// ── Default devices (pre-populated) ─────────────────────────

export const DEFAULT_DEVICES: Device[] = [
  {
    id: "robot-default",
    name: "UR3",
    vendor: "Universal Robots",
    type: "robot",
    status: "disconnected",
    ip: "192.168.0.101",
  },
  {
    id: "cam-default",
    name: "RealSense D435",
    vendor: "Intel",
    type: "camera",
    status: "disconnected",
    ip: "localhost:8765",
  },
];

// ── Add-device form state ────────────────────────────────────

export interface DeviceFormData {
  type: DeviceType | "";
  brand: string;
  robotModel: string;
  name: string;
  apiEndpoint: string;
}

export const EMPTY_FORM: DeviceFormData = {
  type: "",
  brand: "",
  robotModel: "",
  name: "",
  apiEndpoint: "",
};



================================================
FILE: frontend/src/constants/executorConfig.ts
================================================
import { Bot, Cpu, Eye } from "lucide-react";
import type { NodeCreatorState } from "@/types";

// ── Executor icon mapping (used in flow nodes) ──────────────

export const EXECUTOR_ICONS: Record<string, React.ComponentType<{ size?: number; className?: string }>> = {
  robot: Bot,
  camera: Eye,
  io_robot: Cpu,
};

// ── Node creator config ─────────────────────────────────────

export const NODE_TYPES = [
  { value: "robot_action", label: "Robot Action" },
  { value: "computer_vision", label: "Computer Vision" },
  { value: "sensors", label: "Sensors" },
] as const;

export const TASKS = [
  { value: "object_tracking", label: "Object Tracking" },
  { value: "classification", label: "Classification" },
  { value: "object_detection", label: "Object Detection" },
] as const;

export const EMPTY_CREATOR: NodeCreatorState = { nodeType: null, task: null, label: "" };



================================================
FILE: frontend/src/hooks/useCamera.ts
================================================
import { useMemo, useRef, useState } from "react";
import type { BoundingBox, BoundingBoxOverlay } from "@/types";

export interface CameraCallbacks {
  onFrame: (frame: string, timestamp: number) => void;
  onBbox: (bbox: BoundingBox, frameWidth: number, frameHeight: number, durationMs: number) => void;
  onLabel: (label: string) => void;
  /** Called on flow_completed / aborted / error — clears the live frame only. */
  onStreamStop: () => void;
  /** Called on resetFlow — clears all camera state (frame, labels, bbox). */
  onReset: () => void;
}

export function useCamera() {
  const [cameraFrame, setCameraFrame] = useState<string | null>(null);
  const [lastLabel, setLastLabel] = useState<{ label: string; version: number } | null>(null);
  const [bboxOverlay, setBboxOverlay] = useState<BoundingBoxOverlay | null>(null);

  const lastFrameTimestampRef = useRef(0);
  const labelVersionRef = useRef(0);
  const bboxTimerRef = useRef<number | null>(null);

  const callbacks: CameraCallbacks = useMemo(() => ({
    onFrame: (frame: string, timestamp: number) => {
      if (timestamp > lastFrameTimestampRef.current) {
        lastFrameTimestampRef.current = timestamp;
        setCameraFrame(`data:image/jpeg;base64,${frame}`);
      }
    },

    onBbox: (bbox: BoundingBox, frameWidth: number, frameHeight: number, durationMs: number) => {
      if (bboxTimerRef.current) {
        window.clearTimeout(bboxTimerRef.current);
      }

      setBboxOverlay({
        bbox,
        frameWidth,
        frameHeight,
        expiresAt: Date.now() + durationMs,
      });

      bboxTimerRef.current = window.setTimeout(() => {
        setBboxOverlay(null);
        bboxTimerRef.current = null;
      }, durationMs);
    },

    onLabel: (label: string) => {
      labelVersionRef.current += 1;
      setLastLabel({ label, version: labelVersionRef.current });
    },

    onStreamStop: () => {
      setCameraFrame(null);
    },

    onReset: () => {
      setCameraFrame(null);
      setLastLabel(null);
      if (bboxTimerRef.current) {
        window.clearTimeout(bboxTimerRef.current);
        bboxTimerRef.current = null;
      }
      setBboxOverlay(null);
      lastFrameTimestampRef.current = 0;
    },
  }), []);

  return { cameraFrame, lastLabel, bboxOverlay, callbacks };
}



================================================
FILE: frontend/src/hooks/useFlowExecution.ts
================================================
import { useCallback, useEffect, useRef, useState } from "react";
import {
  startFlow as apiStartFlow,
  abortFlow as apiAbortFlow,
  pauseFlow as apiPauseFlow,
  resumeFlow as apiResumeFlow,
  finishFlow as apiFinishFlow,
} from "@/api/flowApi";
import { createFlowSocket } from "@/api/flowSocket";
import { startCameraStream, stopCameraStream } from "@/api/cameraApi";
import { findStateForStep } from "@/services/flowTransformService";
import type { CameraCallbacks } from "./useCamera";
import type {
  Flow,
  FlowExecStatus,
  NodeExecState,
  ServerMessage,
  StepExecState,
} from "@/types";

export function useFlowExecution(
  flow: Flow | null,
  camera: CameraCallbacks,
) {
  const [flowStatus, setFlowStatus] = useState<FlowExecStatus>("idle");
  const [nodeStates, setNodeStates] = useState<Record<string, NodeExecState>>({});
  const [finishing, setFinishing] = useState(false);

  const socketRef = useRef<{ close: () => void } | null>(null);
  const handleMessageRef = useRef<(msg: ServerMessage) => void>(() => {});

  // ── WebSocket Event Handling ────────────────────────────────

  const handleMessage = useCallback(
    (msg: ServerMessage) => {
      switch (msg.type) {
        case "connected":
          break;

        case "flow_started":
          setFlowStatus("running");
          break;

        case "flow_completed":
          setFlowStatus("completed");
          setFinishing(false);
          stopCameraStream();
          camera.onStreamStop();
          break;

        case "flow_aborted":
          setFlowStatus("idle");
          setFinishing(false);
          stopCameraStream();
          camera.onStreamStop();
          break;

        case "flow_paused":
          setFlowStatus("paused");
          break;

        case "flow_resumed":
          setFlowStatus("running");
          break;

        case "flow_error":
          setFlowStatus("error");
          stopCameraStream();
          camera.onStreamStop();
          console.error("[ws] Flow error:", msg.error);
          break;

        case "loop_restart":
          if (flow) {
            const reset: Record<string, NodeExecState> = {};
            for (const node of flow.nodes) {
              reset[node.id] = { status: "idle", stepStates: {} };
            }
            setNodeStates(reset);
          }
          break;

        case "state_entered":
          setNodeStates((prev) => ({
            ...prev,
            [msg.state]: {
              ...prev[msg.state],
              status: "running",
            },
          }));
          break;

        case "state_completed":
          setNodeStates((prev) => ({
            ...prev,
            [msg.state]: {
              ...prev[msg.state],
              status: "success",
            },
          }));
          break;

        case "waiting_condition":
          break;

        case "step_started": {
          if (!flow) break;
          const stateId = findStateForStep(flow, msg.step_id);
          if (stateId) {
            setNodeStates((prev) => {
              const nodeState = prev[stateId] || { status: "running", stepStates: {} };
              const stepStates: Record<string, StepExecState> = {
                ...(nodeState.stepStates || {}),
                [msg.step_id]: { status: "running" },
              };
              return {
                ...prev,
                [stateId]: {
                  ...nodeState,
                  status: "running",
                  currentStep: msg.step_id,
                  stepStates,
                },
              };
            });
          }
          break;
        }

        case "step_completed": {
          // Capture label from get_label skill results
          if (msg.result?.label && typeof msg.result.label === "string") {
            camera.onLabel(msg.result.label);
          }

          if (!flow) break;
          const stateId = findStateForStep(flow, msg.step_id);
          if (stateId) {
            setNodeStates((prev) => {
              const nodeState = prev[stateId] || { status: "running", stepStates: {} };
              const stepStates: Record<string, StepExecState> = {
                ...(nodeState.stepStates || {}),
                [msg.step_id]: { status: "success", retries: msg.retries, result: msg.result },
              };
              return {
                ...prev,
                [stateId]: {
                  ...nodeState,
                  stepStates,
                },
              };
            });
          }
          break;
        }

        case "step_error": {
          if (!flow) break;
          const stateId = findStateForStep(flow, msg.step_id);
          if (stateId) {
            setNodeStates((prev) => {
              const nodeState = prev[stateId] || { status: "running", stepStates: {} };
              const stepStates: Record<string, StepExecState> = {
                ...(nodeState.stepStates || {}),
                [msg.step_id]: { status: "failure", error: msg.error },
              };
              return {
                ...prev,
                [stateId]: {
                  ...nodeState,
                  status: "failure",
                  stepStates,
                },
              };
            });
          }
          break;
        }

        case "step_retry":
          break;

        case "step_skipped":
          break;

        case "camera_frame":
          camera.onFrame(msg.frame, msg.timestamp);
          break;

        case "bounding_box":
          camera.onBbox(msg.bbox, msg.frame_width, msg.frame_height, msg.display_duration_ms);
          break;
      }
    },
    [flow, camera]
  );

  // Keep ref updated with latest handleMessage to avoid stale closures in WebSocket
  useEffect(() => {
    handleMessageRef.current = handleMessage;
  }, [handleMessage]);

  // ── WebSocket connection ────────────────────────────────────

  const connectWebSocket = useCallback(async () => {
    if (socketRef.current) return;
    socketRef.current = await createFlowSocket(
      (msg) => handleMessageRef.current(msg),
      () => { socketRef.current = null; }
    );
  }, []);

  // ── Reset execution state when a new flow is generated ──────

  useEffect(() => {
    socketRef.current?.close();
    socketRef.current = null;

    if (flow) {
      const initial: Record<string, NodeExecState> = {};
      for (const node of flow.nodes) {
        initial[node.id] = { status: "idle", stepStates: {} };
      }
      setNodeStates(initial);
    } else {
      setNodeStates({});
    }
    setFlowStatus("idle");
  }, [flow]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      socketRef.current?.close();
    };
  }, []);

  // ── Flow control functions ──────────────────────────────────

  const startFlow = useCallback(async () => {
    if (!flow) return;

    const initial: Record<string, NodeExecState> = {};
    for (const node of flow.nodes) {
      initial[node.id] = { status: "idle", stepStates: {} };
    }
    setNodeStates(initial);
    setFinishing(false);

    await connectWebSocket();
    try {
      await startCameraStream(15);
    } catch (err) {
      console.warn("Camera stream unavailable, starting flow without camera:", err);
    }
    await apiStartFlow(flow.id);
  }, [flow, connectWebSocket]);

  const pauseFlow = useCallback(async () => {
    try {
      await apiPauseFlow();
    } catch (err) {
      console.error("Failed to pause flow:", err);
    }
  }, []);

  const resumeFlow = useCallback(async () => {
    try {
      await apiResumeFlow();
    } catch (err) {
      console.error("Failed to resume flow:", err);
    }
  }, []);

  const abortFlow = useCallback(async () => {
    try {
      await apiAbortFlow();
    } catch (err) {
      console.error("Failed to abort flow:", err);
    }
    setFlowStatus("idle");
  }, []);

  const finishFlow = useCallback(async () => {
    setFinishing(true);
    try {
      await apiFinishFlow();
    } catch (err) {
      console.error("Failed to finish flow:", err);
    }
  }, []);

  const resetFlow = useCallback(async () => {
    setFinishing(false);
    socketRef.current?.close();
    socketRef.current = null;

    await stopCameraStream();
    camera.onReset(); // clears frame, labels, QC, bbox

    if (flow) {
      const initial: Record<string, NodeExecState> = {};
      for (const node of flow.nodes) {
        initial[node.id] = { status: "idle", stepStates: {} };
      }
      setNodeStates(initial);
    }
    setFlowStatus("idle");
  }, [flow, camera]);

  return {
    flowStatus,
    nodeStates,
    finishing,
    startFlow,
    pauseFlow,
    resumeFlow,
    abortFlow,
    finishFlow,
    resetFlow,
  };
}



================================================
FILE: frontend/src/hooks/useFlowGeneration.ts
================================================
import { useCallback, useState } from "react";
import { generateFlow } from "@/api/flowApi";
import { layoutFlow } from "@/services/flowLayoutService";
import type { ChatMessage, Flow } from "@/types";

export function useFlowGeneration() {
  const [flow, setFlow] = useState<Flow | null>(null);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [loading, setLoading] = useState(false);

  const sendMessage = useCallback(async (content: string) => {
    const userMsg: ChatMessage = {
      id: crypto.randomUUID(),
      role: "user",
      content,
      timestamp: Date.now(),
    };
    setMessages((prev) => [...prev, userMsg]);
    setLoading(true);

    try {
      const result = await generateFlow(content);
      setFlow(layoutFlow(result));

      const assistantMsg: ChatMessage = {
        id: crypto.randomUUID(),
        role: "assistant",
        content: `Flow generated with ${result.nodes.length} nodes and ${result.edges.length} edges.`,
        timestamp: Date.now(),
      };
      setMessages((prev) => [...prev, assistantMsg]);
    } catch (err) {
      const errorMsg: ChatMessage = {
        id: crypto.randomUUID(),
        role: "assistant",
        content: `Error: ${err instanceof Error ? err.message : "Unknown error"}`,
        timestamp: Date.now(),
      };
      setMessages((prev) => [...prev, errorMsg]);
    } finally {
      setLoading(false);
    }
  }, []);

  const updateStepParams = useCallback(
    (nodeId: string, stepId: string, params: Record<string, unknown>) => {
      setFlow((prev) => {
        if (!prev) return prev;
        return {
          ...prev,
          nodes: prev.nodes.map((node) =>
            node.id === nodeId
              ? {
                  ...node,
                  steps: node.steps?.map((s) =>
                    s.id === stepId ? { ...s, params } : s
                  ),
                }
              : node
          ),
        };
      });
    },
    []
  );

  return { flow, messages, loading, sendMessage, updateStepParams };
}



================================================
FILE: frontend/src/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



================================================
FILE: frontend/src/pages/RobotControlPage.tsx
================================================
import { useState } from "react";
import { TopBar } from "@/components/layout/Topbar";
import { CoderSidebar } from "@/components/chat/CoderSidebar";
import { FlowCanvas } from "@/components/flow/FlowCanvas";
import { CameraFeed } from "@/components/camera/CameraFeed";
import { DevicesSidebar } from "@/components/devices/DevicesSidebar";
import {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbSeparator,
  BreadcrumbPage,
} from "@/components/ui/breadcrumb";
import { useFlowGeneration } from "@/hooks/useFlowGeneration";
import { useCamera } from "@/hooks/useCamera";
import { useFlowExecution } from "@/hooks/useFlowExecution";
import type { SelectedStep } from "@/types";

export function RobotControlPage() {
  const { flow, messages, loading, sendMessage, updateStepParams } = useFlowGeneration();
  const { cameraFrame, lastLabel, bboxOverlay, callbacks: cameraCallbacks } = useCamera();
  const { flowStatus, nodeStates, finishing, startFlow, pauseFlow, resumeFlow, finishFlow, resetFlow } = useFlowExecution(flow, cameraCallbacks);

  const [selectedStep, setSelectedStep] = useState<SelectedStep | null>(null);
  const [nodeCreatorOpen, setNodeCreatorOpen] = useState(false);

  return (
    <div className="flex flex-col h-screen overflow-hidden bg-background">
      <TopBar />
      <div className="flex items-center px-4 py-1.5 border-b border-border bg-card/80 backdrop-blur-panel">
        <Breadcrumb>
          <BreadcrumbList>
            <BreadcrumbItem>
              <BreadcrumbLink href="/" className="forgis-text-label font-forgis-body text-[var(--gunmetal-50)] no-underline">
                Forgis Factory
              </BreadcrumbLink>
            </BreadcrumbItem>
            <BreadcrumbSeparator />
            <BreadcrumbItem>
              <BreadcrumbLink href="/" className="forgis-text-label font-forgis-body text-[var(--gunmetal-50)] no-underline">
                Line 1
              </BreadcrumbLink>
            </BreadcrumbItem>
            <BreadcrumbSeparator />
            <BreadcrumbItem>
              <BreadcrumbPage className="forgis-text-label font-forgis-body text-[var(--gunmetal-50)]">
                Labelling and Sorting
              </BreadcrumbPage>
            </BreadcrumbItem>
          </BreadcrumbList>
        </Breadcrumb>
      </div>
      <div className="flex flex-1 overflow-hidden">
        {/* Left sidebar - Devices (idle) or Camera Feed (active) */}
        {flowStatus === "idle" ? (
          <DevicesSidebar
            selectedStep={selectedStep}
            onDeselectStep={() => setSelectedStep(null)}
            onParamChange={(nodeId, stepId, key, value) => {
              updateStepParams(nodeId, stepId, {
                ...selectedStep?.step.params,
                [key]: value,
              });
              setSelectedStep((prev) =>
                prev
                  ? { ...prev, step: { ...prev.step, params: { ...prev.step.params, [key]: value } } }
                  : prev
              );
            }}
            nodeCreatorOpen={nodeCreatorOpen}
            onCloseNodeCreator={() => setNodeCreatorOpen(false)}
          />
        ) : (
          <CameraFeed frameUrl={cameraFrame} streaming lastLabel={lastLabel} bboxOverlay={bboxOverlay} />
        )}

        {/* Main content area - Flow canvas always visible */}
        <div className="flex flex-1 min-h-0 overflow-hidden p-5 bg-[var(--panel)]">
          <div className="flex-1 min-h-0 min-w-0">
            <FlowCanvas
              flow={flow}
              flowStatus={flowStatus}
              nodeStates={nodeStates}
              onStart={startFlow}
              onPause={pauseFlow}
              onResume={resumeFlow}
              onFinish={finishFlow}
              finishing={finishing}
              onReset={resetFlow}
              onSelectStep={(nodeId, step) => {
                setNodeCreatorOpen(false);
                setSelectedStep({ nodeId, step });
              }}
              onAddNode={() => {
                setSelectedStep(null);
                setNodeCreatorOpen(true);
              }}
            />
          </div>
        </div>

        {/* Right sidebar - Coder (hidden while flow is active) */}
        {flowStatus === "idle" && (
          <CoderSidebar messages={messages} loading={loading} onSend={sendMessage} />
        )}
      </div>
    </div>
  );
}



================================================
FILE: frontend/src/services/flowLayoutService.ts
================================================
import type { Flow, FlowNode, FlowEdge } from "@/types";

// ── Layout constants ─────────────────────────────────────────

const W = 220;       // node width
const HB = 180;      // base node height (header + padding)
const HS = 80;       // additional height per step row
const GAP_X = 40;    // horizontal gap between parallel columns
const GAP_Y = 50;    // vertical gap between consecutive nodes
const START_H = 60;  // start/end node height

// ── Public API ───────────────────────────────────────────────

/**
 * Computes positions and sizes for every node in the flow.
 * Returns a new Flow with updated `position` and `style` fields.
 * Works with any flow shape: linear, branching, looping.
 */
export function layoutFlow(flow: Flow): Flow {
  const { nodes, edges } = flow;

  // Build lookup maps
  const nodeMap = new Map<string, FlowNode>(nodes.map((n) => [n.id, n]));

  // Non-loop edges are the only ones relevant for layout
  const layoutEdges = edges.filter((e) => e.data?.isLoop !== true);

  // Position map: nodeId → { x, y }
  const positions = new Map<string, { x: number; y: number }>();
  // Size map: nodeId → { width, height }
  const sizes = new Map<string, { width: number; height: number }>();

  // Pre-compute sizes for all nodes
  for (const node of nodes) {
    sizes.set(node.id, computeNodeSize(node));
  }

  // Find the start node
  const startNode = nodes.find((n) => n.type === "start");
  if (!startNode) return flow;

  // Layout from start node using recursive column placement
  layoutColumn(startNode.id, 0, 0, nodeMap, layoutEdges, positions, sizes);

  // Center the graph horizontally so the widest point starts at x=0
  centerHorizontally(positions);

  // Build the new nodes with computed positions and sizes
  const layoutNodes = nodes.map((n) => ({
    ...n,
    position: positions.get(n.id) ?? n.position,
    style: sizes.get(n.id),
  }));

  return { ...flow, nodes: layoutNodes };
}

// ── Core layout ──────────────────────────────────────────────

/**
 * Recursively lays out a column of nodes starting from `nodeId`.
 * Returns the total height consumed by this column.
 */
function layoutColumn(
  nodeId: string,
  x: number,
  y: number,
  nodeMap: Map<string, FlowNode>,
  edges: FlowEdge[],
  positions: Map<string, { x: number; y: number }>,
  sizes: Map<string, { width: number; height: number }>,
): number {
  // Skip if already positioned (handles merge points)
  if (positions.has(nodeId)) return 0;

  const node = nodeMap.get(nodeId);
  if (!node) return 0;

  const size = sizes.get(nodeId)!;

  // Center this node horizontally in its column
  positions.set(nodeId, { x: x + (W - size.width) / 2, y });

  let currentY = y + size.height + GAP_Y;

  // Find non-loop outgoing edges
  const outgoing = edges.filter((e) => e.source === nodeId);

  if (outgoing.length === 0) {
    // Terminal node — no children
    return currentY - y;
  }

  if (outgoing.length === 1) {
    // Linear chain — continue downward
    const childHeight = layoutColumn(
      outgoing[0].target, x, currentY, nodeMap, edges, positions, sizes,
    );
    return (currentY - y) + childHeight;
  }

  // Multiple outgoing edges → branching (conditional)
  // Find the merge point where branches converge
  const branchTargets = outgoing.map((e) => e.target);
  const mergeId = findCommonMerge(edges, branchTargets);

  // Count downstream weight for each branch (for proportional column widths)
  const branchWeights = branchTargets.map((target) =>
    countBranchNodes(target, mergeId, nodeMap, edges),
  );
  const totalWeight = branchWeights.reduce((a, b) => a + b, 0) || branchTargets.length;

  // Available width for all branches
  const totalBranchWidth = totalWeight * (W + GAP_X) - GAP_X;

  // Start branches from the left
  let branchX = x + (W - totalBranchWidth) / 2;
  let maxBranchHeight = 0;

  for (let i = 0; i < branchTargets.length; i++) {
    const weight = branchWeights[i] || 1;
    const columnWidth = weight * (W + GAP_X) - GAP_X;
    const columnCenter = branchX + (columnWidth - W) / 2;

    const branchHeight = layoutColumn(
      branchTargets[i], columnCenter, currentY, nodeMap, edges, positions, sizes,
    );

    maxBranchHeight = Math.max(maxBranchHeight, branchHeight);
    branchX += columnWidth + GAP_X;
  }

  currentY += maxBranchHeight;

  // Continue layout from merge point (if found and not already positioned)
  if (mergeId && !positions.has(mergeId)) {
    const mergeHeight = layoutColumn(
      mergeId, x, currentY, nodeMap, edges, positions, sizes,
    );
    return (currentY - y) + mergeHeight;
  }

  return currentY - y;
}

// ── Helper functions ─────────────────────────────────────────

/** Computes the pixel size of a node based on its type and step count. */
function computeNodeSize(node: FlowNode): { width: number; height: number } {
  if (node.type === "start" || node.type === "end") {
    return { width: START_H, height: START_H };
  }
  const stepCount = node.steps?.length ?? 0;
  return { width: W, height: HB + stepCount * HS };
}

/**
 * Counts nodes reachable from `start` up to (but not including) `stopBefore`.
 * Used to weight branch column widths proportionally.
 */
function countBranchNodes(
  start: string,
  stopBefore: string | null,
  nodeMap: Map<string, FlowNode>,
  edges: FlowEdge[],
): number {
  const visited = new Set<string>();
  const queue = [start];

  while (queue.length > 0) {
    const current = queue.shift()!;
    if (visited.has(current)) continue;
    if (current === stopBefore) continue;
    if (!nodeMap.has(current)) continue;
    visited.add(current);

    for (const e of edges) {
      if (e.source === current && !visited.has(e.target)) {
        queue.push(e.target);
      }
    }
  }
  return visited.size;
}

/**
 * Given multiple branch start nodes, finds the first node reachable from
 * ALL of them — the merge point where branches converge.
 * Returns null if no common merge exists (branches never rejoin).
 */
function findCommonMerge(
  edges: FlowEdge[],
  branchTargets: string[],
): string | null {
  if (branchTargets.length < 2) return null;

  // Collect all reachable nodes for each branch
  const reachableSets = branchTargets.map((target) => {
    const reachable = new Set<string>();
    const queue = [target];
    while (queue.length > 0) {
      const current = queue.shift()!;
      if (reachable.has(current)) continue;
      reachable.add(current);
      for (const e of edges) {
        if (e.source === current && !reachable.has(e.target)) {
          queue.push(e.target);
        }
      }
    }
    return reachable;
  });

  // Find nodes reachable from ALL branches
  const common = [...reachableSets[0]].filter((id) =>
    reachableSets.every((set) => set.has(id)),
  );

  if (common.length === 0) return null;

  // Return the closest common node — the one with shortest max distance from any branch
  // BFS distance from each branch target
  const distances = new Map<string, number[]>();
  for (const id of common) {
    distances.set(id, []);
  }

  for (let i = 0; i < branchTargets.length; i++) {
    const dist = new Map<string, number>();
    const queue: [string, number][] = [[branchTargets[i], 0]];
    while (queue.length > 0) {
      const [current, d] = queue.shift()!;
      if (dist.has(current)) continue;
      dist.set(current, d);
      for (const e of edges) {
        if (e.source === current && !dist.has(e.target)) {
          queue.push([e.target, d + 1]);
        }
      }
    }
    for (const id of common) {
      distances.get(id)!.push(dist.get(id) ?? Infinity);
    }
  }

  // Pick the node with the smallest maximum distance (closest merge point)
  let bestId: string | null = null;
  let bestMaxDist = Infinity;
  for (const [id, dists] of distances) {
    const maxDist = Math.max(...dists);
    if (maxDist < bestMaxDist) {
      bestMaxDist = maxDist;
      bestId = id;
    }
  }

  return bestId;
}

/**
 * Centers the entire graph horizontally so that the minimum x position is 0.
 */
function centerHorizontally(positions: Map<string, { x: number; y: number }>) {
  let minX = Infinity;
  for (const pos of positions.values()) {
    if (pos.x < minX) minX = pos.x;
  }
  if (minX !== 0 && minX !== Infinity) {
    for (const pos of positions.values()) {
      pos.x -= minX;
    }
  }
}



================================================
FILE: frontend/src/services/flowTransformService.ts
================================================
import { MarkerType, type Node, type Edge } from "@xyflow/react";
import type {
  Flow,
  FlowStep,
  FlowExecStatus,
  NodeExecState,
  NodeExecStatus,
} from "@/types";

// ── Shared type: data contract between this service and ExecutionNode ──

export type ExecNodeData = {
  label: string;
  steps?: FlowStep[];
  nodeType: string;
  nodeId: string;
  execState: NodeExecState | undefined;
  flowStatus: FlowExecStatus;
  style?: { width: number; height: number };
  message?: string;
  onSelectStep?: (nodeId: string, step: FlowStep) => void;
  [key: string]: unknown;
};

export type ExecNode = Node<ExecNodeData, "execution">;

// ── Node styling helpers ─────────────────────────────────────

export function getNodeBorderColor(
  execStatus: NodeExecStatus | undefined,
  flowStatus: FlowExecStatus,
): string {
  if (flowStatus === "idle") return "var(--node-header)";
  switch (execStatus) {
    case "running":
      return "var(--gunmetal-50)";
    case "success":
      return "var(--status-healthy)";
    case "failure":
      return "var(--orange)";
    default:
      return "var(--node-header)";
  }
}

export function getNodeOpacity(
  execStatus: NodeExecStatus | undefined,
  flowStatus: FlowExecStatus,
): number {
  if (flowStatus === "idle") return 0.9;
  switch (execStatus) {
    case "running":
      return 1;
    case "success":
    case "failure":
      return 0.9;
    default:
      return 0.3;
  }
}

// ── Flow → ReactFlow nodes ──────────────────────────────────

export function toReactFlowNodes(
  flow: Flow,
  nodeStates: Record<string, NodeExecState>,
  flowStatus: FlowExecStatus,
  onSelectStep?: (nodeId: string, step: FlowStep) => void,
): ExecNode[] {
  return flow.nodes.map((n) => ({
    id: n.id,
    type: "execution" as const,
    position: { ...n.position },
    data: {
      label: n.label,
      steps: n.steps,
      nodeType: n.type,
      nodeId: n.id,
      execState: nodeStates[n.id],
      flowStatus,
      style: n.style,
      onSelectStep,
    },
  }));
}

// ── Flow → ReactFlow edges (initial static styling) ─────────

export function toReactFlowEdges(flow: Flow): Edge[] {
  return flow.edges.map((e) => {
    const isLoop = e.data?.isLoop === true;
    const isConditional = e.data?.transitionType === "conditional";
    const condition = e.data?.condition as string | undefined;

    const label = isConditional && condition ? condition : undefined;

    return {
      id: e.id,
      source: e.source,
      target: e.target,
      type: "smoothstep",
      sourceHandle: isLoop ? "loop-source" : "bottom",
      targetHandle: isLoop ? "loop-target" : "top",
      label,
      labelStyle: label
        ? { fontSize: "var(--text-size-caption)", fill: "var(--muted-foreground)", fontFamily: "inherit" }
        : undefined,
      labelBgStyle: label
        ? { fill: "var(--muted)", stroke: "var(--border)", strokeWidth: 1, rx: 4, ry: 4 }
        : undefined,
      labelBgPadding: label ? ([8, 4] as [number, number]) : undefined,
      style: isLoop
        ? { stroke: "var(--accent-hover)", strokeWidth: 2, strokeDasharray: "6 3" }
        : isConditional
          ? { stroke: "var(--vertical-quality)", strokeWidth: 2 }
          : { stroke: "var(--steel)", strokeWidth: 2 },
      markerEnd: {
        type: MarkerType.ArrowClosed,
        color: isLoop ? "var(--accent-hover)" : isConditional ? "var(--vertical-quality)" : "var(--steel)",
      },
    };
  });
}

// ── Execution-time edge styling ─────────────────────────────

export function updateEdgeStyles(
  edges: Edge[],
  nodeStates: Record<string, NodeExecState>,
  flowStatus: FlowExecStatus,
): Edge[] {
  return edges.map((e) => {
    const isLoop = e.sourceHandle === "loop-source";
    const isConditional = e.label !== undefined;
    const isStartEdge = e.source === "start";
    const srcState = nodeStates[e.source];
    const tgtState = nodeStates[e.target];
    const srcDone = isStartEdge
      ? flowStatus !== "idle"
      : srcState?.status === "success";
    const isEndEdge = e.target === "end";
    const tgtRunning = tgtState?.status === "running";
    const tgtDone = isEndEdge
      ? flowStatus === "completed"
      : tgtState?.status === "success" || tgtState?.status === "failure";

    let stroke = isLoop ? "var(--accent-hover)" : isConditional ? "var(--vertical-quality)" : "var(--steel)";
    let edgeOpacity = flowStatus === "idle" ? 1 : 0.3;
    let animated = false;

    if (srcDone && tgtDone) {
      stroke = "var(--status-healthy)";
      edgeOpacity = 1;
    } else if (srcDone && tgtRunning) {
      stroke = "var(--status-healthy)";
      edgeOpacity = 1;
      animated = true;
    }

    return {
      ...e,
      animated,
      style: {
        stroke,
        opacity: edgeOpacity,
        strokeWidth: 2,
        ...(isLoop ? { strokeDasharray: "6 3" } : {}),
      },
      markerEnd: {
        type: MarkerType.ArrowClosed,
        color: stroke,
      },
    };
  });
}

// ── Utility ─────────────────────────────────────────────────

/** Finds which state node contains a given step ID. */
export function findStateForStep(flow: Flow, stepId: string): string | null {
  for (const node of flow.nodes) {
    if (node.steps?.some((s) => s.id === stepId)) {
      return node.id;
    }
  }
  return null;
}



================================================
FILE: frontend/src/types/index.ts
================================================
import type { ReactNode } from "react";

// ── Flow types (aligned with backend naming) ────────────────

export interface FlowStep {
  id: string;
  skill: string;
  executor: string;
  params?: Record<string, unknown>;
}

export interface FlowNode {
  id: string;
  type: string;           // "state", "start", "end"
  label: string;          // display name
  steps?: FlowStep[];     // steps inside state nodes
  position: { x: number; y: number };
  style?: { width: number; height: number };
}

export interface FlowEdge {
  id: string;
  source: string;
  target: string;
  data?: Record<string, unknown>;
}

export interface Flow {
  id: string;
  name: string;
  loop?: boolean;
  nodes: FlowNode[];
  edges: FlowEdge[];
}

// ── Chat types ──────────────────────────────────────────────

export interface ChatMessage {
  id: string;
  role: "user" | "assistant";
  content: string;
  timestamp: number;
}

// ── Device types ────────────────────────────────────────────

export type DeviceType = "robot" | "camera" | "sensor";
export type DeviceStatus = "connected" | "warning" | "disconnected";

export interface Device {
  id: string;
  name: string;
  vendor: string;
  type: DeviceType;
  status: DeviceStatus;
  ip: string;
}

// ── Step selection (for parameter editor) ───────────────────

export interface SelectedStep {
  nodeId: string;
  step: FlowStep;
}

// ── Node creator (UI-only) ──────────────────────────────────

export interface NodeCreatorState {
  nodeType: string | null;
  task: string | null;
  label: string;
}

// ── Flow execution types ────────────────────────────────────

export type NodeExecStatus = "idle" | "running" | "success" | "failure";

export interface StepExecState {
  status: NodeExecStatus;
  retries?: number;
  error?: string;
  result?: Record<string, unknown>;
}

export interface NodeExecState {
  status: NodeExecStatus;
  durationMs?: number;
  error?: string;
  stepStates?: Record<string, StepExecState>; // Track individual step execution
  currentStep?: string; // Currently executing step ID
}

// Aligned with backend FlowExecutionStatus enum
export type FlowExecStatus = "idle" | "running" | "paused" | "completed" | "error";

// ── WebSocket messages: Server → Client (aligned with backend) ─────

export type ServerMessage =
  | { type: "connected"; message: string; timestamp: number }
  | { type: "flow_started"; flow_id: string; name: string; timestamp: number }
  | { type: "flow_completed"; flow_id: string; status: string; timestamp: number }
  | { type: "flow_paused"; flow_id: string; timestamp: number }
  | { type: "flow_resumed"; flow_id: string; timestamp: number }
  | { type: "flow_aborted"; flow_id: string; timestamp: number }
  | { type: "flow_error"; flow_id: string; error: string; step_id?: string; timestamp: number }
  | { type: "state_entered"; flow_id: string; state: string; timestamp: number }
  | { type: "state_completed"; flow_id: string; state: string; timestamp: number }
  | { type: "loop_restart"; flow_id: string; initial_state: string; timestamp: number }
  | { type: "step_started"; flow_id: string; step_id: string; skill: string; executor: string; timestamp: number }
  | { type: "step_completed"; flow_id: string; step_id: string; result: Record<string, unknown>; retries: number; timestamp: number }
  | { type: "step_error"; flow_id: string; step_id: string; error: string; strategy?: string; timestamp: number }
  | { type: "step_retry"; flow_id: string; step_id: string; attempt: number; max_retries: number; timestamp: number }
  | { type: "step_skipped"; flow_id: string; step_id: string; error: string; strategy: string; timestamp: number }
  | { type: "waiting_condition"; flow_id: string; state: string; timestamp: number }
  | { type: "camera_frame"; frame: string; width: number; height: number; timestamp: number }
  | { type: "bounding_box"; bbox: BoundingBox; frame_width: number; frame_height: number; display_duration_ms: number; timestamp: number }
  | { type: "pong" };

// ── Bounding box types ─────────────────────────────────────

export interface BoundingBox {
  x: number;
  y: number;
  width: number;
  height: number;
  confidence: number;
  class_name: string;
}

export interface BoundingBoxOverlay {
  bbox: BoundingBox;
  frameWidth: number;
  frameHeight: number;
  expiresAt: number;
}
/**
 * Props for the generic ContentPanel component
 */
export interface ContentPanelProps {
  /** Panel title displayed in the header */
  title: string;
  /** Optional subtitle displayed below the title */
  subtitle?: string;
  /** Optional action buttons/elements for the header (right side) */
  actions?: ReactNode;
  /** Optional center content for the header */
  centerActions?: ReactNode;
  /** Panel content */
  children?: ReactNode;
  /** Additional CSS classes for the outer card */
  className?: string;
  /** Additional CSS classes for the content area */
  contentClassName?: string;
  /** Enable scrolling in content area (default: true) */
  scrollable?: boolean;
}




================================================
FILE: scripts/test_yolo.py
================================================
# /// script
# requires-python = ">=3.10"
# dependencies = [
#     "ultralytics",
#     "opencv-python",
#     "pyrealsense2",
# ]
# ///
"""Test YOLO model detection on RealSense camera or image."""

import argparse
import cv2
import numpy as np
from ultralytics import YOLO


def main():
    parser = argparse.ArgumentParser(description="Test YOLO model detection")
    parser.add_argument(
        "--model",
        default="backend/weights/roboflow_logistics.pt",
        help="Path to YOLO model weights",
    )
    parser.add_argument(
        "--image",
        help="Path to test image (if not provided, uses RealSense camera)",
    )
    parser.add_argument(
        "--confidence",
        type=float,
        default=0.3,
        help="Confidence threshold",
    )
    parser.add_argument(
        "--width",
        type=int,
        default=640,
        help="Frame width",
    )
    parser.add_argument(
        "--height",
        type=int,
        default=480,
        help="Frame height",
    )
    args = parser.parse_args()

    print(f"Loading model: {args.model}")
    model = YOLO(args.model)

    # Print available classes
    print(f"\nAvailable classes ({len(model.names)}):")
    for idx, name in model.names.items():
        print(f"  {idx}: {name}")

    if args.image:
        # Single image mode
        print(f"\nRunning detection on: {args.image}")
        results = model(args.image, conf=args.confidence)

        for result in results:
            print(f"\nDetections:")
            for box in result.boxes:
                cls_id = int(box.cls)
                cls_name = model.names[cls_id]
                conf = float(box.conf)
                x1, y1, x2, y2 = box.xyxy[0].tolist()
                print(f"  - {cls_name}: {conf:.2%} at [{x1:.0f}, {y1:.0f}, {x2:.0f}, {y2:.0f}]")

        # Show annotated image
        annotated = results[0].plot()
        cv2.imshow("Detection Result", annotated)
        cv2.waitKey(0)
        cv2.destroyAllWindows()
    else:
        # RealSense camera mode
        import pyrealsense2 as rs

        print(f"\nStarting RealSense camera ({args.width}x{args.height})...")
        print("Press 'q' to quit, 's' to save screenshot")

        # Configure RealSense
        pipeline = rs.pipeline()
        config = rs.config()
        config.enable_stream(rs.stream.color, args.width, args.height, rs.format.rgb8, 30)

        try:
            pipeline.start(config)
            print("RealSense camera started")
        except Exception as e:
            print(f"Error: Could not start RealSense camera: {e}")
            return

        try:
            while True:
                # Wait for frames
                frames = pipeline.wait_for_frames()
                color_frame = frames.get_color_frame()
                if not color_frame:
                    continue

                # Convert to numpy array (RGB)
                frame_rgb = np.asanyarray(color_frame.get_data())
                # Convert to BGR for OpenCV
                frame_bgr = cv2.cvtColor(frame_rgb, cv2.COLOR_RGB2BGR)

                # Run detection
                results = model(frame_bgr, conf=args.confidence, verbose=False)

                # Draw results
                annotated = results[0].plot()

                # Show detection count
                detections = []
                for box in results[0].boxes:
                    cls_id = int(box.cls)
                    detections.append(model.names[cls_id])

                info_text = f"Detections: {len(detections)}"
                if detections:
                    info_text += f" | {', '.join(detections)}"
                cv2.putText(annotated, info_text, (10, 30),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)

                cv2.imshow("YOLO Detection (press 'q' to quit)", annotated)

                key = cv2.waitKey(1) & 0xFF
                if key == ord('q'):
                    break
                elif key == ord('s'):
                    cv2.imwrite("detection_screenshot.jpg", annotated)
                    print("Screenshot saved: detection_screenshot.jpg")
        finally:
            pipeline.stop()
            cv2.destroyAllWindows()


if __name__ == "__main__":
    main()


